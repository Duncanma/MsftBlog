Below are common patterns and best-practices that should be used when creating component context and templates.

## Namespace nested context

If your component can be broken down into distinct parts, organize the structure of your context accordingly. For example, a Dropdown component has a button, a menu, and content inside the menu. Each piece described is represented in the context as nested objects.

dropdown.config.json

```json
{
  "direction": "down",
  "button": {
    "id": "dropdown-default",
    "classes": "dropdown-toggle",
    "text": "Dropdown",
    "color": "secondary",
  },
  "menu": {
    "id": "dropdown-default-menu",
    "links": [
      {
        "text": "Action",
        "href": "#"
      }
    ]
  }
}
```

Any sub-component must have its context contained within an appropriate namespaced object. Here, the dropdown button is a "Button" sub-component with its context defined under the "button" object within the dropdown context.

The dropdown menu, although not considered a sub-component, also has context unique to it. These menu-specific properties are nested under the "menu" object within the dropdown context. This way the "id" of the menu is not confused with another "id" property elsewhere in the dropdown's context (for instance, the button's "id" property).

The dropdown menu also contains content unique to it. The context for this content is nested under "menu". In this case, the menu contains a list of anchor links. Contained within the menu's context is a property "links" which is a list of context objects representing each link.

## Property names

If context directly maps to an HTML property such as `id`, `href`, `src`, `value`, etc, use the same property name in your context. Although it requires some familiarity with HTML, it does enforce a common and consistent naming convention for the majority of properties.

Below are context properties that do not directly map to HTML properties that must be standardized across components.

- [text](#text)
- [content](#content)
- [classes](#classes)
- [attributes](#attributes)

### text
Used to define the text content found between HTML tags. 

*configuration:*
```json
{
  "text": "Featured products"
}
```

*template:*
```hbs
<h2>\{{text}}</h2>
```

*result:*
```html
<h2>Featured products</h2>
```

### content
Used to define a string of escaped HTML content found within an HTML node.

*configuration:*
```json
{
  "content": "Learn more<span class=\"sr-only\"> about new products</span>"
}
```

*template:*
```hbs
<a href="/products">\{{content}}</a>
```

*result:*
```html
<a href="/products">Learn more<span class="sr-only"> about new products</span></a>
```

### classes
A string of classes that gets rendered within the `class` property of an HTML element. The recommended use of the `classes` property is to allow for utilities or other classes that may not be a part of the component to be passed and set on a component.

*configuration:*
```json
{
  "classes": "mt-3 ml-2"
}
```

*template:*
```hbs
<button class="btn btn-secondary \{{classes}}">Close</button>
```

*result:*
```html
<button class="btn btn-secondary mt-3 ml-2">Close</button>
```

### attributes
A JSON formatted object representing miscellaneous HTML properties. This is useful for enabling additional HTML attributes to be set on a component. The object structure also allows for a component to inherit some attributes from one context, while overriding others with a new context. When rendering `attributes` inside the handlebars template, use the helper `htmlAttr` to render the object as HTML attributes on an element.

*configuration:*
```json
{
  "text": false,
  "attributes": [
    "disabled": false,
    "aria-label": "Submit"
  ]
}
```

*template:*
```hbs
<button class="btn" \{{{htmlAttr attributes}}}>\{{text}}</button>
```

*result:*
```html
<button class="btn" aria-label="Submit"></button>
```