const selectors = [
  'input:not([disabled])',
  'select:not([disabled])',
  'textarea:not([disabled])',
  'a[href]',
  'button:not([disabled])',
  'audio[controls]',
  'video[controls]',
  '[contenteditable]:not([contenteditable="false"])'
];

const tabSelectors = [
  ...selectors,
  '[tabindex]:not([tabindex^="-"]):not([disabled])'
];

const focusSelectors = [
  ...selectors,
  '[tabindex]:not([disabled])'
];

const HelpersUtil = {
  /**
  * Returns array of tabbable elements
  * @param {node} node container to search, default is document
  * @returns {Array} returns elements that can be tabbed to using the keyboard
  */
  getTabbableElements(node = document) {
    return Array.from(node.querySelectorAll(tabSelectors.join(', ')));
  },

  /**
  * Checks if a node is a tabbable element
  * @param {node} node the node to compare
  * @returns {boolean} returns true or false depending on whether the node is considered tabbable or not
  */
  isElementTabbable(node) {
    return node.matches(tabSelectors.join(', '));
  },

  getUid() {
    // Convert random number to base 36 (numbers + letters),
    // and grab the first 9 characters after the decimal.
    return Math.random().toString(36).slice(2, 9);
  },

  /**
  * Returns array of focusable elements
  * @param {node} node container to search, default is document
  * @returns {Array} returns elements that can receive focus
  */
  getFocusableElements(node = document) {
    return Array.from(node.querySelectorAll(focusSelectors.join(', ')));
  },

  /**
  * Returns outer height of element, includes element offsetHeight
  * @param {node}       node container to search
  * @param {object}     options
  * @param {string[]}   options.cssSelectors array of css properties
  * @example
  *   const options = { cssSelectors: ['margin', 'padding'] };
  *   const options = { cssSelectors: ['marginTop'] };
  * @returns {number}   returns height value
  */
  getElementOuterHeight(node, options = null) {
    const computedNodeStyles = getComputedStyle(node);
    if (!options) {
      return computedNodeStyles.offsetHeight;
    }

    let outerHeight = node.offsetHeight;
    options.cssSelectors.forEach(selector => {
      // if no values are specified, calculate spacing for the top and bottom
      if (!selector.toLowerCase().includes('top') && !selector.toLowerCase().includes('bottom')) {
        outerHeight += parseInt(computedNodeStyles[selector + 'Top'], 10) + parseInt(computedNodeStyles[selector + 'Bottom'], 10);
      } else if (selector.values.length > 0) {
        outerHeight += parseInt(computedNodeStyles[selector], 10);
      }
    });

    return outerHeight;
  },

  /**
  * Returns outer width of element, includes element offsetWidth
  * @param {node}       node container to search
  * @param {object}     options
  * @param {string[]}   options.cssSelectors array of css properties
  * @example
  *   const options = { cssSelectors: ['margin', 'padding'] };
  *   const options = { cssSelectors: ['marginLeft'] };
  * @returns {number}   returns width value
  */
  getElementOuterWidth(node, options = null) {
    const computedNodeStyles = getComputedStyle(node);
    if (!options) {
      return computedNodeStyles.offsetWidth;
    }

    let outerWidth = node.offsetWidth;
    options.cssSelectors.forEach(selector => {
      // if no values are specifed, calculate spacing for the left and right
      if (!selector.toLowerCase().includes('left') && !selector.toLowerCase().includes('right')) {
        outerWidth += parseInt(computedNodeStyles[selector + 'Left'], 10) + parseInt(computedNodeStyles[selector + 'Right'], 10);
      } else if (selector.values.length > 0) {
        outerWidth += parseInt(computedNodeStyles[selector], 10);
      }
    });

    return outerWidth;
  },

  /**
   * Returns the element pointed to from a data-target attribute
   * @param {node} element element with the data-target attribute
   * @returns {node} returns the element
   */
  getSelectorFromElement(element) {
    let selector = element.getAttribute('data-target');

    if (!selector || selector === '#') {
      const hrefAttr = element.getAttribute('href');
      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';
    }

    try {
      return document.querySelector(selector) ? selector : null;
    } catch {
      return null;
    }
  },

  /**
   * Gets the offset height of the element
   * @param {node} element the element
   * @returns {number} returns the offset height
   */
  reflow(element) {
    return element.offsetHeight;
  },

  /**
   * Gets the full height of the document
   * May be a little dated but this seems to be an established approach
   * https://javascript.info/size-and-scroll-window#width-height-of-the-document
   * @returns {number} the full height of the document
   */
  getDocumentHeight() {
    return Math.max(
      document.body.scrollHeight,
      document.documentElement.scrollHeight,
      document.body.offsetHeight,
      document.documentElement.offsetHeight,
      document.body.clientHeight,
      document.documentElement.clientHeight
    );
  }
};

export default HelpersUtil;
