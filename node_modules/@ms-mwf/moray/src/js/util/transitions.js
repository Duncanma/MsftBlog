const TRANSITION_END = 'transitionend';

/**
 * Gets the transition duration from an element's styles
 * @param {node} element - element
 * @returns {number} - transition duration in milliseconds
 */
const getTransitionDurationFromElement = element => {
  const MILLISECONDS_MULTIPLIER = 1000;

  if (!element) {
    return 0;
  }

  // Get transition-duration of the element
  let transitionDuration = getComputedStyle(element)['transition-duration'];
  let transitionDelay = getComputedStyle(element)['transition-delay'];

  const floatTransitionDuration = parseFloat(transitionDuration);
  const floatTransitionDelay = parseFloat(transitionDelay);

  // Return 0 if element or transition duration is not found
  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  }

  // If multiple durations are defined, take the first
  transitionDuration = transitionDuration.split(',')[0];
  transitionDelay = transitionDelay.split(',')[0];

  return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
};

/**
 * Dispatches a transition-end event.
 * @param {node} element - element on which to dispatch event
 */
const triggerTransitionEnd = element => {
  element.dispatchEvent(new Event(TRANSITION_END));
};

/**
 * Ensures transition-end is triggered on an element.
 * @param {node} element - element on which transition occurs
 * @param {number} duration - transition duration in milliseconds
 */
const emulateTransitionEnd = (element, duration = 0) => {
  let called = false;
  const durationPadding = 5;
  const emulatedDuration = duration + durationPadding;
  function listener() {
    called = true;
    element.removeEventListener(TRANSITION_END, listener);
  }

  element.addEventListener(TRANSITION_END, listener);
  setTimeout(() => {
    if (!called) {
      triggerTransitionEnd(element);
    }
  }, emulatedDuration);
};

export default {
  TRANSITION_END,
  getTransitionDurationFromElement,
  triggerTransitionEnd,
  emulateTransitionEnd
};
