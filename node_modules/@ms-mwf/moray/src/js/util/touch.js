const PointerType = {
  TOUCH: 'touch',
  PEN: 'pen'
};

export const EventName = {
  POINTER_DOWN: 'pointerdown',
  POINTER_UP: 'pointerup',
  TOUCH_START: 'touchstart',
  TOUCH_MOVE: 'touchmove',
  TOUCH_END: 'touchend'
};

export const ClassName = {
  POINTER_EVENT: 'pointer-event'
};

function _handleSwipe() {
  const absDeltax = Math.abs(this.touchDeltaX);

  if (absDeltax <= this.swipeThreshold) {
    return;
  }

  const direction = absDeltax / this.touchDeltaX;

  // swipe left
  if (direction > 0) {
    this.negativeCallback();
  }

  // swipe right
  if (direction < 0) {
    this.positiveCallback();
  }
}

function _swipeStart(event) {
  if (this.pointerEvent && PointerType[event.pointerType.toUpperCase()]) {
    this.touchStartX = event.clientX;
  } else if (!this.pointerEvent) {
    this.touchStartX = event.touches[0].clientX;
  }
}

function _swipeMove(event) {
  // ensure swiping with one touch and not pinching
  if (event.touches && event.touches.length > 1) {
    this.touchDeltaX = 0;
  } else {
    this.touchDeltaX = event.touches[0].clientX - this.touchStartX;
  }
}

function _swipeEnd(event) {
  if (this.pointerEvent && PointerType[event.pointerType.toUpperCase()]) {
    this.touchDeltaX = event.clientX - this.touchStartX;
  }

  _handleSwipe.bind(this)();
}

/**
 * Class for handling touch events.
 */
class TouchUtil {
  /**
   * Create the touch events handler.
   * @param {Object} opts - The touch events options.
   * @param {Node} opts.el - The swipeable DOM node.
   * @param {Function} opts.positiveCallback - Callback function to be called after swiping in a positive direction.
   * @param {Function} opts.negativeCallback - Callback function to be called after swiping in a negative direction.
   * @param {number} [opts.swipeThreshold] - The minimum swipe size
   * @param {string} [opts.pointerEventClassName] - The classname to add for pointer events
   */
  constructor(opts) {
    this.el = opts.el;
    this.positiveCallback = opts.positiveCallback;
    this.negativeCallback = opts.negativeCallback;
    this.swipeThreshold = opts.swipeThreshold || 40;
    this.pointerEventClassName = opts.pointerEventClassName || ClassName.POINTER_EVENT;
    this.touchStartX = 0;
    this.touchDeltaX = 0;
    this.touchSupported = 'ontouchstart' in document.documentElement || Boolean(navigator.maxTouchPoints > 0);
    this.pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);
  }

  /**
   * Add the touch event listeners.
   */
  addEventListeners() {
    if (this.touchSupported) {
      if (this.pointerEvent) {
        this.el.addEventListener(EventName.POINTER_DOWN, _swipeStart.bind(this));
        this.el.addEventListener(EventName.POINTER_UP, _swipeEnd.bind(this));

        this.el.classList.add(this.pointerEventClassName);
      } else {
        this.el.addEventListener(EventName.TOUCH_START, _swipeStart.bind(this));
        this.el.addEventListener(EventName.TOUCH_MOVE, _swipeMove.bind(this));
        this.el.addEventListener(EventName.TOUCH_END, _swipeEnd.bind(this));
      }
    }
  }

  /**
   * Remove the touch event listeners.
   */
  removeEventListeners() {
    if (this.touchSupported) {
      if (this.pointerEvent) {
        this.el.removeEventListener(EventName.POINTER_DOWN, _swipeStart);
        this.el.removeEventListener(EventName.POINTER_UP, _swipeEnd);

        this.el.classList.remove(this.pointerEventClassName);
      } else {
        this.el.removeEventListener(EventName.TOUCH_START, _swipeStart);
        this.el.removeEventListener(EventName.TOUCH_MOVE, _swipeMove);
        this.el.removeEventListener(EventName.TOUCH_END, _swipeEnd);
      }
    }
  }
}

export default TouchUtil;
