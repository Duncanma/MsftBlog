import HelpersUtil from './helpers';

const testDiv = `
  <div id="testDiv">
    <input id="input01" type="text"/>
    <input id="input02" type="text" disabled/>
    <input id="input03" type="text" tabindex="1" disabled/>
    <input id="input04" type="text" tabindex="-1" disabled/>

    <textarea id="text01" >text area</textarea>
    <textarea id="text02" disabled>text area disabled</textarea>

    <a id="link01" href="http://www.microsoft.com">link</a>
    <a id="link02">current link</a>

    <button id="btn01" data-target="#targetDiv">button</button>
    <button id="btn02" disabled>button</button>

    <div id="tabindex0" tabindex="0">tab index 0</div>
    <div id="tabindex1" tabindex="1">tab index 1</div>
    <div id="tabindexNeg1" tabindex="-1">tab index -1</div>
    <div id="tabindexNeg2" tabindex="-2">tab index -2</div>

    <div id="targetDiv"></div>
  </div>
`;

const tabbableIds = [
  'input01',
  'text01',
  'link01',
  'btn01',
  'tabindex0',
  'tabindex1'
];

const nonTabbableIds = [
  'input02',
  'input03',
  'input04',
  'text02',
  'link02',
  'btn02',
  'tabindexNeg1',
  'tabindexNeg2'
];

const focusableIds = [
  ...tabbableIds,
  'tabindexNeg1',
  'tabindexNeg2'
];

describe('HelpersUtil', () => {
  beforeEach(() => {
    document.body.innerHTML = testDiv;
  });
  afterEach(() => {
    document.body.innerHTML = '';
    jest.restoreAllMocks();
  });

  describe('getTabbableElements()', () => {
    it('returns an array of tabbable elements', () => {
      const result = HelpersUtil.getTabbableElements();
      const ids = result.map(el => el.id);

      expect(result).not.toBe('undefined');
      expect(ids.sort()).toEqual(tabbableIds.sort());
    });
  });

  describe('isElementTabbable()', () => {
    test.each(tabbableIds)('returns true for element with id %s', input => {
      const el = document.getElementById(input);
      expect(HelpersUtil.isElementTabbable(el)).toBe(true);
    });
    test.each(nonTabbableIds)('returns false for element with id %s', input => {
      const el = document.getElementById(input);
      expect(HelpersUtil.isElementTabbable(el)).toBe(false);
    });
  });

  describe('getFocusableElements()', () => {
    it('returns an array of focusable elements', () => {
      const result = HelpersUtil.getFocusableElements();
      const ids = result.map(el => el.id);

      expect(result).not.toBe('undefined');
      expect(ids.sort()).toEqual(focusableIds.sort());
    });
  });

  describe('getElementOuterHeight()', () => {
    const originalOffsetHeight = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'offsetHeight');

    beforeAll(() => {
      Object.defineProperty(HTMLElement.prototype, 'offsetHeight', {
        configurable: true,
        value: 200
      });
    });

    afterAll(() => {
      Object.defineProperty(HTMLElement.prototype, 'offsetHeight', originalOffsetHeight);
    });

    it('returns correct height with no passed options', () => {
      const subject = document.getElementById('testDiv');
      jest.spyOn(global, 'getComputedStyle').mockReturnValue({ offsetHeight: 200 });
      expect(HelpersUtil.getElementOuterHeight(subject)).toEqual(200);
    });

    it('returns correct height with options passed in', () => {
      const subject = document.getElementById('testDiv');
      jest.spyOn(global, 'getComputedStyle').mockReturnValue({ marginTop: '20px', marginBottom: '10px' });
      const options = { cssSelectors: ['margin'] };
      expect(HelpersUtil.getElementOuterHeight(subject, options)).toEqual(230);
    });
  });

  describe('getElementOuterWidth()', () => {
    const originalOffsetWidth = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'offsetWidth');

    beforeAll(() => {
      Object.defineProperty(HTMLElement.prototype, 'offsetWidth', {
        configurable: true,
        value: 200
      });
    });

    afterAll(() => {
      Object.defineProperty(HTMLElement.prototype, 'offsetWidth', originalOffsetWidth);
    });

    it('returns correct width with no passed options', () => {
      const subject = document.getElementById('testDiv');
      jest.spyOn(global, 'getComputedStyle').mockReturnValue({ offsetWidth: 300 });
      expect(HelpersUtil.getElementOuterWidth(subject)).toEqual(300);
    });

    it('returns correct width with options passed in', () => {
      const subject = document.getElementById('testDiv');
      jest.spyOn(global, 'getComputedStyle').mockReturnValue({ marginLeft: '10px', marginRight: '10px' });
      const options = { cssSelectors: ['margin'] };
      expect(HelpersUtil.getElementOuterWidth(subject, options)).toEqual(220);
    });
  });

  describe('getSelectorFromElement()', () => {
    it('returns the correct element', () => {
      const subject = document.getElementsByTagName('button')[0];
      expect(HelpersUtil.getSelectorFromElement(subject)).toEqual('#targetDiv');
    });
  });
});
