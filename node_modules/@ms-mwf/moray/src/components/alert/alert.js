import Util from '../../js/util';

const instances = [];

export const Selector = {
  DATA_MOUNT: '.alert-dismissible, [data-mount="alert-dismissible"]',
  DISMISS: '[data-dismiss="alert"]'
};

export const EventName = {
  CLOSE: 'onClose',
  CLOSED: 'onClosed',
  ON_REMOVE: 'onRemove',
  ON_UPDATE: 'onUpdate'
};

export const ClassName = {
  FADE: 'fade',
  SHOW: 'show'
};

function _removeElement(element) {
  element.classList.remove(ClassName.SHOW);

  if (!element.classList.contains(ClassName.FADE)) {
    _destroyElement.bind(this)(element);
    return;
  }

  const transitionDuration = Util.getTransitionDurationFromElement(element);

  element.addEventListener(Util.TRANSITION_END, event => _destroyElement.bind(this)(element, event), { once: true });
  Util.emulateTransitionEnd(element, transitionDuration);
}

function _destroyElement(element) {
  element.dispatchEvent(this[EventName.CLOSED]);
  element.remove();
}

class Alert {
  constructor(opts) {
    this.el = opts.el;
    this.dismiss = this.el.querySelector(Selector.DISMISS);

    // Custom Events
    this[EventName.CLOSE] = new CustomEvent(EventName.CLOSE);
    this[EventName.CLOSED] = new CustomEvent(EventName.CLOSED);

    // Add event handlers
    if (this.dismiss) {
      this.events = [
        {
          el: this.dismiss,
          type: 'click',
          handler: () => {
            this.close();
          }
        }
      ];
      Util.addEvents(this.events);
    }

    instances.push(this);
  }

  /**
   * Perform a close action
   */
  close() {
    const rootElement = this.el;
    rootElement.dispatchEvent(this[EventName.CLOSE]);
    _removeElement.bind(this)(rootElement);
  }

  /**
   * Update instance. Added for API consistency
   */
  update() {
    // Create and dispatch custom event
    this[EventName.ON_UPDATE] = new CustomEvent(EventName.ON_UPDATE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_UPDATE]);
  }

  /**
   * Remove the instance
   */
  remove() {
    Util.removeEvents(this.events);
    const index = instances.indexOf(this);
    instances.splice(index, 1);

    // Create and dispatch custom event
    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_REMOVE]);
  }

  /**
   * Get alert instances.
   * @returns {Object[]} An array of alert instances
   */
  static getInstances() {
    return instances;
  }
}

export default Alert;
