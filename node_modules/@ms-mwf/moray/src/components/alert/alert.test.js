import Alert, { Selector, EventName, ClassName } from './alert';
import Util from '../../js/util';

const alertHtml = `
  <div class="alert alert-dismissible fade show" role="alert" aria-live="polite">
    <div class="alert-content">
      <p>A standard dismissible alert used to politely notify users to new information.</p>
    </div>
    <button type="button" class="close" data-dismiss="alert" aria-label="Close alert" title="Close"></button>
  </div>
`;

document.body.innerHTML = alertHtml;
const el = document.querySelector(Selector.DATA_MOUNT);
const dismiss = document.querySelector(Selector.DISMISS);

jest.useFakeTimers();

describe('Alert', () => {
  let alert;

  beforeEach(() => {
    alert = new Alert({ el });
  });

  afterEach(() => {
    if (alert) {
      alert.remove();
    }
  });

  describe('constructor()', () => {
    it('should create the alert and dismiss elements', () => {
      expect(alert.el).toEqual(el);
      expect(alert.dismiss).toEqual(dismiss);
    });

    it('should call the close method when clicking dismiss', () => {
      alert.close = jest.fn();
      dismiss.click();
      expect(alert.close).toHaveBeenCalled();
    });
  });

  describe('close()', () => {
    describe('close with fade transition', () => {
      beforeEach(() => {
        alert.el.dispatchEvent = jest.fn();
        alert.close();
      });

      it('should trigger the `close` custom event', () => {
        expect(alert.el.dispatchEvent).toBeCalled();
        expect(alert.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.CLOSE);
      });

      it('should trigger transition end event', () => {
        expect(alert.el.classList).not.toContain(ClassName.SHOW);
        jest.runAllTimers(); // complete transitions
        expect(alert.el.dispatchEvent.mock.calls[1][0].type).toBe(Util.TRANSITION_END);
      });
    });

    describe('close without fade transition', () => {
      beforeEach(() => {
        alert.el.classList.remove(ClassName.FADE);
        alert.el.dispatchEvent = jest.fn();
        alert.close();
      });

      it('should trigger the `close` custom event', () => {
        expect(alert.el.dispatchEvent).toBeCalled();
        expect(alert.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.CLOSE);
      });

      it('should remove the alert element', () => {
        expect(alert.el.classList).not.toContain(ClassName.SHOW);
        expect(alert.el.dispatchEvent.mock.calls[1][0].type).toBe(EventName.CLOSED);
      });
    });
  });

  describe('update()', () => {
    it('should trigger the `onUpdate` custom event', () => {
      alert.el.dispatchEvent = jest.fn();
      alert.update();
      expect(alert.el.dispatchEvent).toBeCalled();
      expect(alert.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_UPDATE);
    });
  });

  describe('remove()', () => {
    beforeEach(() => {
      alert.el.dispatchEvent = jest.fn();
      alert.remove();
    });

    it('should remove alert from the list of instances', () => {
      const instances = Alert.getInstances();
      expect(instances.indexOf(alert)).toEqual(-1);
    });

    it('should trigger the `onRemove` custom event', () => {
      expect(alert.el.dispatchEvent).toBeCalled();
      expect(alert.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_REMOVE);
    });
  });
});
