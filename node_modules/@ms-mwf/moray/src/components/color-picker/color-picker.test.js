/* eslint-disable max-nested-callbacks */

import ColorPicker from './color-picker';
import config from './color-picker.config.json';
import ColorPickerControl from './color-picker-control';

jest.mock('./color-picker-control');

const COLOR_CONTROLS = config.context.colors;
const id = 'color-picker-image';
const html = `
  <fieldset class="color-picker" data-controls="${id}">
    <legend class="sr-only">Choose your color</legend>
    ${COLOR_CONTROLS.map(color => `
      <input
        id="color-${color['color-name']}"
        type="radio"
        data-color-picker-image="${color.source}"
        ${color.checked ? 'checked' : ''}>
      <label for="color-${color['color-name']}" aria-hidden="true" title="${color['color-name']}">
        <span class="color-picker-dot" style="background-color: #${color['color-hex']}"></span>
      </label>
    `).join('')}
  </fieldset>
`;

document.body.innerHTML = html;
const fieldsetNode = document.querySelector('fieldset');

describe(ColorPicker.name, () => {
  beforeEach(() => {
    while (ColorPicker.getInstances().length) {
      ColorPicker.getInstances()[0].remove();
    }

    ColorPickerControl.mockClear();
  });

  describe('constructor()', () => {
    describe('image swatch', () => {
      it('should create ColorPickerControls with the proper data', () => {
        document.body.insertAdjacentHTML('afterbegin', `<img id="${id}" src="">`);
        const instance = new ColorPicker({ el: fieldsetNode });

        COLOR_CONTROLS.forEach((_, index) => {
          expect(ColorPickerControl.mock.calls[index][0]).toMatchObject({
            el: fieldsetNode,
            containerTarget: instance.containerTarget
          });
          expect(instance.containerTarget.nodeName.toLowerCase()).toBe('img');
        });
      });
    });

    describe('update()', () => {
      it('should have the right number of controls after removing one and calling update()', () => {
        document.body.innerHTML = html;
        const instance = new ColorPicker({ el: fieldsetNode });
        const targetColorInfo = COLOR_CONTROLS[0];

        fieldsetNode.querySelector(`#color-${targetColorInfo['color-name']}`).remove();
        fieldsetNode.querySelector(`[for="color-${targetColorInfo['color-name']}"]`).remove();
        instance.update();
        expect(instance.controls.length).toBe(COLOR_CONTROLS.length - 1);
      });
      it('should have the right number of controls after adding  one and calling update()', () => {
        document.body.innerHTML = html;
        const instance = new ColorPicker({ el: fieldsetNode });
        const targetColorInfo = COLOR_CONTROLS[0];

        fieldsetNode.insertAdjacentHTML('afterbegin', `
        <input
          id="color-${targetColorInfo['color-name']}"
          type="radio"
          data-color-picker-image="${targetColorInfo.source}"
          ${targetColorInfo.checked ? 'checked' : ''}>
        <label for="color-${targetColorInfo['color-name']}" aria-hidden="true" title="${targetColorInfo['color-name']}">
          <span class="color-picker-dot" style="background-color: #${targetColorInfo['color-hex']}"></span>
        </label>
      `);
        instance.update();
        expect(instance.controls.length).toBe(COLOR_CONTROLS.length);
      });
    });

    describe('colored background swatch', () => {
      it('should create ColorPickerControls with the proper data', () => {
        document.body.innerHTML = html;
        document.body.insertAdjacentHTML('afterbegin', `<div id="${id}"></div>`);

        const instance = new ColorPicker({ el: fieldsetNode });

        COLOR_CONTROLS.forEach((_, index) => {
          expect(ColorPickerControl.mock.calls[index][0]).toMatchObject({
            el: fieldsetNode,
            containerTarget: instance.containerTarget
          });
          expect(instance.containerTarget.nodeName.toLowerCase()).toBe('div');
        });
      });
    });

    describe('NO colored swatch', () => {
      it('should create ColorPickerControls with the proper data', () => {
        document.body.innerHTML = html;
        const instance = new ColorPicker({ el: fieldsetNode });

        COLOR_CONTROLS.forEach((_, index) => {
          expect(ColorPickerControl.mock.calls[index][0]).toMatchObject({
            el: fieldsetNode,
            containerTarget: instance.containerTarget
          });
          expect(instance.containerTarget).toBe(null);
        });
      });
    });

    it('should instantiate the correct number of ColorPickerControls', () => {
      const instance = new ColorPicker({ el: fieldsetNode });

      expect(instance.controls).toHaveLength(COLOR_CONTROLS.length);
      expect(ColorPickerControl).toBeCalledTimes(COLOR_CONTROLS.length);
    });
  });

  describe('getInstances()', () => {
    it('should return 1 ColorPicker instance when called once', () => {
      new ColorPicker({ el: fieldsetNode });

      expect(ColorPicker.getInstances()).toHaveLength(1);
    });

    it('should return 2 ColorPicker instances when called twice', () => {
      // for simulation – do not target the same element IRL
      new ColorPicker({ el: fieldsetNode });
      new ColorPicker({ el: fieldsetNode });

      expect(ColorPicker.getInstances()).toHaveLength(2);
    });
  });

  describe('remove()', () => {
    it('should remove one ColorPicker when called on instance', () => {
      // for simulation – do not target the same element IRL
      new ColorPicker({ el: fieldsetNode });
      new ColorPicker({ el: fieldsetNode });
      new ColorPicker({ el: fieldsetNode });

      const instance2 = ColorPicker.getInstances()[1];
      instance2.remove();

      expect(ColorPicker.getInstances()).toHaveLength(2);
      // ensure the proper instance was deleted
      expect(ColorPicker.getInstances()).not.toContain(instance2);
    });
  });
});
