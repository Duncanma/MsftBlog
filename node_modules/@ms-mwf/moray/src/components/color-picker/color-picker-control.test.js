/* eslint-disable max-nested-callbacks */

import ColorPickerControl, { Attributes, ClassName, EventName } from './color-picker-control';
import { Selector } from './color-picker';
import config from './color-picker.config.json';

const COLOR_CONTROLS = config.context.colors;
const id = 'color-picker-image';
// includes DOM combinations for testing â€“ does not exactly match component template
const html = `
  <img id="${id}" src="">
  <div id="${id}"></div>
  <fieldset class="color-picker" data-controls="${id}">
    <legend class="sr-only">Choose your color</legend>
    ${COLOR_CONTROLS.map(color => `
      <input
        id="color-${color['color-name']}"
        type="radio"
        data-color-picker-image="${color.source}"
        ${color.checked ? 'checked' : ''}>
      <label for="color-${color['color-name']}" aria-hidden="true" title="${color['color-name']}">
        <span class="color-picker-dot" style="background-color: #${color['color-hex']}"></span>
      </label>
    `).join('')}
  </fieldset>
`;

document.body.innerHTML = html;
const controls = document.querySelectorAll(Selector.CONTROL);
const labels = document.querySelectorAll('label');
const divSwatch = document.querySelector('div');
const imgSwatch = document.querySelector('img');

describe(ColorPickerControl.name, () => {
  beforeEach(() => {
    // clear all ColorPickerControl instances
    while (ColorPickerControl.getInstances().length) {
      ColorPickerControl.getInstances()[0].remove();
    }
  });

  describe('constructor()', () => {
    describe('control colors', () => {
      it('should contain label class "color-picker-dot-light" when the color is light', () => {
        new ColorPickerControl({
          el: controls[3] // platinum
        });
        const label = labels[3];

        expect(label.classList).toContain(ClassName.COLOR_LIGHT);
      });

      it('should NOT contain label class "color-picker-dot-light" when the color is dark', () => {
        new ColorPickerControl({
          el: controls[0] // burgundy
        });
        const label = labels[0];

        expect(label.classList).not.toContain(ClassName.COLOR_LIGHT);
      });
    });

    describe('on change', () => {
      // intentionally click different control radios to trigger change events between tests

      describe('with [data-color-picker-image] attribute', () => {
        it('should dispatch an "onChange" event on change', () => {
          const control = controls[1];
          const instance = new ColorPickerControl({
            el: control,
            containerTarget: divSwatch
          });
          instance.containerTarget.dispatchEvent = jest.fn();

          control.click();

          expect(instance.containerTarget.dispatchEvent).toBeCalled();
          expect(instance.containerTarget.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_CHANGE);
        });

        it('should set image source for <img> swatch', () => {
          const control = controls[2];
          const instance = new ColorPickerControl({
            el: control,
            containerTarget: imgSwatch
          });

          control.click();

          expect(instance.containerTarget.attributes.src.value).toBe(COLOR_CONTROLS[2].source);
        });

        it('should set background image for non-<img> swatch', () => {
          const control = controls[3];
          const instance = new ColorPickerControl({
            el: control,
            containerTarget: divSwatch
          });

          control.click();

          expect(instance.containerTarget.style['background-image']).toBe(`url(${COLOR_CONTROLS[3].source})`);
        });
      });

      describe('with NO [data-color-picker-image] attribute', () => {
        it('should NOT dispatch an "onChange" event on change', () => {
          const control = controls[4];
          control.removeAttribute(Attributes.IMAGE);
          const instance = new ColorPickerControl({
            el: control,
            containerTarget: divSwatch
          });
          instance.containerTarget.dispatchEvent = jest.fn();

          control.click();

          expect(instance.containerTarget.dispatchEvent).not.toBeCalled();
        });

        it('should NOT set image source for <img> swatch', () => {
          const control = controls[5];
          control.removeAttribute(Attributes.IMAGE);
          const instance = new ColorPickerControl({
            el: control,
            containerTarget: imgSwatch
          });

          control.click();

          // img src should NOT be changed to clicked control color
          expect(instance.containerTarget.attributes.src.value).not.toBe(COLOR_CONTROLS[5].source);
        });

        it('should NOT reset background image style for background swatch', () => {
          const control = controls[6];
          control.removeAttribute(Attributes.IMAGE);
          const instance = new ColorPickerControl({
            el: control,
            containerTarget: divSwatch
          });

          control.click();

          // background should NOT be changed to clicked control color
          expect(instance.containerTarget.style['background-image']).not.toBe(`url(${COLOR_CONTROLS[6].source})`);
        });
      });
    });
  });

  describe('getInstances()', () => {
    it('should return the proper number of ColorPickerControl instances', () => {
      controls.forEach(control =>
        new ColorPickerControl({
          el: control
        })
      );

      expect(ColorPickerControl.getInstances()).toHaveLength(COLOR_CONTROLS.length);
    });
  });

  describe('remove()', () => {
    it('should remove one ColorPickerControl when called on instance', () => {
      controls.forEach(control =>
        new ColorPickerControl({
          el: control
        })
      );

      const instance2 = ColorPickerControl.getInstances()[1];
      instance2.remove();

      expect(ColorPickerControl.getInstances()).toHaveLength(COLOR_CONTROLS.length - 1);
      // ensure the proper instance was deleted
      expect(ColorPickerControl.getInstances()).not.toContain(instance2);
    });

    it('should dispatch an "onRemove" event when called on instance', () => {
      const control = controls[0];
      const instance = new ColorPickerControl({
        el: control
      });

      instance.el.dispatchEvent = jest.fn();
      instance.remove();

      expect(instance.el.dispatchEvent).toBeCalled();
      expect(instance.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_REMOVE);
    });
  });
});
