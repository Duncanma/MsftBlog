import CharacterCount, { Selector } from './character-count';

const characterCountHtml = `
  <label for="unique-form-id-1">Write something here</label>
  <input class="form-control" type="text" id="unique-form-id-1" maxlength="30">
  <div data-mount="character-count" data-target="#unique-form-id-1" data-status-msg-template="%{remaining} of %{max} characters remaining" data-max-msg-template="Maximum character count reached" data-sr-low-char-warning-lvl="5">
    <span class="text-muted" aria-hidden="true"></span>
    <span class="sr-only" role="status" aria-live="polite" aria-atomic="true"></span>
  </div>

  <label for="unique-form-id-2">Write something here</label>
  <textarea class="form-control  " id="unique-form-id-2" maxlength="160" rows="3"></textarea>
  <div data-mount="character-count" data-target="#unique-form-id-2" data-status-msg-template="%{remaining} of %{max} characters remaining" data-max-msg-template="Maximum character count reached" data-sr-low-char-warning-lvl="5">
    <span class="text-muted" aria-hidden="true"></span>
    <span class="sr-only" role="status" aria-live="polite" aria-atomic="true"></span>
  </div>
`;

describe('CharacterCount without options passed in', () => {
  let instances;
  let inputInstance;
  let textAreaInstance;
  let detectedEventTrigger = '';

  // Set up DOM
  document.body.innerHTML = characterCountHtml;

  beforeAll(() => {
    // init
    document.querySelectorAll(Selector.DATA_MOUNT).forEach(el => {
      new CharacterCount({ el });
    });

    instances = CharacterCount.getInstances();
    inputInstance = instances[0];
    textAreaInstance = instances[1];

    // add custom event listeners
    inputInstance.statusMessage.addEventListener('onUpdate', () => {
      detectedEventTrigger = 'onUpdate';
    });
    inputInstance.statusMessage.addEventListener('onRemove', () => {
      detectedEventTrigger = 'onRemove';
    });
  });

  it('should be initialized', () => {
    expect(instances.length).toEqual(2);

    expect(inputInstance.target.id).toEqual('unique-form-id-1');
    expect(inputInstance.statusMessageTemplate).toEqual('%{remaining} of %{max} characters remaining');
    expect(inputInstance.maxMessageTemplate).toEqual('Maximum character count reached');

    expect(textAreaInstance.target.id).toEqual('unique-form-id-2');
    expect(textAreaInstance.statusMessageTemplate).toEqual('%{remaining} of %{max} characters remaining');
    expect(textAreaInstance.maxMessageTemplate).toEqual('Maximum character count reached');

    expect(inputInstance.statusMessageVisual.innerHTML).toEqual('30 of 30 characters remaining');
    expect(inputInstance.statusMessageSR.innerHTML).toEqual('');

    expect(textAreaInstance.statusMessageVisual.innerHTML).toEqual('160 of 160 characters remaining');
    expect(textAreaInstance.statusMessageSR.innerHTML).toEqual('');
  });

  describe('When the input value is changed', () => {
    beforeAll(() => {
      inputInstance.target.value = '17 character text';
    });

    it('should have the correct status messages, with debouncing', () => {
      setTimeout(() => {
        expect(inputInstance.statusMessageVisual.innerHTML).toEqual('13 of 30 characters remaining');

        // Test debounced screen reader message
        expect(inputInstance.statusMessageSR.innerHTML).toEqual('');
        setTimeout(() => {
          expect(inputInstance.statusMessageSR.innerHTML).toEqual('13 of 30 characters remaining');
        }, 500);
      }, 100);
    });
  });

  describe('When the max character count is reached', () => {
    beforeAll(() => {
      inputInstance.target.value = '30 character text written here';
    });

    it('should have the correct status messages, with correct attributes', () => {
      setTimeout(() => {
        expect(inputInstance.statusMessageVisual.innerHTML).toEqual('Maximum character count reached');
        expect(inputInstance.statusMessageSR.innerHTML).toEqual('Maximum character count reached');

        // Test SR message properties
        expect(inputInstance.statusMessageSR.getAttribute('aria-live')).toEqual('assertive');
      }, 100);
    });
  });

  describe('when target content is changed and .update() is called', () => {
    beforeAll(() => {
      // try to update
      inputInstance.update();
    });

    it('should trigger a custom event', () => {
      expect(detectedEventTrigger).toEqual('onUpdate');
    });
  });

  describe('when an instance is removed', () => {
    beforeAll(() => {
      // try to remove
      inputInstance.remove();
    });

    it('should return the correct number of instances', () => {
      expect(CharacterCount.getInstances().length).toEqual(1);
    });

    it('should trigger a custom event', () => {
      expect(detectedEventTrigger).toEqual('onRemove');
    });
  });
});
