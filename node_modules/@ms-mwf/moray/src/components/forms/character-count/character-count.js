import Util from '../../../js/util';
import { debounce } from 'throttle-debounce';

export const Selector = {
  DATA_MOUNT: '[data-mount="character-count"]'
};

export const EventName = {
  ON_UPDATE: 'onUpdate',
  ON_REMOVE: 'onRemove'
};

const characterCountInstances = [];

const UPDATE_RATE_LIMIT = 400; // rate limit in ms for screen reader announcement

/**
 * Gets the target form element to monitor
 * @returns {Node} The target element
 */
function _getTarget() {
  // Reads selector from data-target attribute
  const selector = Util.getSelectorFromElement(this.statusMessage);

  // There should only be one element targeted, gets the first match
  return document.querySelector(selector);
}

/**
 * Updates the textContent of a node with the most up to date character count status message
 * @param {Node} node The node to update the textContent of
 */
function _updateStatusMessageText(node) {
  const msgTemplate = this.isMaxInputReached() ? this.maxMessageTemplate : this.statusMessageTemplate;
  const inputLength = this.getUserInputLength();

  node.textContent = Util.interpolateString(msgTemplate, {
    remaining: this.inputMaxLength - inputLength,
    entered: inputLength,
    max: this.inputMaxLength
  });
}

/**
 * Updates the visual status message only, immediately
 */
function _updateVisualStatusMessage() {
  _updateStatusMessageText.bind(this)(this.statusMessageVisual);
}

/**
 * Updates the screen reader status message only, immediately
 */
function _updateScreenReaderStatusMessage() {
  _updateStatusMessageText.bind(this)(this.statusMessageSR);
}

/**
 * Computes whether key typed is printable
 * @param {KeyboardEvent} keyboardEventKey
 * @returns {Boolean} Whether the key entered is printable
 */
function _isPrintable(keyboardEventKey) {
  return /^.$/.test(keyboardEventKey);
}

/**
 * Causes the screen reader status message to narrate
 */
function _narrateStatusMessage() {
  this.statusMessageSR.textContent = '';
  setTimeout(() => {
    _updateScreenReaderStatusMessage.bind(this)();
  }, 200);
}

/**
 * Narrates the screen reader status message if the given KeyboardEvent represents a printable character
 * @param {KeyboardEvent} keyboardEvent
 */
function _narrateIfMaxInputAndPrintableKey(keyboardEvent) {
  if (this.isMaxInputReached() && _isPrintable(keyboardEvent.key)) {
    _narrateStatusMessage.bind(this)();
  }
}

class CharacterCount {
  /**
   * Creates a CharacterCount object
   * @param {Object} opts The CharacterCount options
   * @param {HTMLElement} opts.el The node that wraps the status message elements and stores configuration information
   */
  constructor(opts) {
    this.statusMessage = opts.el || opts.statusMessage;

    if (opts.statusMessage) {
      console.warn(
        'Warning: the CharacterCount "statusMessage" option is deprecated and will be removed in favor of "el" in a future version'
      );
    }

    this.statusMessageSR = this.statusMessage.querySelector('.sr-only');
    this.statusMessageVisual = this.statusMessage.querySelector(':not(.sr-only)');

    this.target = _getTarget.bind(this)();
    this.inputMaxLength = Number(this.target.getAttribute('maxLength'));

    this.statusMessageTemplate = this.statusMessage.getAttribute('data-status-msg-template');
    this.maxMessageTemplate = this.statusMessage.getAttribute('data-max-msg-template');
    this.debouncedSRUpdate = debounce(UPDATE_RATE_LIMIT, () => {
      _updateScreenReaderStatusMessage.bind(this)();
    });

    this.srLowCharWarnLvl = this.statusMessage.getAttribute('data-sr-low-char-warning-lvl');
    this.userHasBeenWarned = false;
    this.ariaLiveWasReset = false;

    // Add event handlers
    this.events = [
      { el: this.target, type: 'input', handler: this.updateStatusMessage.bind(this) },
      { el: this.target, type: 'keydown', handler: _narrateIfMaxInputAndPrintableKey.bind(this) },
      { el: this.target, type: 'focus', handler: _narrateStatusMessage.bind(this) }
    ];

    Util.addEvents(this.events);

    // Initialize visual message
    _updateVisualStatusMessage.bind(this)();

    // push to instances list
    characterCountInstances.push(this);
  }

  /**
   * Get the length of the current value of the monitored form element
   * @returns {Number} The length of the value
   */
  getUserInputLength() {
    return this.target.value.length;
  }

  /**
   * Determine whether the max input length has been reached
   * @returns {Boolean} Whether the max input length has been reached
   */
  isMaxInputReached() {
    return this.getUserInputLength() === this.inputMaxLength;
  }

  /**
   * Determine whether the low character warning level has been met
   * @returns {Boolean} Whether the low character warning level has been met
   */
  isInputAtOrBelowLowCharWarnLvl() {
    return this.inputMaxLength - this.getUserInputLength() <= this.srLowCharWarnLvl;
  }

  /**
   * Updates both status messages. The visual one immediatey, the screen reader in a debounced manner.
   */
  updateStatusMessage() {
    this.debouncedSRUpdate();
    _updateVisualStatusMessage.bind(this)();

    if (!this.isMaxInputReached() && this.userHasBeenWarned && !this.ariaLiveWasReset) {
      this.statusMessageSR.setAttribute('aria-live', 'polite');
    }

    if (this.isMaxInputReached() || (!this.userHasBeenWarned && this.isInputAtOrBelowLowCharWarnLvl())) {
      this.debouncedSRUpdate.cancel();
      this.statusMessageSR.setAttribute('aria-live', 'assertive');
      _updateScreenReaderStatusMessage.bind(this)();
    }
  }

  /**
   * Updates the object by re-reading all configuration options stored in the DOM
   */
  update() {
    this.target = _getTarget.bind(this)();
    this.inputMaxLength = Number(this.target.getAttribute('maxLength'));

    this.statusMessageTemplate = this.statusMessage.getAttribute('data-status-msg-template');
    this.maxMessageTemplate = this.statusMessage.getAttribute('data-max-msg-template');
    this.debouncedSRUpdate = debounce(UPDATE_RATE_LIMIT, () => {
      _updateScreenReaderStatusMessage.bind(this)();
    });

    this.srLowCharWarnLvl = this.statusMessage.getAttribute('data-sr-low-char-warning-lvl');
    this.userHasBeenWarned = false;
    this.ariaLiveWasReset = false;

    // Create and dispatch custom event
    this[EventName.ON_UPDATE] = new CustomEvent(EventName.ON_UPDATE, { bubbles: true });
    this.statusMessage.dispatchEvent(this[EventName.ON_UPDATE]);
  }

  /**
   * Removes the CharacterCount instance
   */
  remove() {
    Util.removeEvents(this.events);

    const index = characterCountInstances.indexOf(this);
    characterCountInstances.splice(index, 1);

    // Create and dispatch custom event
    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.statusMessage.dispatchEvent(this[EventName.ON_REMOVE]);
  }

  /**
   * Gets the array of CharacterCount instances
   * @returns {Object[]} Array of CharacterCount instances
   */
  static getInstances() {
    return characterCountInstances;
  }
}

export default CharacterCount;
