import FormValidation, { Selector, ClassName, EventName } from './validation';

const defaultFormHtml = `
<form class="needs-validation" novalidate>
  <div class="form-group">
    <label for="catSelect">* Category</label>
    <div class="custom-select">
      <select class="custom-select-input" id="catSelect" required aria-describedby="select-cat-hint" data-feedback-content="The “Category” field is required." data-feedback="catSelect-feedback">
        <option value=""></option>
        <option value="hardware">Hardware</option>
        <option value="software">Software</option>
      </select>
      <span class="custom-select-arrow"></span>
    </div>
    <p class="form-text text-muted" id="select-cat-hint">select hint text</p>
    <div class="invalid-feedback" id="catSelect-feedback" aria-live="assertive" aria-relevant="additions removals"></div>
  </div>
  <fieldset class="form-group" aria-describedby="hearFeedbackDesc hearFeedback">
    <legend><span aria-hidden="true">*</span> How did you hear about us? (select up to 3)</legend>
    <p class="sr-only" id="hearFeedbackDesc">Required</p>
    <div class="form-check">
        <input type="checkbox" class="form-check-input" id="mwfe651e994" name="hear" value="search" data-feedback-content="Between one and three ways you've heard about us must be selected." data-feedback="hearFeedback" data-form-check-required="true" data-form-check-max="3">
        <label class="form-check-label" for="mwfe651e994">Search engine</label>
    </div>
    <div class="form-check">
        <input type="checkbox" class="form-check-input" id="mwf0caf68a2" name="hear" value="social">
        <label class="form-check-label" for="mwf0caf68a2">Social media</label>
    </div>
    <div class="form-check">
        <input type="checkbox" class="form-check-input" id="mwf00ca3ffd" name="hear" value="tv">
        <label class="form-check-label" for="mwf00ca3ffd">TV</label>
    </div>
    <div class="form-check">
        <input type="checkbox" class="form-check-input" id="mwf2350b3a2" name="hear" value="mouth">
        <label class="form-check-label" for="mwf2350b3a2">Word of mouth</label>
    </div>
    <div class="invalid-feedback ml-4" id="hearFeedback" aria-live="assertive" aria-relevant="additions removals"></div>
  </fieldset>
  <div class="form-group">
    <label for="input-title">* Title</label>
    <input class="form-control" type="text" id="input-title" type="text" required aria-describedby="input-title-hint" data-feedback-content="The “Title” field is required." data-feedback="input-title-feedback">
    <p class="form-text text-muted" id="input-title-hint">Sample hint text</p>
    <div class="invalid-feedback" id="input-title-feedback" aria-live="assertive" aria-relevant="additions removals"></div>
  </div>
  <div class="form-group ">
    <div class="custom-control custom-checkbox ">
      <input type="checkbox" class="custom-control-input " id="terms-element" name="terms" required aria-describedby="terms-feedback" data-feedback-content="You must read the terms and conditions." data-feedback="terms-feedback" aria-invalid="false">
        <label class="custom-control-label " for="terms-element"><span class="custom-control-glyph" aria-hidden="true"></span><span aria-hidden="true">*</span> I have read the terms and conditions.</label>
      </div>
    <div class="invalid-feedback " id="terms-feedback"></div>
  </div>
  <div class="alert glyph-prepend glyph-prepend-warning bg-transparent ml-n4 mt-n3 pb-0" data-mount="feedback-list">
    <div class="alert-content">
      <h3 class="h6">Please resolve the following errors before submission</h3>
      <ol class="list-unstyled"></ol>
    </div>
  </div>
  <button class="btn btn-primary form-group" type="submit">Submit</button>
</form>
`;

const fullFeedbackContainer = `
<div class="alert mb-3" data-mount="feedback-list">
  <span class="glyph-prepend glyph-prepend-warning" aria-hidden="true"></span>
  <section aria-label="Error information" class="alert-content">
    <h3 class="h6 ">Please resolve the following errors before submission</h3>
    <ol class="list-unstyled">
      <li>item 1</li>
      <li>item 2</li>
      <li>item 3</li>
    </ol>
  </section>
</div>
`;

const emptyFeedbackContainer = `
<div class="alert mb-3" data-mount="feedback-list">
  <span class="glyph-prepend glyph-prepend-warning" aria-hidden="true"></span>
  <section aria-label="Error information" class="alert-content">
    <h3 class="h6 ">Please resolve the following errors before submission</h3>
    <ol class="list-unstyled"></ol>
  </section>
</div>
`;

document.body.innerHTML = defaultFormHtml;

const el = document.querySelector(Selector.DATA_MOUNT);
const feedbackListContainer = document.querySelector(Selector.FEEDBACK_LIST);
const feedbackListFocusEl = feedbackListContainer.querySelector('h3');
const textInput = el.querySelector('#input-title');
const select = el.querySelector('#catSelect');
const checkboxes = el.querySelectorAll('.form-check-input');
const checkbox1 = checkboxes[0];
const checkbox2 = checkboxes[1];
const singleRequiredCheckbox = el.querySelector('#terms-element');

describe('Form validation', () => {
  let formValidation;
  jest.useFakeTimers();

  beforeEach(() => {
    formValidation = new FormValidation({ el });

    // reset form field values
    textInput.value = '';
    select.selectedIndex = -1;
    checkbox1.checked = false;
    checkbox2.checked = false;
    singleRequiredCheckbox.checked = false;
  });

  afterEach(() => {
    if (formValidation) {
      formValidation.remove();
    }
  });

  describe('constructor()', () => {
    it('should set define the element in the feedback list to receive focus first', () => {
      expect(formValidation.feedbackListFocusEl).toBe(feedbackListFocusEl);
      expect(feedbackListFocusEl.tabIndex).toEqual(-1);
    });

    it('should hide the empty feedback list', () => {
      expect(feedbackListContainer.classList).toContain(ClassName.DISPLAY.NONE);
    });

    it('should run `onSubmit` when the form is submitted', () => {
      formValidation.onSubmit = jest.fn();
      el.dispatchEvent(new Event('submit'));
      expect(formValidation.onSubmit).toBeCalled();
    });

    describe('input events', () => {
      beforeEach(() => {
        formValidation.validate = jest.fn();
      });

      it('should run validate on blur', () => {
        textInput.dispatchEvent(new FocusEvent('blur'));
        jest.runAllTimers();

        expect(formValidation.validate).toBeCalled();
      });

      it('should run validate on change', () => {
        select.dispatchEvent(new Event('change'));
        jest.runAllTimers();

        expect(formValidation.validate).toBeCalled();
      });
    });
  });

  describe('validate()', () => {
    describe('if input is invalid', () => {
      beforeEach(() => {
        formValidation.validate(textInput);
      });

      afterEach(() => {
        formValidation.feedbackList.innerHTML = '';
      });

      it('should set correct classes and attributes on the input', () => {
        expect(formValidation.isInputValid(textInput)).toEqual(false);
        expect(textInput.classList).toContain(ClassName.IS_INVALID);
        expect(textInput.getAttribute('aria-invalid')).toEqual('true');
      });

      it('should set correct classes and attributes on the feedback element', () => {
        const textInputFeedbackEl = el.querySelector('#input-title-feedback');
        expect(textInputFeedbackEl.classList).toContain(ClassName.IS_INVALID);
        expect(textInputFeedbackEl.textContent).toEqual(textInput.feedback.content);
      });

      it('should create and display a feedback link', () => {
        expect(feedbackListContainer.classList).not.toContain(ClassName.DISPLAY.NONE);
        expect(feedbackListContainer.querySelectorAll('a')[0].hash).toEqual(`#${textInput.id}`);
      });

      it('should set correct classes and attributes on all inputs in a group', () => {
        formValidation.validate(checkbox1);

        expect(formValidation.isInputValid(checkbox1)).toEqual(false);
        // eslint-disable-next-line max-nested-callbacks
        checkboxes.forEach(checkbox => {
          expect(checkbox.classList).toContain(ClassName.IS_INVALID);
          expect(checkbox.getAttribute('aria-invalid')).toEqual('true');
        });
      });
    });

    describe('if input is valid', () => {
      beforeEach(() => {
        textInput.value = 'test';
        formValidation.validate(textInput);
      });

      it('should set correct classes and attributes on the input', () => {
        expect(formValidation.isInputValid(textInput)).toEqual(true);
        expect(textInput.classList).not.toContain(ClassName.IS_INVALID);
        expect(textInput.getAttribute('aria-invalid')).toEqual('false');
      });

      it('should not create or display a feedback link', () => {
        expect(feedbackListContainer.classList).toContain(ClassName.DISPLAY.NONE);
        expect(feedbackListContainer.querySelectorAll('a').length).toEqual(0);
      });

      it('should set correct classes and attributes on all inputs in a group', () => {
        checkbox1.checked = true;
        formValidation.validate(checkbox1);

        expect(formValidation.isInputValid(checkbox1)).toEqual(true);
        // eslint-disable-next-line max-nested-callbacks
        checkboxes.forEach(checkbox => {
          expect(checkbox.classList).not.toContain(ClassName.IS_INVALID);
          expect(checkbox.getAttribute('aria-invalid')).toEqual('false');
        });
      });
    });

    describe('if input is invalid then valid', () => {
      it('should add and remove the feedback link', () => {
        // Trigger invalid state
        formValidation.validate(textInput);

        expect(formValidation.isInputValid(textInput)).toEqual(false);
        expect(feedbackListContainer.classList).not.toContain(ClassName.DISPLAY.NONE);
        expect(feedbackListContainer.querySelectorAll('a')[0].hash).toEqual(`#${textInput.id}`);

        // Trigger valid state
        textInput.value = 'test';
        formValidation.validate(textInput);

        expect(formValidation.isInputValid(textInput)).toEqual(true);
        expect(feedbackListContainer.classList).toContain(ClassName.DISPLAY.NONE);
        expect(feedbackListContainer.querySelectorAll('a').length).toEqual(0);
      });

      it('should add and remove the feedback link for grouped inputs', () => {
        // Trigger invalid state
        formValidation.validate(checkbox1);

        expect(formValidation.isInputValid(checkbox1)).toEqual(false);
        expect(feedbackListContainer.classList).not.toContain(ClassName.DISPLAY.NONE);
        expect(feedbackListContainer.querySelectorAll('a')[0].hash).toEqual(`#${checkbox1.id}`);

        // Trigger valid state
        checkbox2.checked = true;
        formValidation.validate(checkbox1);

        expect(formValidation.isInputValid(checkbox1)).toEqual(true);
        expect(feedbackListContainer.classList).toContain(ClassName.DISPLAY.NONE);
        expect(feedbackListContainer.querySelectorAll('a').length).toEqual(0);
      });
    });
  });

  describe('isInputValid()', () => {
    it('should return false if input is not valid', () => {
      expect(formValidation.isInputValid(textInput)).toEqual(false);
    });

    it('should return false if a checkbox group is invalid', () => {
      expect(formValidation.isInputValid(checkbox1)).toEqual(false);
    });

    it('should return true if a checkbox group is valid', () => {
      checkbox2.checked = true;
      expect(formValidation.isInputValid(checkbox1)).toEqual(true);
    });
  });

  describe('isFormValid()', () => {
    it('should return false if any inputs are invalid', () => {
      expect(formValidation.isFormValid()).toEqual(false);
    });

    it('should return true if all inputs are valid', () => {
      textInput.value = 'test';
      select.selectedIndex = 1;
      checkbox1.checked = true;
      singleRequiredCheckbox.checked = true;

      expect(formValidation.isFormValid()).toEqual(true);
    });
  });

  describe('isFormEmpty()', () => {
    it('should return true is no form fields have been filled', () => {
      expect(formValidation.isFormEmpty()).toEqual(true);
    });

    it('should return false if a radio or checkbox is checked', () => {
      checkbox1.checked = true;
      expect(formValidation.isFormEmpty()).toEqual(false);
    });

    it('should return false if a text input has a value', () => {
      textInput.value = 'test';
      expect(formValidation.isFormEmpty()).toEqual(false);
    });
  });

  describe('onSubmit()', () => {
    beforeEach(() => {
      formValidation.validate = jest.fn();
      formValidation.el.dispatchEvent = jest.fn();
      formValidation.el.submit = jest.fn();
    });

    it('should validate each input', () => {
      const e = { preventDefault: jest.fn() };
      const inputs = el.querySelectorAll(Selector.INPUTS);
      formValidation.onSubmit(e);
      expect(formValidation.validate.mock.calls.length).toEqual(inputs.length);
    });

    it('should trigger the `on valid` custom event if the form is valid', () => {
      textInput.value = 'test';
      select.selectedIndex = 1;
      checkbox1.checked = true;
      singleRequiredCheckbox.checked = true;
      const e = { preventDefault: jest.fn() };
      formValidation.onSubmit(e);

      expect(formValidation.isFormValid()).toEqual(true);
      expect(formValidation.el.dispatchEvent).toBeCalled();
      expect(formValidation.el.dispatchEvent.mock.calls[0][0].type).toEqual(EventName.ON_VALID);
    });

    it('should submit the form if it is valid, form submission is allowed and the form is not empty or empty forms are allowed', () => {
      textInput.value = 'test';
      select.selectedIndex = 1;
      checkbox1.checked = true;
      singleRequiredCheckbox.checked = true;

      const e = { preventDefault: jest.fn() };
      formValidation.onSubmit(e);

      expect(formValidation.isFormValid()).toEqual(true);
      expect(formValidation.el.submit).toBeCalled();
    });

    it('should not submit the form if it is valid but empty', () => {
      textInput.required = false;
      select.required = false;
      singleRequiredCheckbox.required = false;
      [].slice.call(formValidation.inputs).forEach(input => {
        if (input.group) {
          input.group.requiredMin = 0;
        }
      });

      const e = { preventDefault: jest.fn() };
      formValidation.onSubmit(e);

      expect(formValidation.isFormValid()).toEqual(true);
      expect(formValidation.el.submit).not.toBeCalled();

      // reset state
      formValidation.allowEmptySubmit = false;
      textInput.required = true;
      select.required = true;
      singleRequiredCheckbox.required = true;
      [].slice.call(formValidation.inputs).forEach(input => {
        if (input.group) {
          input.group.requiredMin = 1;
        }
      });
    });

    it('should submit the form if it is valid, empty and empty submit is allowed', () => {
      textInput.required = false;
      select.required = false;
      singleRequiredCheckbox.required = false;
      [].slice.call(formValidation.inputs).forEach(input => {
        if (input.group) {
          input.group.requiredMin = 0;
        }
      });
      formValidation.allowEmptySubmit = true;

      const e = { preventDefault: jest.fn() };
      formValidation.onSubmit(e);

      expect(formValidation.isFormValid()).toEqual(true);
      expect(formValidation.el.submit).toBeCalled();

      // reset state
      formValidation.allowEmptySubmit = false;
      textInput.required = true;
      select.required = true;
      singleRequiredCheckbox.required = true;
      [].slice.call(formValidation.inputs).forEach(input => {
        if (input.group) {
          input.group.requiredMin = 1;
        }
      });
    });

    it('should not submit the form if it is valid but form submission is prevented', () => {
      textInput.value = 'test';
      select.selectedIndex = 1;
      checkbox1.checked = true;
      singleRequiredCheckbox.checked = true;
      formValidation.preventFormSubmission = true;

      const e = { preventDefault: jest.fn() };
      formValidation.onSubmit(e);

      expect(formValidation.isFormValid()).toEqual(true);
      expect(formValidation.el.submit).not.toBeCalled();

      // reset state
      formValidation.preventFormSubmission = false;
    });

    it('should focus on the feedback list if the form is invalid', () => {
      const e = { preventDefault: jest.fn() };
      formValidation.onSubmit(e);

      expect(formValidation.isFormValid()).toEqual(false);
      expect(document.activeElement).toEqual(feedbackListFocusEl);
    });
  });

  describe('update()', () => {
    beforeEach(() => {
      formValidation.el.dispatchEvent = jest.fn();
      formValidation.el.submit = jest.fn();
    });

    it('should trigger the `onUpdate` custom event', () => {
      formValidation.update();

      expect(formValidation.el.dispatchEvent).toBeCalled();
      expect(formValidation.el.dispatchEvent.mock.calls[0][0].type).toEqual(EventName.ON_UPDATE);
    });

    it('should submit form when `preventFormSubmission` is set to false', () => {
      textInput.value = 'test';
      select.selectedIndex = 1;
      checkbox1.checked = true;
      singleRequiredCheckbox.checked = true;

      formValidation.update({ preventFormSubmission: false });

      const e = { preventDefault: jest.fn() };
      formValidation.onSubmit(e);

      expect(formValidation.el.submit).toBeCalled();
    });

    it('should not submit form when `preventFormSubmission` is set to true', () => {
      textInput.value = 'test';
      select.selectedIndex = 1;
      checkbox1.checked = true;

      formValidation.update({ preventFormSubmission: true });
      const e = { preventDefault: jest.fn() };
      formValidation.onSubmit(e);

      expect(formValidation.el.submit).not.toBeCalled();
    });

    it('should not submit form when `allowEmptySubmit` is set to true', () => {
      textInput.required = false;
      select.required = false;
      [].slice.call(formValidation.inputs).forEach(input => {
        if (input.group) {
          input.group.requiredMin = 0;
        }
      });

      formValidation.update({ allowEmptySubmit: true });
      const e = { preventDefault: jest.fn() };
      formValidation.onSubmit(e);

      expect(formValidation.el.submit).not.toBeCalled();
    });

    it('should not submit form when `allowEmptySubmit` is set to false', () => {
      textInput.required = false;
      select.required = false;
      [].slice.call(formValidation.inputs).forEach(input => {
        if (input.group) {
          input.group.requiredMin = 0;
        }
      });

      formValidation.update({ allowEmptySubmit: false });
      const e = { preventDefault: jest.fn() };
      formValidation.onSubmit(e);

      expect(formValidation.el.submit).not.toBeCalled();
    });

    // Property `preventFormSubmission` takes precedence over `allowEmptySubmit`
    it('should not submit form when `allowEmptySubmit` is set to true, but `preventFormSubmission` is also set to true', () => {
      textInput.required = false;
      select.required = false;
      [].slice.call(formValidation.inputs).forEach(input => {
        if (input.group) {
          input.group.requiredMin = 0;
        }
      });

      formValidation.update({ allowEmptySubmit: true, preventFormSubmission: true });
      const e = { preventDefault: jest.fn() };
      formValidation.onSubmit(e);

      expect(formValidation.el.submit).not.toBeCalled();
    });

    it('should display feedback list when updated and there are items on the list', () => {
      const feedbackListContainerElement = document.createElement('div');
      feedbackListContainerElement.innerHTML = fullFeedbackContainer;

      formValidation.update({ feedbackListContainer: feedbackListContainerElement });

      expect(formValidation.feedbackListContainer.classList).not.toContain(ClassName.DISPLAY.NONE);
    });

    it('should not display feedback list when updated and there are no items on the list', () => {
      const feedbackListContainerElement = document.createElement('div');
      feedbackListContainerElement.innerHTML = emptyFeedbackContainer;

      formValidation.update({ feedbackListContainer: feedbackListContainerElement });

      expect(formValidation.feedbackListContainer.classList).toContain(ClassName.DISPLAY.NONE);
    });
  });

  describe('remove()', () => {
    beforeEach(() => {
      formValidation.el.dispatchEvent = jest.fn();
      formValidation.remove();
    });

    it('should remove form validation from the list of instances', () => {
      const instances = FormValidation.getInstances();
      expect(instances.indexOf(formValidation)).toEqual(-1);
    });

    it('should trigger the `onRemove` custom event', () => {
      expect(formValidation.el.dispatchEvent).toBeCalled();
      expect(formValidation.el.dispatchEvent.mock.calls[0][0].type).toEqual(EventName.ON_REMOVE);
    });
  });

  describe('getInstances()', () => {
    it('should return an array of all form validation instances', () => {
      expect(FormValidation.getInstances()).toHaveLength(1);
    });
  });
});
