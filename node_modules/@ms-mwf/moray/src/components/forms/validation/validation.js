import Util from '../../../js/util';

export const Selector = {
  DATA_MOUNT: '.needs-validation, [data-mount="validation"]',
  INPUTS: 'input, select, textarea',
  SUBMIT: '[type="submit"]',
  FEEDBACK_LIST: '[data-mount="feedback-list"]',
  FEEDBACK_EL: 'data-feedback',
  FEEDBACK_CONTENT: 'data-feedback-content',
  CHECKBOX_REQUIRED: 'data-form-check-required',
  CHECKBOX_MAX: 'data-form-check-max'
};

export const EventName = {
  ON_VALID: 'onValid',
  ON_REMOVE: 'onRemove',
  ON_UPDATE: 'onUpdate'
};

export const ClassName = {
  DISPLAY: {
    NONE: 'd-none'
  },
  IS_INVALID: 'is-invalid'
};

const formValidations = [];

/**
 * Private functions.
 */

/**
 * Create link to input field with feedback at bottom of form
 * @param {Node} input - The form input field.
 */
function _createFeedbackLink(input) {
  if (!input.feedback.link) {
    const feedbackItem = document.createElement('li');
    const feedbackLink = document.createElement('a');
    const feedbackTextNode = document.createTextNode(input.feedback.content);

    feedbackLink.setAttribute('href', `#${input.id}`);
    input.feedback.focusControls = new Util.FocusControls({ el: feedbackLink });
    feedbackLink.append(feedbackTextNode);
    feedbackItem.append(feedbackLink);
    input.feedback.link = feedbackItem;
    if (input.group) {
      input.group.siblings.forEach(sibling => {
        sibling.feedback.link = feedbackItem;
        sibling.feedback.focusControls = input.feedback.focusControls;
      });
    }
  }

  this.feedbackList.append(input.feedback.link);
  if (!input.feedback.focusControls) {
    input.feedback.focusControls = new Util.FocusControls({ el: input.feedback.link.querySelector('a') });
  }

  input.feedback.linkRemoved = false;
  if (input.group) {
    input.group.siblings.forEach(sibling => {
      sibling.feedback.linkRemoved = false;
    });
  }

  this.feedbackListContainer.classList.remove(ClassName.DISPLAY.NONE);
}

/**
 * Remove link to input field with feedback at bottom of form
 * @param {Node} input - The form input field.
 */
function _removeFeedbackLink(input) {
  if (input.group) {
    input.group.siblings.forEach(sibling => {
      sibling.feedback.linkRemoved = true;
      sibling.feedback.focusControls.remove();
    });
  } else {
    input.feedback.linkRemoved = true;
    input.feedback.focusControls.remove();
  }

  input.feedback.link.remove();

  if (this.feedbackList.children.length === 0) {
    this.feedbackListContainer.classList.add(ClassName.DISPLAY.NONE);
  }
}

/**
 * Generate feedback data object from data attrbutes
 * @param {Node} input - The form input field.
 * @returns {Object} Object with feedback data.
 */
function _getFeedbackData(input) {
  const feedback = {
    id: input.getAttribute(Selector.FEEDBACK_EL)
  };

  if (feedback.id) {
    feedback.content = input.getAttribute(Selector.FEEDBACK_CONTENT);
    feedback.el = this.el.querySelector(`#${feedback.id}`);
    feedback.linkRemoved = true;
  }

  return feedback;
}

/**
 * Events for when input is valid
 * @param {Node} input - The form input field.
 */
function _onValid(input) {
  input.classList.remove(ClassName.IS_INVALID);
  input.setAttribute('aria-invalid', false);

  if (input.group) {
    input.group.siblings.forEach(sibling => {
      sibling.classList.remove(ClassName.IS_INVALID);
      sibling.setAttribute('aria-invalid', false);
    });
  }

  if (input.feedback.el) {
    input.feedback.el.classList.remove(ClassName.IS_INVALID);
    input.feedback.el.textContent = '';

    if (this.feedbackList && input.feedback.link && !input.feedback.linkRemoved) {
      _removeFeedbackLink.bind(this)(input);
    }
  }
}

/**
 * Events for when input is invalid
 * @param {Node} input - The form input field.
 * @param {Object} feedback - The feedback options.
 * @param {Node} feedback.el - The input feedback element.
 * @param {string} feedback.content - The feedback content.
 */
function _onInvalid(input) {
  input.classList.add(ClassName.IS_INVALID);
  input.setAttribute('aria-invalid', true);

  if (input.group) {
    input.group.siblings.forEach(sibling => {
      sibling.classList.add(ClassName.IS_INVALID);
      sibling.setAttribute('aria-invalid', true);
    });
  }

  if (input.feedback.el && input.feedback.content) {
    input.feedback.el.classList.add(ClassName.IS_INVALID);
    input.feedback.el.textContent = input.feedback.content;
    if (this.feedbackList && input.feedback.linkRemoved) {
      _createFeedbackLink.bind(this)(input);
    }
  }
}

/**
 * Generate group data object from input
 * @param {Node} input - The form input field.
 * @returns {Object} Object with group data.
 */
function _inputCheckReducer(input) {
  const { name, type } = input;
  return [].slice.call(this.inputs).reduce((obj, _input) => {
    if (_input.type === type && _input.name === name) {
      if (obj.siblings) {
        obj.siblings.push(_input);
      } else {
        obj.siblings = [_input];
      }

      const requiredMin = _input.getAttribute(Selector.CHECKBOX_REQUIRED);
      const maxValid = _input.getAttribute(Selector.CHECKBOX_MAX);
      // Selector.CHECKBOX_REQUIRED attribute accepts either a boolean or integer
      // If it's a boolean convert to an integer
      if (requiredMin) {
        let requiredMinInt = Number(requiredMin);
        if (isNaN(requiredMinInt)) {
          requiredMinInt = requiredMin === 'true' ? 1 : 0;
        }

        obj.requiredMin = requiredMinInt;
      }

      if (maxValid) {
        const maxValidInt = Number(maxValid);
        const maxValidIntIsNaN = isNaN(maxValidInt);
        if (!maxValidIntIsNaN) {
          obj.maxValid = maxValidInt;
        }
      }

      if (_input.getAttribute(Selector.FEEDBACK_EL)) {
        if (obj.feedback) {
          obj.feedback.push(_input);
        } else {
          obj.feedback = [_input];
        }
      }
    }

    return obj;
  }, {});
}

/**
 * Setup inputs with required data.
 * @param {Node} input - The form input field.
 */
function _inputInit(input) {
  const { type, required } = input;
  let feedbackEl = input;

  if (required) {
    // the default aria-invalid attribute is false but some screenreaders do not respect this
    input.setAttribute('aria-invalid', false);
  }

  if (type === 'radio' || type === 'checkbox') {
    const group = _inputCheckReducer.bind(this)(input);
    const { feedback, ..._group } = group;

    if (_group.siblings.length > 1) {
      input.group = _group;
    }

    if (feedback) {
      feedbackEl = feedback[0];
    }
  }

  input.feedback = _getFeedbackData.bind(this)(feedbackEl);
}

/**
 * Set first element to recieve focus in the feedback list
 */
function _setFeedbackListFocusEl() {
  const tagNames = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P'];
  const prevEl = this.feedbackList.previousElementSibling;

  this.feedbackListFocusEl = this.feedbackListContainer;
  if (prevEl && tagNames.indexOf(prevEl.tagName) > -1) {
    this.feedbackListFocusEl = prevEl;
  }

  this.feedbackListFocusEl.tabIndex = -1;
}

/**
 * Unset current element to receive focus in the feedbacklist
 */
function _unsetFeedbackListFocusEl() {
  this.feedbackListFocusEl.removeAttribute('tabIndex');
}

// Moved event declarations outside of constructor for calling in update.
/**
 * Adds submit event to events array
 */
function _setupSubmitEvent() {
  this.events.push({
    el: this.el,
    type: 'submit',
    handler: e => {
      this.onSubmit(e);
    }
  });
}

/**
 * Adds blur and change events for all input, select, and textarea elements to events array
 */
function _setupInputEvents() {
  // Set up inputs
  this.inputs.forEach(input => {
    _inputInit.bind(this)(input);

    this.events.push(
      {
        el: input,
        type: 'blur',
        handler: () => {
          setTimeout(() => {
            this.validate(input, true);
          }, 0);
        }
      },
      {
        el: input,
        type: 'change',
        handler: () => {
          this.validate(input, true);
        }
      }
    );
  });
}

/**
 * Class representing form validation.
 */
class FormValidation {
  /**
   * Initialize form validation.
   * @param {Object} opts - The form validation options
   * @param {Node} opts.el - The form DOM node
   * @param {Boolean} opts.preventFormSubmission - Flag to prevent form submission
   * @param {Boolean} opts.allowEmptySubmit - Flag that determines whether to allow empty forms to submit
   * @param {Node} opts.feedbackListContainer - The feedback list container DOM node
   */
  constructor(opts) {
    this.el = opts.el;
    // Property `preventFormSubmission` takes precedence over `allowEmptySubmit`
    this.preventFormSubmission = opts.preventFormSubmission || this.el.dataset.preventFormSubmission !== undefined;
    this.allowEmptySubmit = opts.allowEmptySubmit || this.el.dataset.allowEmptySubmit !== undefined;
    this.inputs = this.el.querySelectorAll(Selector.INPUTS);
    this.submit = this.el.querySelector(Selector.SUBMIT);
    this.feedbackListContainer = opts.feedbackListContainer || this.el.querySelector(Selector.FEEDBACK_LIST);
    if (this.feedbackListContainer) {
      this.feedbackList = this.feedbackListContainer.querySelector('ol');
      _setFeedbackListFocusEl.call(this);
    }

    this.events = [];
    _setupSubmitEvent.call(this);

    formValidations.push(this);

    // Hide empty feedback list
    if (this.feedbackList && this.feedbackList.children.length === 0) {
      this.feedbackListContainer.classList.add(ClassName.DISPLAY.NONE);
    }

    _setupInputEvents.call(this);

    // Add event handlers.
    Util.addEvents(this.events);

    // Create custom events.
    this[EventName.ON_VALID] = new CustomEvent(EventName.ON_VALID, { bubbles: true, cancelable: true });
  }

  /**
   * Validate form input
   * @param {Node} input - The form input field.
   * @param {boolean} onlyOnValid - Only runs if valid.
   */
  validate(input, onlyOnValid) {
    const activeEl = document.activeElement;
    if (!input.name || input.name !== activeEl.name) {
      if (this.isInputValid(input)) {
        _onValid.bind(this)(input);
      } else if (!onlyOnValid) {
        _onInvalid.bind(this)(input);
      }
    }
  }

  /**
   * Check if input is valid
   * @param {Node} input - The form input field.
   * @returns {Boolean} - true if input is valid.
   */
  isInputValid(input) {
    // Radio and check groups
    if (input.group && (input.group.requiredMin || input.group.maxValid)) {
      // get number of checked inputs in the group
      const checked = input.group.siblings.filter(sibling => sibling.checked === true);
      // compare against required min or max
      if (
        (input.group.requiredMin && checked.length < input.group.requiredMin) ||
        (input.group.maxValid && checked.length > input.group.maxValid)
      ) {
        return false;
      }

      return true;
    }

    return input.checkValidity();
  }

  /**
   * Check if form is valid
   * @returns {Boolean} - true if all form inputs are valid.
   */
  isFormValid() {
    const checkValidity = [].slice.call(this.inputs).some(input => {
      return this.isInputValid(input) === false;
    });
    return !checkValidity;
  }

  /**
   * Check if form is empty
   * @returns {Boolean} - false if any form inputs are checked or have a value.
   */
  isFormEmpty() {
    const notEmpty = [].slice.call(this.inputs).some(input => {
      const { type, value, checked } = input;
      if (type === 'radio' || type === 'checkbox') {
        if (checked) {
          return true;
        }
      } else if (value !== null && value !== undefined && value.trim().length) {
        return true;
      }

      return false;
    });
    return !notEmpty;
  }

  /**
   * Submit form
   * @param {Event} e - The event object.
   */
  onSubmit(e) {
    e.preventDefault();
    this.inputs.forEach(input => {
      this.validate(input);
    });

    if (this.isFormValid()) {
      this.el.dispatchEvent(this[EventName.ON_VALID]);
      if (!this.preventFormSubmission && (!this.isFormEmpty() || this.allowEmptySubmit)) {
        this.el.submit();
      }
    } else if (this.feedbackListFocusEl) {
      this.feedbackListFocusEl.focus();
    }
  }

  /**
   * Update form validation.
   * @param {Object} opts - The form validation options
   * @param {Boolean} opts.preventFormSubmission - Flag to prevent form submission
   * @param {Node} opts.feedbackListContainer - The feedback list container DOM node
   * @param {Boolean} opts.allowEmptySubmit - Flag that determines whether to allow empty forms to submit
   */
  update(opts = {}) {
    if (opts) {
      this.inputs = this.el.querySelectorAll(Selector.INPUTS);
      this.submit = this.el.querySelector(Selector.SUBMIT);

      // Remove event handlers
      Util.removeEvents(this.events);

      // Rebuild events array
      this.events = [];
      _setupSubmitEvent.call(this);
      _setupInputEvents.call(this);

      Util.addEvents(this.events);

      // Property `preventFormSubmission` takes precedence over `allowEmptySubmit`
      if (opts.preventFormSubmission) {
        this.preventFormSubmission = opts.preventFormSubmission;
      }

      if (opts.feedbackListContainer) {
        _unsetFeedbackListFocusEl.call(this);
        this.feedbackListContainer = opts.feedbackListContainer;
        this.feedbackList = this.feedbackListContainer.querySelector('ol');
        _setFeedbackListFocusEl.call(this);

        if (this.feedbackList.children.length === 0) {
          this.feedbackListContainer.classList.add(ClassName.DISPLAY.NONE);
        } else {
          this.feedbackListContainer.classList.remove(ClassName.DISPLAY.NONE);
        }
      }

      if (opts.allowEmptySubmit) {
        this.allowEmptySubmit = opts.allowEmptySubmit;
      }
    }

    // Create and dispatch custom event
    this[EventName.ON_UPDATE] = new CustomEvent(EventName.ON_UPDATE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_UPDATE]);
  }

  /**
   * Remove the form validation.
   */
  remove() {
    // Remove event handlers
    Util.removeEvents(this.events);

    // Remove this form validation reference from array of instances
    const index = formValidations.indexOf(this);
    formValidations.splice(index, 1);

    // Create and dispatch custom event
    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_REMOVE]);
  }

  /**
   * Get an array of form validation instances.
   * @returns {Object[]} Array of form validation instances.
   */
  static getInstances() {
    return formValidations;
  }
}

export default FormValidation;
