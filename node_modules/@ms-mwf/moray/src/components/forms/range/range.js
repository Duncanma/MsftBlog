import Util from '../../../js/util';
import { throttle } from 'throttle-debounce';

export const Selector = {
  DATA_MOUNT: '[data-mount="range"]',
  MAXTEXT: 'maxtext',
  MINTEXT: 'mintext',
  VALUETEXT: 'valuetext'
};

export const ClassName = {
  TOOLTIP: 'custom-range-tooltip',
  DISABLED: 'disabled'
};

export const EventName = {
  ON_UPDATE: 'onUpdate',
  ON_REMOVE: 'onRemove',
  CHANGE: 'change',
  INPUT: 'input',
  POINTERMOVE: 'pointermove',
  RESIZE: 'resize'
};

const ranges = [];

/**
 * Private functions.
 */
function _getValuetext(value) {
  if (value === this.min && this.valueTextTemplates[Selector.MINTEXT]) {
    return Util.interpolateString(this.valueTextTemplates[Selector.MINTEXT], { value });
  }

  if (value === this.max && this.valueTextTemplates[Selector.MAXTEXT]) {
    return Util.interpolateString(this.valueTextTemplates[Selector.MAXTEXT], { value });
  }

  if (this.valueTextTemplates[Selector.VALUETEXT]) {
    return Util.interpolateString(this.valueTextTemplates[Selector.VALUETEXT], { value });
  }

  return value;
}

function _setValuetext() {
  this.el.setAttribute('aria-valuetext', this.getValuetext(this.el.value));
}

function _getValueTextTemplates() {
  const templates = {};
  templates[Selector.VALUETEXT] = this.el.dataset[Selector.VALUETEXT] || null;
  templates[Selector.MINTEXT] = this.el.dataset[Selector.MINTEXT] || null;
  templates[Selector.MAXTEXT] = this.el.dataset[Selector.MAXTEXT] || null;
  return templates;
}

function _createTooltip() {
  const wrapper = document.createElement('div');
  const span = document.createElement('span');
  wrapper.classList.add(ClassName.TOOLTIP);
  wrapper.setAttribute('aria-hidden', 'true');
  wrapper.append(span);
  this.el.before(wrapper);
  return { wrapper, span };
}

function _updateTooltip() {
  const ratio = (this.el.value - this.min) / (this.max - this.min);
  const thumbWidth = 24; // Shadow DOM
  const inputWidth = this.el.offsetWidth;
  this.tooltip.span.textContent = this.el.value;
  const spanWidth = this.tooltip.span.offsetWidth;
  const offset = ratio * (inputWidth - thumbWidth) - spanWidth / 2 + thumbWidth / 2;
  const direction = Util.isBiDirectional() ? 'right' : 'left';
  this.tooltip.span.style[direction] = `${offset}px`;

  if (this.el.hasAttribute('disabled')) {
    this.el.parentElement.classList.add(ClassName.DISABLED);
  } else {
    this.el.parentElement.classList.remove(ClassName.DISABLED);
  }
}

/**
 * Class representing a range slider.
 */
class Range {
  /**
   * Create the range slider.
   * @param {Object} opts - The range options.
   * @param {Node} opts.el - The range DOM node.
   * @param {Function} [opts.onInput] - Function to override the range input handler.
   * @param {Function} [opts.getValuetext] - Function that returns the aria-valuetext value for a particular range value.
   * @param {Object} [opts.valueTextTemplates] - Object containing string templates for maxtext, mintext, and valuetext.
   * @param {Object} [opts.tooltip] - Object containing references to two Nodes: the tooltip wrapper and span (text container).
   */
  constructor(opts) {
    this.el = opts.el;
    this.min = this.el.min || 0; // HTML default
    this.max = this.el.max || 100; // HTML default
    this.onInput = opts.onInput || _updateTooltip.bind(this);
    this.getValuetext = opts.getValuetext || _getValuetext.bind(this);
    this.valueTextTemplates = opts.valueTextTemplates || _getValueTextTemplates.call(this);

    // IE provides its own built-in tooltip
    const isIE = Util.detectIE() && Util.detectIE() <= 11;
    this.tooltip = isIE || opts.tooltip === null ? null : opts.tooltip || _createTooltip.call(this);

    if (this.tooltip) {
      // Perform initial tooltip setup
      this.onInput();

      // Add tooltip event handlers
      this.tooltipEvents = {
        inputEvent: { el: this.el, type: EventName.INPUT, handler: this.onInput },
        changeEvent: { el: this.el, type: EventName.CHANGE, handler: this.onInput }, // Required for iOS/VoiceOver
        windowEvent: { el: window, type: EventName.RESIZE, handler: throttle(100, this.onInput) }
      };

      Util.addEvents(Object.values(this.tooltipEvents));
    }

    // Set the initial aria-valuetext
    _setValuetext.call(this);

    // Both change and pointermove are required to update aria-valuetext properly in various SR/device combos
    // See https://github.com/w3c/aria-practices/pull/1757
    this.valueTextEvents = {
      changeEvent: { el: this.el, type: EventName.CHANGE, handler: _setValuetext.bind(this) },
      pointerEvent: { el: this.el, type: EventName.POINTERMOVE, handler: throttle(250, _setValuetext.bind(this)) }
    };

    Util.addEvents(Object.values(this.valueTextEvents));

    ranges.push(this);
  }

  /**
   * Update the range.
   * @param {Object} [opts] - The range options.
   * @param {Function} [opts.onInput] - Function to override the range input handler.
   * @param {Function} [opts.getValuetext] - Function that returns the aria-valuetext value for a particular range value.
   * @param {Object} [opts.valueTextTemplates] - Object containing string templates for maxtext, mintext, and valuetext.
   * @param {Object} [opts.tooltip] - Object containing references to two Nodes: the tooltip wrapper and span (text container).
   */
  update(opts = {}) {
    // Only update the input event handler if the tooltip exists
    if (opts.onInput && this.tooltip) {
      Util.removeEvents(Object.values(this.tooltipEvents));
      this.onInput = opts.onInput;
      this.tooltipEvents = {
        inputEvent: { el: this.el, type: EventName.INPUT, handler: this.onInput },
        changeEvent: { el: this.el, type: EventName.CHANGE, handler: this.onInput }, // Required for iOS/VoiceOver
        windowEvent: { el: window, type: EventName.RESIZE, handler: throttle(100, this.onInput) }
      };
      Util.addEvents(Object.values(this.tooltipEvents));
    }

    if (opts.getValuetext) {
      this.getValuetext = opts.getValuetext;
    }

    if (opts.valueTextTemplates) {
      this.valueTextTemplates = opts.valueTextTemplates;
    }

    if (opts.tooltip === null || opts.tooltip) {
      if (opts.tooltip === null) {
        // Remove the tooltip DOM node and event listeners
        this.tooltip.wrapper.remove();
        Util.removeEvents(Object.values(this.tooltipEvents));
      }

      this.tooltip = opts.tooltip;
    }

    if (this.tooltip) {
      // Min and max may have changed, perform tooltip setup again
      this.onInput();
    }

    // Set the initial aria-valuetext
    _setValuetext.call(this);

    // Create and dispatch custom event
    this[EventName.ON_UPDATE] = new CustomEvent(EventName.ON_UPDATE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_UPDATE]);
  }

  /**
   * Remove the range.
   */
  remove() {
    Util.removeEvents(Object.values(this.valueTextEvents));

    if (this.tooltip) {
      Util.removeEvents(Object.values(this.tooltipEvents));
    }

    const index = ranges.indexOf(this);
    ranges.splice(index, 1);

    // Create and dispatch custom event
    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_REMOVE]);
  }

  /**
   * Get an array of range instances.
   * @returns {Object[]} Array of range instances.
   */
  static getInstances() {
    return ranges;
  }
}

export default Range;
