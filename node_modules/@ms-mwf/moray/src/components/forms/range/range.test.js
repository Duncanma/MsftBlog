import Range, { Selector, ClassName, EventName } from './range';

const rangeHtml =
  `<div class="custom-range">
    <input type="range"
      class="custom-range-input"
      min="0"
      max="10"
      step="1"
      value="5"
      data-mount="range"
      data-valuetext="Quantity of %{value}"
      data-mintext="Minimum quantity %{value}"
      data-maxtext="Maximum quantity %{value}"
    >
  </div>
  <p id="custom-tooltip"><span></span></p>
  `;

document.body.innerHTML = rangeHtml;

const el = document.querySelector(Selector.DATA_MOUNT);
const wrapper = document.querySelector('#custom-tooltip');
const span = wrapper.querySelector('span');

describe('Range', () => {
  let range;
  let realDispatchEvent;
  let onChangeValue;

  beforeEach(() => {
    // Reset HTML element value and custom tooltip text content
    el.value = 5;
    span.textContent = '';

    range = new Range({ el });

    realDispatchEvent = range.el.dispatchEvent;

    // Add event listener to get passed value from onChange event
    range.el.addEventListener(EventName.ON_CHANGE, event => {
      onChangeValue = event.detail.value;
    });
  });

  afterEach(() => {
    range.el.dispatchEvent = realDispatchEvent;

    if (range) {
      range.remove();
    }
  });

  describe('constructor()', () => {
    it('should create the range element', () => {
      expect(range.el).toEqual(el);
      expect(range.value).toEqual('5');
      expect(range.min).toEqual('0');
      expect(range.max).toEqual('10');
    });

    it('should create the tooltip element', () => {
      expect(range.tooltip.wrapper.classList).toContain(ClassName.TOOLTIP);
      expect(range.tooltip.wrapper.getAttribute('aria-hidden')).toEqual('true');
      expect(range.tooltip.span.textContent).toEqual('5');
    });

    it('should add the aria-valuetext attribute', () => {
      expect(range.el.getAttribute('aria-valuetext')).toEqual('Quantity of 5');
    });

    it('should update the tooltip and valuetext when the value changes', () => {
      range.el.value = 3;
      range.el.dispatchEvent(new Event(EventName.INPUT));
      range.el.dispatchEvent(new Event(EventName.CHANGE));
      expect(range.tooltip.span.textContent).toEqual('3');
      expect(range.el.getAttribute('aria-valuetext')).toEqual('Quantity of 3');
    });

    it('should use the mintext and maxtext templates for aria-valuetext', () => {
      range.el.value = 0;
      range.el.dispatchEvent(new Event(EventName.CHANGE));
      expect(range.el.getAttribute('aria-valuetext')).toEqual('Minimum quantity 0');
      range.el.value = 10;
      range.el.dispatchEvent(new Event(EventName.CHANGE));
      expect(range.el.getAttribute('aria-valuetext')).toEqual('Maximum quantity 10');
    });

    it('should dispatch the `onChange` event when the value changes', () => {
      range.el.value = 9;
      range.el.dispatchEvent(new Event(EventName.CHANGE));
      expect(onChangeValue).toBe('9');
    });
  });

  describe('update()', () => {
    let mockOnInput;
    let mockGetValuetext;
    let newOpts;

    beforeEach(() => {
      mockOnInput = jest.fn();
      mockGetValuetext = jest.fn();

      newOpts = {
        onInput: mockOnInput,
        getValuetext: mockGetValuetext,
        tooltip: { wrapper, span },
        valueTextTemplates: {}
      };
    });

    afterEach(() => {
      jest.clearAllMocks();
    });

    it('should trigger the `onUpdate` custom event', () => {
      range.el.dispatchEvent = jest.fn();
      range.update();
      expect(range.el.dispatchEvent).toBeCalled();
      expect(range.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_UPDATE);
    });

    it('should not dispatch the `onChange` event when the value doesn\'t change', () => {
      range.el.dispatchEvent = jest.fn();
      range.update();
      expect(range.el.dispatchEvent).toHaveBeenCalledTimes(1);
    });

    it('should be able to be updated with options passed in', () => {
      range.update(newOpts);
      expect(range.onInput).toBe(newOpts.onInput);
      expect(range.getValuetext).toBe(newOpts.getValuetext);
      expect(range.tooltip).toBe(newOpts.tooltip);
      expect(mockOnInput).toHaveBeenCalledTimes(1);
    });

    it('should update the aria-valuetext using the getValuetext function', () => {
      mockGetValuetext.mockReturnValue(3);
      range.update(newOpts);
      range.el.value = 3;
      range.el.dispatchEvent(new Event(EventName.CHANGE));
      expect(range.el.getAttribute('aria-valuetext')).toEqual('3');
      expect(mockGetValuetext).toHaveBeenCalledTimes(1);
    });

    it('should allow the tooltip to be removed via the update function', () => {
      range.update({
        tooltip: null
      });

      expect(range.tooltip).toBeNull();
      expect(document.querySelector(ClassName.TOOLTIP)).toBeNull();
    });
  });

  describe('remove()', () => {
    beforeEach(() => {
      range.el.dispatchEvent = jest.fn();
      range.remove();
    });

    it('should remove range from the list of instances', () => {
      const instances = Range.getInstances();
      expect(instances.indexOf(range)).toEqual(-1);
    });

    it('should trigger the `onRemove` custom event', () => {
      expect(range.el.dispatchEvent).toBeCalled();
      expect(range.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_REMOVE);
    });
  });
});

describe('Range with options passed in', () => {
  let range;

  beforeEach(() => {
    el.value = 5;
    span.textContent = '';

    range = new Range({
      el,
      tooltip: { wrapper, span },
      valueTextTemplates: {
        mintext: 'mintext %{value}',
        maxtext: 'maxtext %{value}'
      }
    });
  });

  afterEach(() => {
    if (range) {
      range.remove();
    }
  });

  it('should populate our custom tooltip element', () => {
    expect(span.textContent).toEqual('5');
  });

  it('should use the mintext and maxtext templates for aria-valuetext', () => {
    range.el.value = 0;
    range.el.dispatchEvent(new Event(EventName.CHANGE));
    expect(range.el.getAttribute('aria-valuetext')).toEqual('mintext 0');
    range.el.value = 10;
    range.el.dispatchEvent(new Event(EventName.CHANGE));
    expect(range.el.getAttribute('aria-valuetext')).toEqual('maxtext 10');
  });

  it('should add the disabled class to the tooltip when disabled', () => {
    range.el.setAttribute('disabled', '');
    range.update();
    expect(range.el.parentElement.classList).toContain(ClassName.DISABLED);
  });
});

describe('Range loaded in IE11', () => {
  const userAgentGetter = jest.spyOn(window.navigator, 'userAgent', 'get');
  let range;

  beforeEach(() => {
    // Set the userAgent to be IE11
    userAgentGetter.mockReturnValue('Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko');
    range = new Range({ el });
  });

  afterEach(() => {
    if (range) {
      range.remove();
    }
  });

  describe('constructor()', () => {
    it('should not create the tooltip element in IE11', () => {
      expect(range.el).toEqual(el);
      expect(range.tooltip).toBeNull();
    });
  });
});
