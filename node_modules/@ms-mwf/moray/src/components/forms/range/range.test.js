import Range, { Selector, ClassName, EventName } from './range';

const rangeHtml =
  `<div class="custom-range">
    <input type="range"
      class="custom-range-input"
      min="0"
      max="10"
      step="1"
      value="5"
      data-mount="range"
      data-valuetext="Quantity of %{value}"
      data-mintext="Minimum quantity %{value}"
      data-maxtext="Maximum quantity %{value}"
    >
  </div>`;

const mockFn = jest.fn();
let instances;
let eventValue = '';

describe('Range with no options passed in', () => {
  let wrapper;
  let span;

  beforeAll(() => {
    // Set up our document body
    document.body.innerHTML = rangeHtml;

    document.querySelectorAll(Selector.DATA_MOUNT).forEach(node => {
      new Range({ el: node });
    });

    instances = Range.getInstances();

    // Setup event listeners for custom events
    instances[0].el.addEventListener(EventName.ON_UPDATE, () => {
      eventValue = 'updated';
    });
    instances[0].el.addEventListener(EventName.ON_REMOVE, () => {
      eventValue = 'removed';
    });
  });

  afterAll(() => {
    document.body.innerHTML = '';
  });

  it('should be able to be initialized', () => {
    expect(instances.length).toEqual(1);
    expect(instances[0].el.value).toEqual('5');
    expect(instances[0].min).toEqual('0');
    expect(instances[0].max).toEqual('10');
  });

  it('should create the tooltip element', () => {
    expect(instances[0].tooltip.wrapper.classList).toContain(ClassName.TOOLTIP);
    expect(instances[0].tooltip.wrapper.getAttribute('aria-hidden')).toEqual('true');
    expect(instances[0].tooltip.span.textContent).toEqual('5');
  });

  it('should add the aria-valuetext attribute', () => {
    expect(instances[0].el.getAttribute('aria-valuetext')).toEqual('Quantity of 5');
  });

  it('should update the tooltip when the value changes', () => {
    instances[0].el.value = 3;
    instances[0].el.dispatchEvent(new Event(EventName.INPUT));
    instances[0].el.dispatchEvent(new Event(EventName.CHANGE));
    expect(instances[0].tooltip.span.textContent).toEqual('3');
    expect(instances[0].el.getAttribute('aria-valuetext')).toEqual('Quantity of 3');
  });

  it('should use the mintext and maxtext templates for aria-valuetext', () => {
    instances[0].el.value = 0;
    instances[0].el.dispatchEvent(new Event(EventName.CHANGE));
    expect(instances[0].el.getAttribute('aria-valuetext')).toEqual('Minimum quantity 0');
    instances[0].el.value = 10;
    instances[0].el.dispatchEvent(new Event(EventName.CHANGE));
    expect(instances[0].el.getAttribute('aria-valuetext')).toEqual('Maximum quantity 10');
  });

  it('should be able to be updated with options passed in', () => {
    wrapper = document.createElement('p');
    span = document.createElement('span');
    wrapper.append(span);
    document.body.append(wrapper);

    instances[0].update({
      onInput: mockFn,
      getValuetext: value => value,
      tooltip: { wrapper, span }
    });

    expect(eventValue).toEqual('updated');
    expect(instances[0].tooltip.wrapper.nodeName).toEqual('P');
  });

  it('should call the mock onInput when the input event is fired', () => {
    instances[0].el.dispatchEvent(new Event(EventName.INPUT));
    expect(mockFn).toHaveBeenCalledTimes(2);
  });

  it('should update the aria-valuetext using the getValuetext function', () => {
    instances[0].el.value = 3;
    instances[0].el.dispatchEvent(new Event(EventName.CHANGE));
    expect(instances[0].el.getAttribute('aria-valuetext')).toEqual('3');
  });

  it('should allow the tooltip to be removed via the update function', () => {
    instances[0].update({
      tooltip: null
    });

    expect(instances[0].tooltip).toBeNull();
    expect(document.querySelector(ClassName.TOOLTIP)).toBeNull();
  });

  it('should be able to be removed', () => {
    instances[0].remove();
    expect(Range.getInstances().length).toEqual(0);
    expect(eventValue).toEqual('removed');
  });
});

describe('Range with options passed in', () => {
  beforeAll(() => {
    // Set up our document body
    document.body.innerHTML = rangeHtml;

    const wrapper = document.createElement('p');
    const span = document.createElement('span');
    wrapper.append(span);
    document.body.append(wrapper);

    document.querySelectorAll(Selector.DATA_MOUNT).forEach(node => {
      new Range({
        el: node,
        tooltip: { wrapper, span },
        valueTextTemplates: {
          mintext: 'mintext %{value}',
          maxtext: 'maxtext %{value}'
        }
      });
    });

    instances = Range.getInstances();
  });

  afterAll(() => {
    document.body.innerHTML = '';
  });

  it('should be able to be initialized', () => {
    expect(instances.length).toEqual(1);
    expect(instances[0].el.value).toEqual('5');
    expect(instances[0].min).toEqual('0');
    expect(instances[0].max).toEqual('10');
  });

  it('should create the tooltip element', () => {
    expect(instances[0].tooltip.span.textContent).toEqual('5');
  });

  it('should add the aria-valuetext attribute', () => {
    expect(instances[0].el.getAttribute('aria-valuetext')).toEqual('5');
  });

  it('should use the mintext and maxtext templates for aria-valuetext', () => {
    instances[0].el.value = 0;
    instances[0].el.dispatchEvent(new Event(EventName.CHANGE));
    expect(instances[0].el.getAttribute('aria-valuetext')).toEqual('mintext 0');
    instances[0].el.value = 10;
    instances[0].el.dispatchEvent(new Event(EventName.CHANGE));
    expect(instances[0].el.getAttribute('aria-valuetext')).toEqual('maxtext 10');
  });

  it('should add the disabled class to the tooltip when disabled', () => {
    instances[0].el.setAttribute('disabled', '');
    instances[0].update();
    expect(instances[0].el.parentElement.classList).toContain(ClassName.DISABLED);
  });

  it('should be able to be removed', () => {
    instances[0].remove();
    expect(Range.getInstances().length).toEqual(0);
    expect(eventValue).toEqual('removed');
  });
});

describe('Range loaded in IE11', () => {
  // Set the userAgent to be IE11
  const userAgentGetter = jest.spyOn(window.navigator, 'userAgent', 'get');

  beforeAll(() => {
    // Set up our document body
    document.body.innerHTML = rangeHtml;

    userAgentGetter.mockReturnValue('Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko');

    document.querySelectorAll(Selector.DATA_MOUNT).forEach(node => {
      new Range({ el: node });
    });

    instances = Range.getInstances();
  });

  afterAll(() => {
    document.body.innerHTML = '';
  });

  it('should be able to be initialized and not have a tooltip', () => {
    expect(instances.length).toEqual(1);
    expect(instances[0].el.value).toEqual('5');
    expect(instances[0].min).toEqual('0');
    expect(instances[0].max).toEqual('10');
    expect(instances[0].tooltip).toBeNull();
  });
});
