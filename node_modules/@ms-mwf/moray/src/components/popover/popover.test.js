
import Popover, { Default, EventName } from './popover';
import Util from '../../js/util';

const popoverContent = 'Test content with a <a href="#" id="menuDefaultLink">link</a>.';
const popoverContentNoHTML = 'Test content without any HTML tags.';

const popoverDefaultHtml =
  '<button id="controlDefault" aria-controls="menuDefault">Popover trigger</button>' +
  '<div class="popover" id="menuDefault" role="dialog" aria-labelledby="controlDefault">' +
    '<div class="popover-content">' +
      '<div class="popover-body">' +
        `<p>${popoverContent}</p>` +
      '</div>' +
    '</div>' +
  '</div>';

const popoverAltHtml =
  '<button id="controlAlt" aria-controls="menuAlt" data-alignment="start" data-placement="bottom" data-close-label="Custom close text">Popover trigger</button>' +
  '<div class="popover" id="menuAlt" role="dialog" aria-labelledby="controlAlt">' +
    '<div class="popover-content">' +
      '<div class="popover-body">' +
        `<p>${popoverContent}</p>` +
      '</div>' +
    '</div>' +
  '</div>';

const popoverControlOnlyHtml =
  `<button id="controlOnly" data-content="${popoverContentNoHTML}" data-close-label="Custom close text">Popover trigger</button>`;

const enterKeyPressed = new KeyboardEvent('keydown', { keyCode: Util.keyCodes.ENTER, bubbles: true });
const spaceBarPressed = new KeyboardEvent('keydown', { keyCode: Util.keyCodes.SPACE, bubbles: true });
const escKeyPressed = new KeyboardEvent('keydown', { keyCode: Util.keyCodes.ESC, bubbles: true });
const clickEvent = new MouseEvent('click', { bubbles: true, cancelable: true });
const mouseDownEvent = new MouseEvent('mousedown', { bubbles: true, cancelable: true });
const focusInEvent = new MouseEvent('focusin', { bubbles: true, cancelable: true });

// Set up our document body
document.body.innerHTML = popoverDefaultHtml + popoverAltHtml + popoverControlOnlyHtml;

describe('Popover', () => {
  let popoverDefault;

  beforeEach(() => {
    // Initialize popover
    popoverDefault = new Popover({
      el: document.querySelector('#controlDefault')
    });
  });

  afterEach(() => {
    // Remove the instance for garbage collection
    popoverDefault.remove();
  });

  it('should be initialized', () => {
    const instances = Popover.getInstances();
    expect(instances.indexOf(popoverDefault)).not.toEqual(-1);
    expect(popoverDefault.el.id).toEqual('controlDefault');
    expect(popoverDefault.menu.id).toEqual('menuDefault');
    expect(popoverDefault.placement).toEqual('right');
    expect(popoverDefault.alignment).toEqual('center');
    expect(popoverDefault.offset).toEqual(16);
    expect(popoverDefault.enableReflow).toEqual(true);
    expect(popoverDefault.enableFade).toEqual(true);
    expect(popoverDefault.shown).toEqual(false);
  });

  it('should create a close button if none is present', () => {
    const closeBtn = popoverDefault.menu.querySelector('.close');
    expect(closeBtn).not.toBeNull();
    expect(closeBtn.getAttribute('aria-label')).toEqual(Default.CLOSE_LABEL);
  });

  it('should create an arrow element', () => {
    expect(popoverDefault.arrow instanceof HTMLElement).toEqual(true);
    expect(popoverDefault.arrow.classList.contains('arrow')).toEqual(true);
  });

  describe('with a menu created using `data-content`', () => {
    let popoverControl;

    beforeEach(() => {
      popoverControl = new Popover({
        el: document.querySelector('#controlOnly')
      });
    });

    afterEach(() => {
      popoverControl.remove();
    });

    it('should create a menu on initialization', () => {
      const contents = popoverControl.el.getAttribute('data-content');
      const closeLabel = popoverControl.el.getAttribute('data-close-label');
      const menuBody = popoverControl.menu.querySelector('.popover-body');
      const closeBtn = popoverControl.menu.querySelector('.close');

      expect(popoverControl.el.id).toEqual('controlOnly');
      expect(popoverControl.el.getAttribute('aria-controls')).toEqual(popoverControl.menu.id);
      expect(popoverControl.menu.getAttribute('aria-labelledby')).toEqual('controlOnly');
      expect(popoverControl.menu.getAttribute('role')).toEqual('dialog');
      expect(popoverControl.menu.classList.contains('popover')).toEqual(true);
      expect(popoverControl.menu.classList.contains('fade')).toEqual(true);
      expect(menuBody.innerHTML).toEqual(contents);
      expect(closeBtn.getAttribute('aria-label')).toEqual(closeLabel);
      expect(popoverControl.arrow.parentNode).toEqual(popoverControl.menu);
    });
  });

  describe('with options set using HTML attributes', () => {
    let popoverAlt;

    beforeEach(() => {
      popoverAlt = new Popover({
        el: document.querySelector('#controlAlt')
      });
    });

    afterEach(() => {
      popoverAlt.remove();
    });

    it('should be initialized', () => {
      const instances = Popover.getInstances();
      expect(instances.indexOf(popoverAlt)).not.toEqual(-1);
      expect(popoverAlt.el.id).toEqual('controlAlt');
      expect(popoverAlt.menu.id).toEqual('menuAlt');
      expect(popoverAlt.placement).toEqual('bottom');
      expect(popoverAlt.alignment).toEqual('start');
      expect(popoverAlt.offset).toEqual(16);
      expect(popoverAlt.enableReflow).toEqual(true);
      expect(popoverAlt.enableFade).toEqual(true);
      expect(popoverAlt.shown).toEqual(false);
    });

    it('should create a close button if none is present using the `data-close-label` attribute', () => {
      const closeBtn = popoverAlt.menu.querySelector('.close');
      expect(closeBtn).not.toBeNull();
      expect(closeBtn.getAttribute('aria-label')).toEqual('Custom close text');
    });
  });

  describe('when the menu is hidden', () => {
    let eventValue;

    beforeAll(() => {
      popoverDefault.el.addEventListener('onHide', () => {
        eventValue = 'hidden';
      });
    });

    beforeEach(() => {
      popoverDefault.hide();
    });

    it('should hide the menu', () => {
      expect(popoverDefault.shown).toEqual(false);
      expect(popoverDefault.el.classList.contains('active')).toEqual(false);
      expect(popoverDefault.menu.classList.contains('show')).toEqual(false);
      expect(popoverDefault.el.getAttribute('aria-expanded')).toEqual('false');
    });

    it('should open the menu when the trigger is clicked', () => {
      popoverDefault.el.click();
      expect(popoverDefault.shown).toEqual(true);
      expect(popoverDefault.el.classList.contains('active')).toEqual(true);
      expect(popoverDefault.menu.classList.contains('show')).toEqual(true);
    });

    it('should open the menu when the enter key is pressed on the trigger', () => {
      popoverDefault.el.dispatchEvent(enterKeyPressed);
      expect(popoverDefault.shown).toEqual(true);
      expect(popoverDefault.el.classList.contains('active')).toEqual(true);
      expect(popoverDefault.menu.classList.contains('show')).toEqual(true);
    });

    it('should open the menu when the space bar is pressed on the trigger', () => {
      popoverDefault.el.dispatchEvent(spaceBarPressed);
      expect(popoverDefault.shown).toEqual(true);
      expect(popoverDefault.el.classList.contains('active')).toEqual(true);
      expect(popoverDefault.menu.classList.contains('show')).toEqual(true);
    });

    it('should do nothing when the esc key is pressed on the trigger', () => {
      popoverDefault.el.dispatchEvent(escKeyPressed);
      expect(popoverDefault.shown).toEqual(false);
      expect(popoverDefault.el.classList.contains('active')).toEqual(false);
      expect(popoverDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should trigger the `onHide` custom event', () => {
      expect(eventValue).toEqual('hidden');
    });
  });

  describe('when the menu is shown', () => {
    let eventValue;

    beforeAll(() => {
      popoverDefault.el.addEventListener('onShow', () => {
        eventValue = 'shown';
      });
    });

    beforeEach(() => {
      popoverDefault.show();
    });

    it('should show the menu', () => {
      expect(popoverDefault.shown).toEqual(true);
      expect(popoverDefault.el.classList.contains('active')).toEqual(true);
      expect(popoverDefault.menu.classList.contains('show')).toEqual(true);
      expect(popoverDefault.el.getAttribute('aria-expanded')).toEqual('true');
    });

    it('should send focus to the close button', () => {
      expect(document.activeElement).toEqual(popoverDefault.closeBtn);
    });

    it('should trap focus within the menu', () => {
      document.body.dispatchEvent(focusInEvent);
      expect(document.activeElement).toEqual(popoverDefault.closeBtn);
    });

    it('should close the menu when the trigger is clicked', () => {
      popoverDefault.el.click();
      expect(popoverDefault.shown).toEqual(false);
      expect(popoverDefault.el.classList.contains('active')).toEqual(false);
      expect(popoverDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should close the menu when the enter key is pressed on the trigger', () => {
      popoverDefault.el.dispatchEvent(enterKeyPressed);
      expect(popoverDefault.shown).toEqual(false);
      expect(popoverDefault.el.classList.contains('active')).toEqual(false);
      expect(popoverDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should close the menu when the space bar is pressed on the trigger', () => {
      popoverDefault.el.dispatchEvent(spaceBarPressed);
      expect(popoverDefault.shown).toEqual(false);
      expect(popoverDefault.el.classList.contains('active')).toEqual(false);
      expect(popoverDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should close the menu when the esc key is pressed on the menu', () => {
      popoverDefault.menu.dispatchEvent(escKeyPressed);
      expect(popoverDefault.shown).toEqual(false);
      expect(popoverDefault.el.classList.contains('active')).toEqual(false);
      expect(popoverDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should close the menu when clicking outside the menu', () => {
      document.body.dispatchEvent(mouseDownEvent);
      expect(popoverDefault.shown).toEqual(false);
      expect(popoverDefault.el.classList.contains('active')).toEqual(false);
      expect(popoverDefault.menu.classList.contains('show')).toEqual(false);
      expect(popoverDefault.el.getAttribute('aria-expanded')).toEqual('false');
      expect(document.activeElement).not.toEqual(popoverDefault.el);
    });

    it('should close the menu when clicking the close button', () => {
      const closeBtn = popoverDefault.menu.querySelector('.close');
      closeBtn.dispatchEvent(clickEvent);
      expect(popoverDefault.shown).toEqual(false);
      expect(popoverDefault.el.classList.contains('active')).toEqual(false);
      expect(popoverDefault.menu.classList.contains('show')).toEqual(false);
      expect(popoverDefault.el.getAttribute('aria-expanded')).toEqual('false');
      expect(document.activeElement).toEqual(popoverDefault.el);
    });

    it('should close the menu when the esc key is pressed', () => {
      popoverDefault.menu.dispatchEvent(escKeyPressed);
      expect(popoverDefault.shown).toEqual(false);
      expect(popoverDefault.el.classList.contains('active')).toEqual(false);
      expect(popoverDefault.menu.classList.contains('show')).toEqual(false);
      expect(popoverDefault.el.getAttribute('aria-expanded')).toEqual('false');
      expect(document.activeElement).toEqual(popoverDefault.el);
    });

    it('should trigger the `onShow` custom event', () => {
      expect(eventValue).toEqual('shown');
    });
  });

  describe('when the instance is updated', () => {
    let eventValue;

    beforeAll(() => {
      popoverDefault.el.addEventListener('onUpdate', () => {
        eventValue = 'updated';
      });
    });

    it('should update the alignment property with a valid enum', () => {
      popoverDefault.update({ alignment: 'end' });
      expect(popoverDefault.alignment).toEqual('end');

      popoverDefault.update({ alignment: 'hi' });
      expect(popoverDefault.alignment).toEqual('center');
    });

    it('should update the placement property with a valid enum', () => {
      popoverDefault.update({ placement: 'left' });
      expect(popoverDefault.placement).toEqual('left');

      popoverDefault.update({ placement: 'hi' });
      expect(popoverDefault.placement).toEqual('right');
    });

    it('should update the tabbable elements list', () => {
      popoverDefault.tabbableElements = null;
      popoverDefault.update();
      expect(popoverDefault.tabbableElements.length).toEqual(2);
      expect(popoverDefault.tabbableElements[0]).toEqual(popoverDefault.closeBtn);
      expect(popoverDefault.tabbableElements[popoverDefault.tabbableElements.length - 1].id).toEqual('menuDefaultLink');
    });

    it('should update the fade effect option', () => {
      popoverDefault.update({ enableFade: false });
      expect(popoverDefault.enableFade).toEqual(false);
      expect(popoverDefault.menu.classList.contains('fade')).toEqual(false);

      popoverDefault.update({ enableFade: true });
      expect(popoverDefault.enableFade).toEqual(true);
      expect(popoverDefault.menu.classList.contains('fade')).toEqual(true);
    });

    it('should trigger the `onUpdate` custom event', () => {
      popoverDefault.update();
      expect(eventValue).toEqual('updated');
    });
  });

  describe('when the instance is removed', () => {
    let eventValue;

    beforeAll(() => {
      popoverDefault.el.addEventListener('onRemove', () => {
        eventValue = 'removed';
      });
    });

    beforeEach(() => {
      popoverDefault.remove();
    });

    it('should be removed from the list of instances', () => {
      const instances = Popover.getInstances();
      expect(instances.indexOf(popoverDefault)).toEqual(-1);
    });

    it('should trigger the `onRemove` custom event', () => {
      expect(eventValue).toEqual('removed');
    });
  });

  describe('show and hide with preventDefault', () => {
    afterEach(() => {
      jest.resetAllMocks();
    });

    it('should cancel show if default is prevented', () => {
      popoverDefault.hide();
      popoverDefault.el.dispatchEvent = jest.fn(e => e.preventDefault());
      popoverDefault.show();

      expect(popoverDefault.el.dispatchEvent).toBeCalled();
      expect(popoverDefault.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_SHOW);
      expect(popoverDefault.el.dispatchEvent.mock.calls[0][0].defaultPrevented).toBe(true);
      expect(popoverDefault.shown).toEqual(false);
      expect(popoverDefault.el.getAttribute('aria-expanded')).toEqual('false');
      expect(popoverDefault.menu.getAttribute('aria-modal')).not.toEqual('true');
    });

    it('should cancel hide when default is prevented', () => {
      popoverDefault.show();
      popoverDefault.el.dispatchEvent = jest.fn(e => e.preventDefault());
      popoverDefault.hide();

      expect(popoverDefault.el.dispatchEvent).toBeCalled();
      expect(popoverDefault.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_HIDE);
      expect(popoverDefault.el.dispatchEvent.mock.calls[0][0].defaultPrevented).toBe(true);
      expect(popoverDefault.shown).toEqual(true);
      expect(popoverDefault.el.getAttribute('aria-expanded')).toEqual('true');
      expect(popoverDefault.menu.getAttribute('aria-modal')).toEqual('true');
    });
  });
});
