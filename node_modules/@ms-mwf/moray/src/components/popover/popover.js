import Util from '../../js/util';
import Flyout from '../flyout/flyout';
import * as FlyoutConfig from '../flyout/flyout';

export const Selector = {
  DATA_MOUNT: '[data-mount="popover"]'
};

export const EventName = {
  ON_HIDE: 'onHide',
  ON_SHOW: 'onShow',
  ON_UPDATE: 'onUpdate',
  ON_REMOVE: 'onRemove'
};

export const ClassName = {
  ...FlyoutConfig.ClassName,
  POPOVER: 'popover',
  CLOSE: 'close',
  ARROW: 'arrow'
};

export const Default = {
  ...FlyoutConfig.Default,
  CLOSE_LABEL: 'Close dialog',
  ALIGNMENT: 'center'
};

const popovers = [];

/**
 * The event handler for when the target element is clicked
 * @param {MouseEvent} event - The event object
 */
function _elOnClick(event) {
  // Prevent page from trying to scroll to a page anchor
  event.preventDefault();
  this.toggle();
}

/**
 * The event handler for when a key is pressed on the target element
 * @param {KeyboardEvent} event - The event object
 */
function _elOnKeydown(event) {
  if (event.keyCode === Util.keyCodes.SPACE || event.keyCode === Util.keyCodes.ENTER) {
    // Trigger the same event as a click for consistency.
    // Note: Since focus should be trapped within the menu while open, these events should only ever apply when the menu is closed.
    // If somehow a keyboard event is triggered on the target element, go a head and close the menu as if it was clicked.
    event.preventDefault();
    _elOnClick.call(this, event);
  }
}

/**
 * The event handler for when a key is pressed on the menu
 * @param {KeyboardEvent} event - The event object
 */
function _menuOnKeydown(event) {
  if (event.keyCode === Util.keyCodes.ESC) {
    this.hide();
  }
}

/**
 * The event handler for when the close button is clicked.
 * Note: browser also triggers this when space or enter is pressed on a button.
 * @param {MouseEvent} event - The event object
 */
function _closeOnClick(event) {
  // Prevent page from trying to scroll to a page anchor
  event.preventDefault();
  this.hide();
}

/**
 * The event handler for when mousedown is triggered on the document.
 * Happens before mouseup, click, and focusin to control closing of the menu without conflicting with other events.
 * @param {Event} event - The event object
 */
function _documentOnMousedown(event) {
  if (this.shown && !this.menu.contains(event.target) && !this.el.contains(event.target)) {
    this.hide({ setFocus: false });
  }
}

/**
 * The event handler for when the document receives focus
 * @param {Event} event - The event object
 */
function _documentOnFocusin(event) {
  if (this.shown && !this.menu.contains(event.target)) {
    // Create a keyboard trap within the menu until the popover is closed by the user
    if (event.relatedTarget === this.closeBtn) {
      this.tabbableElements[this.tabbableElements.length - 1].focus();
    } else {
      this.closeBtn.focus();
    }
  }
}

/**
 * Gets the related menu or creates one if none is associated
 * @param {Node} node - The element associated with the menu, typically the popover trigger
 * @returns {Node} The menu element
 */
function _getOrCreateMenu(node) {
  if (node.attributes['aria-controls']) {
    return document.querySelector(`#${node.attributes['aria-controls'].value}`);
  }

  if (node.attributes['data-content']) {
    const menu = document.createElement('div');
    const menuId = `${ClassName.POPOVER}_${Util.getUid()}`;
    const menuContent = document.createElement('div');
    const menuContentBody = document.createElement('div');

    menu.setAttribute('id', menuId);
    menu.classList.add(ClassName.POPOVER);
    menu.setAttribute('role', 'dialog');
    menu.setAttribute('aria-labelledby', node.id);

    menuContent.classList.add('popover-content');
    menu.appendChild(menuContent);

    menuContentBody.classList.add('popover-body');
    menuContentBody.textContent = node.getAttribute('data-content');
    menuContent.appendChild(menuContentBody);
    menu.prepend(_createCloseBtn({ label: node.getAttribute('data-close-label') }));

    node.setAttribute('aria-expanded', 'false');
    node.setAttribute('aria-controls', menuId);
    node.after(menu);

    return menu;
  }
}

/**
 * Create a close button element
 * @param {Object} [opts={}] - Options for the button element
 * @param {string} [opts.label=Default.CLOSE_LABEL] - The aria-label value for the button
 * @returns {Node} The a close button element
 */
function _createCloseBtn(opts = {}) {
  const btn = document.createElement('button');
  btn.classList.add(ClassName.CLOSE);
  btn.setAttribute('aria-label', opts.label || Default.CLOSE_LABEL);

  return btn;
}

/**
 * Creates a decorative arrow element for the menu
 * @param {Node} node - The element to add the arrow to, typically the menu
 * @returns {Node} The arrow element
 */
function _createPopoverArrow(node) {
  const arrow = document.createElement('div');
  arrow.classList.add(ClassName.ARROW);
  node.append(arrow);

  return arrow;
}

class Popover extends Flyout {
  /**
   * Create a popover, inherited from flyout
   * @param {Object} opts - The flyout options
   * @param {Node} opts.el - The element that toggles the flyout
   * @param {Node} [opts.menu] - The element that defines the flyout menu
   * @param {string} [opts.placement=right] - A string that defines the placement of the menu
   * @param {string} [opts.alignment=center] - A string that defines the alignment of the menu
   * @param {number} [opts.offset=16] - The number of pixels the menu should be offset from the trigger
   * @param {boolean} [opts.enableReflow=true] - Whether the menu should reflow to fit within the window as best as possible
   * @param {boolean} [opts.enableFade=true] - Whether the menu should fade in and out
   */
  constructor(opts) {
    // Set super options
    const flyoutOpts = { ...opts };
    flyoutOpts.menu = opts.menu || _getOrCreateMenu(flyoutOpts.el);
    flyoutOpts.alignment = FlyoutConfig._getAlignment(
      opts.alignment || flyoutOpts.el.getAttribute('data-alignment'),
      Default.ALIGNMENT
    );
    flyoutOpts.offset = opts.offset ? parseInt(opts.offset, 10) : 16;
    flyoutOpts.enableFade = typeof opts.enableFade === 'boolean' ? opts.enableFade : true;
    super(flyoutOpts);

    // Popover-specific setup
    this.arrow = _createPopoverArrow(this.menu);

    // Get the "close" button within the menu
    this.closeBtn = this.menu.querySelector('button.close');
    if (!this.closeBtn) {
      this.closeBtn = _createCloseBtn({ label: this.el.getAttribute('data-close-label') });
      this.menu.prepend(this.closeBtn);
    }

    // Get a list of tabbable elements within the menu
    this.tabbableElements = Util.getTabbableElements(this.menu);

    // Add event handlers
    this.events = [
      { el: this.el, type: 'click', handler: _elOnClick.bind(this) },
      { el: this.el, type: 'keydown', handler: _elOnKeydown.bind(this) },
      { el: this.menu, type: 'keydown', handler: _menuOnKeydown.bind(this) },
      { el: this.closeBtn, type: 'click', handler: _closeOnClick.bind(this) },
      { el: document, type: 'mousedown', handler: _documentOnMousedown.bind(this) },
      { el: document, type: 'focusin', handler: _documentOnFocusin.bind(this) }
    ];
    Util.addEvents(this.events);

    // Create custom events
    this[EventName.ON_HIDE] = new CustomEvent(EventName.ON_HIDE, { bubbles: true, cancelable: true });
    this[EventName.ON_SHOW] = new CustomEvent(EventName.ON_SHOW, { bubbles: true, cancelable: true });

    popovers.push(this);
  }

  /**
   * Position the flyout menu
   */
  positionMenu() {
    super.positionMenu();
    this.positionMenuArrow();
  }

  /**
   * Position the menu's arrow
   */
  positionMenuArrow() {
    const position = this.currentPosition;

    // Reset positioning
    this.arrow.style.top = null;
    this.arrow.style.bottom = null;
    this.arrow.style.left = null;
    this.arrow.style.right = null;

    // Top and bottom menus
    if (position.placement === 'top' || position.placement === 'bottom') {
      if (position.alignment === 'start') {
        this.arrow.style[Default.START] =
          Math.round(this.boundingRect.el.width / 2) - this.arrow.offsetWidth / 2 + Math.abs(this.overflowOffset) + 'px';
      } else if (position.alignment === 'end') {
        this.arrow.style[Default.END] = Math.round(this.boundingRect.el.width / 2) - this.arrow.offsetWidth / 2 + Math.abs(this.overflowOffset) + 'px';
      } else {
        this.arrow.style.left = Math.round(this.boundingRect.menu.width / 2) - this.arrow.offsetWidth / 2 + Math.abs(this.overflowOffset) + 'px';
      }
      // Left and right menus
    } else if (position.alignment === 'start') {
      this.arrow.style.top = Math.round(this.boundingRect.el.height / 2) - this.arrow.offsetWidth / 2 + 'px';
    } else if (position.alignment === 'end') {
      this.arrow.style.bottom = Math.round(this.boundingRect.el.height / 2) - this.arrow.offsetWidth / 2 + 'px';
    } else {
      this.arrow.style.top = Math.round(this.boundingRect.menu.height / 2) - this.arrow.offsetWidth / 2 + 'px';
    }
  }

  /**
   * Show the menu
   */
  show() {
    super.show();
    this.el.setAttribute('aria-expanded', this.shown);
    this.menu.setAttribute('aria-modal', true);
    this.closeBtn.focus();

    this.el.dispatchEvent(this[EventName.ON_SHOW]);
  }

  /**
   * Hide the menu
   * @param {string} [opts={}] - Options for hiding the menu
   * @param {boolean} [opts.setFocus=true] - Whether or not the focus should be set on the toggling element; defaults to true
   */
  hide(opts = {}) {
    super.hide(opts);
    this.el.setAttribute('aria-expanded', this.shown);
    this.menu.removeAttribute('aria-modal');

    this.el.dispatchEvent(this[EventName.ON_HIDE]);
  }

  /**
   * Update the popover instance
   * @param {string} [opts={}] - Options for updating the instance
   */
  update(opts = {}) {
    const flyoutOpts = { ...opts };

    // Refresh the list of tabbable elements within the menu
    this.tabbableElements = Util.getTabbableElements(this.menu);

    // Enforce popover's default alignment as fallback
    if (opts.alignment) {
      flyoutOpts.alignment = FlyoutConfig._getAlignment(opts.alignment, Default.ALIGNMENT);
    }

    super.update(flyoutOpts);

    // Create and dispatch custom event
    this[EventName.ON_UPDATE] = new CustomEvent(EventName.ON_UPDATE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_UPDATE]);
  }

  /**
   * Remove the popover instance
   */
  remove() {
    // Remove event handlers, observers, etc.
    Util.removeEvents(this.events);

    // Remove this reference from the array of instances
    const index = popovers.indexOf(this);
    popovers.splice(index, 1);

    // Create and dispatch custom event
    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_REMOVE]);
  }

  /**
   * Get an array of popover instances
   * @returns {Object[]} Array of popover instances
   */
  static getInstances() {
    return popovers;
  }
}

export default Popover;
