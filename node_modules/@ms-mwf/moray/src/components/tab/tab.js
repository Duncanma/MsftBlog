import Util from '../../js/util';

/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

const tabs = [];

export const EventName = {
  HIDE: 'onHide',
  HIDDEN: 'onHidden',
  SHOW: 'onShow',
  SHOWN: 'onShown',
  CLICK_DATA_API: 'click',
  KEYDOWN_DATA_API: 'keydown',
  ON_REMOVE: 'onRemove',
  ON_UPDATE: 'onUpdate',
  POP_STATE: 'popstate'
};

export const Attribute = {
  HIDDEN: 'hidden'
};

export const ClassName = {
  DROPDOWN_MENU: 'dropdown-menu',
  ACTIVE: 'active',
  DISABLED: 'disabled',
  FADE: 'fade',
  SHOW: 'show'
};

export const Selector = {
  NAV_LIST_GROUP: '.nav, .list-group, .tab-group',
  ACTIVE: '.active',
  ACTIVE_UL: 'li .active',
  DATA_MOUNT: '[data-mount="tab"]',
  BACK_TO_TABS: '[data-focus="back-to-tabs"]',
  ROLE_TAB: '[role="tab"]',
  TAB_CONTENT: '.tab-content, .tab-panel-group'
};

// Private

/**
 * Activate tab.
 * @param {HTMLElement} element - Tab element.
 * @param {HTMLElement} container - Tab container element.
 * @param {Function} callback - Function to run after transition ends.
 * @this Tab
 */
function _activate(element, container, callback) {
  let activeElements;

  if (container && (container.nodeName === 'UL' || container.nodeName === 'OL')) {
    activeElements = container.querySelector(Selector.ACTIVE_UL);
  } else {
    // make sure that any selected tab panel .active element is a direct descendant of the tab panel container
    activeElements = [].slice.call(container.children).filter(e => e.classList.contains(ClassName.ACTIVE));
  }

  const active = activeElements[0];
  const isTransitioning = callback && active && active.classList.contains(ClassName.FADE);
  const complete = () => _transitionComplete.call(this, element, active, callback);

  if (active && isTransitioning) {
    const transitionDuration = Util.getTransitionDurationFromElement(active);

    active.classList.remove(ClassName.SHOW);
    active.addEventListener(Util.TRANSITION_END, complete, { once: true });
    Util.emulateTransitionEnd(active, transitionDuration);
  } else {
    complete();
  }
}

/**
 * Callback for completed tab transitions.
 * @param {HTMLElement} element - Newly selected tab element.
 * @param {HTMLElement} active - Previously active tab element.
 * @param {Function} callback - Function to run after transition ends.
 * @this Tab
 */
function _transitionComplete(element, active, callback) {
  if (active) {
    active.classList.remove(ClassName.ACTIVE);

    if (active.getAttribute('role') === 'tab') {
      active.setAttribute('aria-selected', 'false');
      active.setAttribute('tabindex', '-1');
    } else if (active.getAttribute('role') === 'tabpanel') {
      active.hidden = true;
    }
  }

  element.classList.add(ClassName.ACTIVE);
  if (element.getAttribute('role') === 'tab') {
    element.setAttribute('aria-selected', 'true');
    element.setAttribute('tabindex', '0');
  } else if (element.getAttribute('role') === 'tabpanel') {
    element.removeAttribute(Attribute.HIDDEN);

    // Scroll back to top of panel if necessary
    const activePanelTop = element.getBoundingClientRect().top;
    const documentElementNode = document.documentElement;
    let documentScrollPaddingTop = 0;
    if (documentElementNode.style.scrollPaddingTop) {
      documentScrollPaddingTop = parseInt(documentElementNode.style.scrollPaddingTop, 10);
    }

    if (activePanelTop < 0) {
      const scrollOffset = activePanelTop - documentElementNode.getBoundingClientRect().top - documentScrollPaddingTop;
      window.scrollTo(0, scrollOffset);
    }

    if (this.backToTabs && this.backToTabs instanceof HTMLAnchorElement) {
      this.backToTabs.focusControls?.remove();
      this.backToTabs.href = `#${element.id}-tab`;
      this.backToTabs.focusControls = new Util.FocusControls({ el: this.backToTabs });
    }
  }

  Util.reflow(element);

  if (element.classList.contains(ClassName.FADE)) {
    element.classList.add(ClassName.SHOW);
  }

  if (callback) {
    callback();
  }
}

/**
 * Callback function for all key events on tabs.
 * Facilitates left <-> right focus movement between tabs recommended by W3C: https://www.w3.org/TR/wai-aria-practices-1.1/examples/tabs/tabs-2/tabs.html
 * @param {KeyboardEvent} event - Keyboard event.
 * @this Tab
 */
function _onKeycodeEvent(event) {
  const keycode = Util.getKeyCode(event);
  switch (keycode) {
    case Util.keyCodes.SPACE:
    case Util.keyCodes.ENTER:
      event.preventDefault();
      this.show(event);

      break;
    case Util.keyCodes.ARROW_LEFT:
      if (this.isRTL) {
        _onKeycodeRight.call(this);
      } else {
        _onKeycodeLeft.call(this);
      }

      break;
    case Util.keyCodes.ARROW_RIGHT:
      if (this.isRTL) {
        _onKeycodeLeft.call(this);
      } else {
        _onKeycodeRight.call(this);
      }

      break;
    default:
      break;
  }
}

/**
 * Callback function for arrow-left key.
 * @this Tab
 */
function _onKeycodeLeft() {
  if (this.tabIndex === 0) {
    return;
  }

  this.listNodeList[this.tabIndex - 1].focus();
}

/**
 * Callback function for arrow-right key.
 * @this Tab
 */
function _onKeycodeRight() {
  if (this.tabIndex === this.listNodeList.length - 1) {
    return;
  }

  this.listNodeList[this.tabIndex + 1].focus();
}

function _onPopState() {
  const { hash } = window.location;

  // Check if hash matches the id of the tab panel or a tab panel child and show.
  // If no hash assume the default Tab panel should be shown.
  if (hash) {
    if (hash === `#${this.tabPanel.id}`) {
      this.show();
      this.el.scrollIntoView(true);
    } else {
      const tabPanelChild = this.tabPanel.querySelector(`[id="${hash.slice(1)}"]`);
      if (tabPanelChild) {
        this.show();
        this.tabContent.addEventListener(Util.TRANSITION_END, () => {
          tabPanelChild.scrollIntoView(true);
        }, { once: true });
      }
    }
  } else if (this.tabIndex === this.defaultTabIndex) {
    this.show();
  }
}

/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

class Tab {
  /**
   * Create a tab instance.
   * @param {Object} opts - Tab options.
   * @param {HTMLElement} opts.el - Tab element.
   * @param {Boolean} [opts.addUrlToHistory=false] - Use pushState instead of replaceState, defaults to false.
   * @param {Number} [opts.defaultTabIndex=0] - Index of default tab in list group. Defaults to first tab with class active or 0.
   */
  constructor({
    el,
    addUrlToHistory = false,
    defaultTabIndex = 0
  }) {
    this.el = el;
    this.listGroup = this.el.closest(Selector.NAV_LIST_GROUP);
    this.targetSelector = Util.getSelectorFromElement(this.el);
    this.tabPanel = document.querySelector(this.targetSelector);
    this.tabContent = this.tabPanel.closest(Selector.TAB_CONTENT);
    this.isRTL = document.dir === 'rtl';
    this.backToTabs = [
      ...Array.from(this.tabContent.children), // tab-panel-group children OR
      ...Array.from(this.tabContent.parentNode.children) // tab-panel-group siblings (backwards-compatible w/ old markup)
    ].find(el => el.dataset.focus === 'back-to-tabs');

    // set back to tab href to active tab's id
    if (
      this.el.classList.contains(ClassName.ACTIVE) &&
      this.backToTabs &&
      this.backToTabs instanceof HTMLAnchorElement
    ) {
      this.backToTabs.href = `#${this.el.id}`;
      this.backToTabs.focusControls = new Util.FocusControls({ el: this.backToTabs });
    }

    // prevents error if tab is not within a list group
    if (this.listGroup) {
      this.listNodeList = this.listGroup.querySelectorAll(Selector.ROLE_TAB) || [];
      this.nodeListArray = [].slice.call(this.listNodeList);
      this.tabIndex = this.nodeListArray.indexOf(this.el);
      this.addUrlToHistory = addUrlToHistory || this.listGroup.dataset.addUrlToHistory !== undefined;
      const activeTab = this.listGroup.querySelector(Selector.ACTIVE);
      const activeIndex = this.nodeListArray.indexOf(activeTab) > -1 ? this.nodeListArray.indexOf(activeTab) : null;
      this.defaultTabIndex = defaultTabIndex || activeIndex || 0;
    }

    // enable deep linking
    _onPopState.call(this);

    // attach event listeners
    this.events = [
      { el: this.el, type: EventName.CLICK_DATA_API, handler: this.show.bind(this) },
      { el: this.el, type: EventName.KEYDOWN_DATA_API, handler: _onKeycodeEvent.bind(this) },
      { el: window, type: EventName.POP_STATE, handler: _onPopState.bind(this) }
    ];

    // add event listeners
    Util.addEvents(this.events);

    tabs.push(this);
  }

  // Public

  /**
   * Shows a tab panel based on the tab clicked and hides other panels.
   * @param {Event} [event] - Event trigger.
   * @this Tab
   */
  show(event) {
    if (event) {
      event.preventDefault();
    }

    const hasParentEl = this.el.parentNode && this.el.parentNode.nodeType === Node.ELEMENT_NODE;
    const isActive = this.el.classList.contains(ClassName.ACTIVE);
    const isDisabled = this.el.classList.contains(ClassName.DISABLED);

    if ((hasParentEl && isActive) || isDisabled) {
      return;
    }

    const target = this.tabPanel;
    let previous;
    const listElement = this.listGroup || this.el.closest(Selector.NAV_LIST_GROUP);

    if (listElement) {
      const isList = listElement.nodeName === 'UL' || listElement.nodeName === 'OL';
      const itemSelector = isList ? Selector.ACTIVE_UL : Selector.ACTIVE;
      previous = this.el.parentNode.querySelector(itemSelector);
    }

    const hideEvent = new CustomEvent(EventName.HIDE, {
      detail: {
        relatedTarget: this.el
      }
    });

    const showEvent = new CustomEvent(EventName.SHOW, {
      detail: {
        relatedTarget: previous
      }
    });

    if (previous) {
      previous.dispatchEvent(hideEvent);
    }

    this.el.dispatchEvent(showEvent);

    if (showEvent.defaultPrevented || hideEvent.defaultPrevented) {
      return;
    }

    _activate.call(this, this.el, listElement);

    const complete = () => {
      const hiddenEvent = new CustomEvent(EventName.HIDDEN, {
        detail: {
          relatedTarget: this.el
        }
      });

      const shownEvent = new CustomEvent(EventName.SHOWN, {
        detail: {
          relatedTarget: previous
        }
      });

      if (previous) {
        previous.dispatchEvent(hiddenEvent);
      }

      this.el.dispatchEvent(shownEvent);

      const { hash } = window.location;
      const url = `#${this.tabPanel.id}`;
      const { title } = document;
      const { state } = window.history;
      const noHashAndNotOnDefaultTab = !hash && this.tabIndex !== this.defaultTabIndex;
      const notChild = hash && !this.tabPanel.querySelector(hash);
      const notSelf = hash !== url;
      if (noHashAndNotOnDefaultTab || (notChild && notSelf)) {
        if (this.addUrlToHistory) {
          window.history.pushState(state, title, url);
        } else {
          window.history.replaceState(state, title, url);
        }
      }
    };

    if (target) {
      _activate.call(this, target, target.parentNode, complete);
    } else {
      complete();
    }
  }

  /**
   * Remove event handlers.
   * @this Tab
   */
  remove() {
    Util.removeEvents(this.events);

    // remove this reference from array of instances
    const index = tabs.indexOf(this);
    tabs.splice(index, 1);

    // Create and dispatch custom event
    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_REMOVE]);
  }

  /**
   * Update Tab
   * @param {Object} [opts] - Tab options.
   * @param {Boolean} [opts.addUrlToHistory] Use pushState instead of replaceState.
   */
  update(opts = {}) {
    if (typeof opts.addUrlToHistory === 'boolean') {
      this.addUrlToHistory = opts.addUrlToHistory;
    }

    // Create and dispatch custom event
    this[EventName.ON_UPDATE] = new CustomEvent(EventName.ON_UPDATE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_UPDATE]);
  }

  /**
   * Get instances.
   * @returns {Tab[]} Array of tab instances.
   */
  static getInstances() {
    return tabs;
  }
}

export default Tab;
