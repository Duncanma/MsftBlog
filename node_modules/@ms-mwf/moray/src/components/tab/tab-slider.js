import { throttle } from 'throttle-debounce';
import imagesLoaded from 'imagesloaded';
import Util from '../../js/util';
import { Selector as TabSelector, EventName as TabEventName } from './tab';

const tabSliders = [];

export const EventName = {
  CLICK_DATA_API: 'click',
  RESIZE_DATA_API: 'resize',
  FOCUS_DATA_API: 'focus',
  SCROLL_DATA_API: 'scroll',
  ON_SCROLL: 'onScroll',
  ON_REMOVE: 'onRemove'
};

export const Direction = {
  LEFT: 'left',
  RIGHT: 'right'
};

export const ClassName = {
  ACTIVE: 'active',
  ARROWS: 'tab-arrows',
  ARROW_PREV: 'arrow-prev',
  ARROW_NEXT: 'arrow-next',
  TAB_OVERFLOW: 'tab-overflow',
  TAB_WINDOW: 'tab-window',
  TAB_GROUP: 'tab-group',
  JUSTIFY_CENTER: 'justify-content-center',
  MOBILE_ARROWS: 'mobile-arrows',
  IMAGE_TAB: 'tab-image',
  IMAGE_TAB_LABEL: 'tab-image-label'
};

export const Selector = {
  ACTIVE: `.${ClassName.ACTIVE}`,
  ARROWS: `.${ClassName.ARROWS}`,
  ARROW_PREV: `.${ClassName.ARROW_PREV}`,
  ARROW_NEXT: `.${ClassName.ARROW_NEXT}`,
  TAB_OVERFLOW: `.${ClassName.TAB_OVERFLOW}`,
  TAB_WINDOW: `.${ClassName.TAB_WINDOW}`,
  TAB_GROUP: `.${ClassName.TAB_GROUP}`,
  DATA_MOUNT: '[data-mount="tab-slider"]',
  IMAGE_TAB: `.${ClassName.IMAGE_TAB}`,
  IMAGE_TAB_LABEL: `.${ClassName.IMAGE_TAB_LABEL}`
};

export const Attribute = {
  DATA_DISABLE_SCROLL_INTO_VIEW: 'data-disable-scroll-into-view'
};

/**
 * Private functions.
 */

/**
 * Helper function to check if single tab element is within tab window.
 * @param {HTMLElement} tab - Single tab element.
 * @param {HTMLElement} tabListWindow - Tab window.
 * @return {boolean} Returns true if the tab element is visible within the tab window.
 */
function _inTabWindow(tab, tabListWindow) {
  const tabBounds = tab.getBoundingClientRect();
  const tabListWindowBounds = tabListWindow.getBoundingClientRect();
  return (
    Math.ceil(tabBounds.left) >= Math.ceil(tabListWindowBounds.left) &&
    Math.ceil(tabBounds.right) < Math.ceil(tabListWindowBounds.right)
  );
}

/**
 * Hide and/or show arrows dependent on visible tabs.
 * @this TabSlider
 */
function _showHideArrow() {
  const tabListWindow = this.el;
  const scrollLeftVal = this.scrollElement.scrollLeft;
  const arrowTarget1 = this.isRTL ? this.arrowNext : this.arrowPrev;
  const arrowTarget2 = this.isRTL ? this.arrowPrev : this.arrowNext;

  // for image tabs, match arrows height to image height
  const imageTab = tabListWindow.querySelector(Selector.IMAGE_TAB); // only need one; all are same height w/ flex styles
  if (imageTab) {
    imagesLoaded(tabListWindow, () => {
      const arrowTargetHeight =
        imageTab.offsetHeight - (imageTab.querySelector(Selector.IMAGE_TAB_LABEL).offsetHeight || 0);
      arrowTarget1.style.height = `${arrowTargetHeight}px`;
      arrowTarget2.style.height = `${arrowTargetHeight}px`;
    });
  }

  if (_inTabWindow(this.tabListItems[0], tabListWindow) || (!this.isRTL && scrollLeftVal === 0)) {
    arrowTarget1.style.display = 'none';
    arrowTarget2.style.display = 'block';
  } else if (_inTabWindow(this.tabListItems[this.tabListItems.length - 1], tabListWindow)) {
    arrowTarget1.style.display = 'block';
    arrowTarget2.style.display = 'none';
  } else {
    this.arrowNext.style.display = 'block';
    this.arrowPrev.style.display = 'block';
  }
}

/**
 * Keep focus on clicked arrow when slider moves.
 * @this TabSlider
 */
function _onArrowFocus() {
  const arrowTarget1 = this.isRTL ? this.arrowNext : this.arrowPrev;
  const arrowTarget2 = this.isRTL ? this.arrowPrev : this.arrowNext;

  if (this.arrowDirection === Direction.LEFT) {
    if (arrowTarget1.style.display === 'block') {
      arrowTarget1.focus();
    } else {
      arrowTarget2.focus();
    }
  } else if (this.arrowDirection === Direction.RIGHT) {
    if (arrowTarget2.style.display === 'block') {
      arrowTarget2.focus();
    } else {
      arrowTarget1.focus();
    }
  }
}

/**
 * Event trigger on click to move the slide left or right depending on which arrow has been clicked.
 * @param {Event} event - DOM event.
 * @this TabSlider
 */
function _onArrowClick(event) {
  event.preventDefault();
  this.isArrowClicked = true;

  _updateTabWindowWidth.call(this);

  // check for which arrow has been clicked
  if (event.target.matches(Selector.ARROW_NEXT)) {
    this.arrowDirection = this.isRTL ? Direction.LEFT : Direction.RIGHT;
  } else {
    this.arrowDirection = this.isRTL ? Direction.RIGHT : Direction.LEFT;
  }

  const slideToTarget = _getSlideToTarget.call(this);
  if (!slideToTarget) {
    return;
  }

  _setScrollLeft.call(this, slideToTarget);
}

/**
 * Set left position of tab window to left position of target element.
 * @param {HTMLElement} slideToTarget - Target element for position alignment.
 * @this TabSlider
 */
function _setScrollLeft(slideToTarget) {
  const arrowPadding =
    parseInt(getComputedStyle(this.arrowPrev).paddingLeft, 10) ||
    parseInt(getComputedStyle(this.arrowNext).paddingLeft, 10);
  const scrollElementLeft = Math.floor(this.scrollElement.scrollLeft);
  const slideToTargetVal = Math.floor(_getBoundingRectValue.call(this, slideToTarget, 'left'));
  const scrollElementVal = Math.floor(_getBoundingRectValue.call(this, this.scrollElement, 'left'));
  let scrollAmount;

  if (this.isRTL) {
    if (this.arrowDirection === Direction.LEFT) {
      scrollAmount = scrollElementLeft + slideToTargetVal + scrollElementVal + arrowPadding;
    } else {
      scrollAmount = scrollElementLeft - slideToTargetVal - scrollElementVal + arrowPadding;
    }
  } else {
    scrollAmount = scrollElementLeft + slideToTargetVal - scrollElementVal - arrowPadding;
  }

  try {
    this.scrollElement.scrollTo({
      left: scrollAmount,
      behavior: 'smooth'
    });
  } catch {
    this.scrollElement.scrollLeft = scrollAmount;
  }
}

/**
 * Get tab element for scroll target positioning.
 * @return {Element|undefined} - element for which to set left position
 * @this TabSlider
 */
function _getSlideToTarget() {
  let tabTarget;
  let i;
  let widthRemaining;
  let tabBounds;
  const tabListWindowBounds = this.el.getBoundingClientRect();

  if (this.arrowDirection === Direction.RIGHT) {
    i = this.tabListItems.length;

    /**
     * Start at right most tab and decrement until
     * the first tab not in the tab window is found
     * */
    while (i--) {
      tabBounds = this.tabListItems[i].getBoundingClientRect();

      // break if last tab is within tab window
      if (i === this.tabListItems.length - 1 && _inTabWindow(this.tabListItems[i], this.el)) {
        break;
      }

      // update to track the left most tab within the tab window
      if (
        _getBoundingRectValue.call(this, this.tabListItems[i], 'right') >=
        _getBoundingRectValue.call(this, this.el, 'right')
      ) {
        tabTarget = this.tabListItems[i];

        // update left most tab shown in tab window
        this.tabSlideTarget.el = tabTarget;
        this.tabSlideTarget.index = i;
      } else {
        break;
      }
    }
  } else {
    /**
     * Start at left most tab in tab window, decrement and find
     * out how many tabs can fit within the tab window.
     * */
    i = this.tabSlideTarget.index;
    widthRemaining = tabListWindowBounds.width;

    if (i === -1) {
      return;
    }

    while (i-- && widthRemaining >= 0) {
      tabBounds = this.tabListItems[i].getBoundingClientRect();
      // break if first tab is within tab window
      if (i === 0 && _inTabWindow(this.tabListItems[i], this.el)) {
        break;
      }

      widthRemaining -= tabBounds.width; // subtract tab width from tab window
      tabTarget = this.tabListItems[i];

      // update left most tab shown in tab window
      this.tabSlideTarget.el = tabTarget;
      this.tabSlideTarget.index = i;

      // break if the tab before this tab element creates a negative value
      if (this.tabListItems[i - 1] && widthRemaining - this.tabListItems[i - 1].getBoundingClientRect().width < 0) {
        break;
      }
    }
  }

  return tabTarget;
}

/**
 * Window resize handler (also runs on instantiation).
 * Sets container width, shows/hides arrows depending on visible tabs, and resets
 * styles when slider is not needed.
 * @this TabSlider
 */
function _onWindowResize() {
  // width of tab container - left/right padding
  const tabContainerWidth = this.el.offsetWidth - parseInt(getComputedStyle(this.el).paddingLeft, 10) * 2;
  const arrowsStyleDisplay = getComputedStyle(this.arrows).display;

  // recalculate if tabs have changed widths from media queries, etc
  _updateTabWindowWidth.call(this);

  // don't do anything if container is large enough to hold tabs
  if (tabContainerWidth >= this.tabListWidth) {
    if (arrowsStyleDisplay === 'block' || this.tabWindow.style.width) {
      this.arrows.style.display = 'none';
      this.tabWindow.style.width = '';
    }

    // add justify center class if it existed
    if (this.tabContentCentered) {
      this.tabGroup.classList.add(ClassName.JUSTIFY_CENTER);
    }

    return;
  }

  // else: set container overflow for tabs
  this.tabWindow.style.width = this.tabListWidth + 'px';

  // align tabs to the left when arrows appear
  if (this.tabContentCentered) {
    this.tabGroup.classList.remove(ClassName.JUSTIFY_CENTER);
  }

  // update tab list and last tab bounds
  this.tabListItems = this.el.querySelectorAll(TabSelector.ROLE_TAB);
  this.lastTabBounds = this.tabListItems[this.tabListItems.length - 1].getBoundingClientRect();

  // show arrows when the right most tab is out of bounds of the container by 40px (arrow width)
  const lastTabBoundsRightVal = _getBoundingRectValue.call(
    this,
    this.tabListItems[this.tabListItems.length - 1],
    'right'
  );
  const tabMountBoundsRightVal = _getBoundingRectValue.call(this, this.el, 'right');
  if (
    arrowsStyleDisplay === 'none' &&
    tabMountBoundsRightVal - this.arrowOffsetWidth <= lastTabBoundsRightVal - this.arrowOffsetWidth
  ) {
    this.arrows.style.display = 'block';
  }

  // hide arrows before shifting left position
  _showHideArrow.call(this);
}

/**
 * Focus event handler to capture selected tab and its index for positioning.
 * @param {Event} event - DOM focus event.
 * @this TabSlider
 */
function _onFocus({ target }) {
  if (target.matches(TabSelector.ROLE_TAB)) {
    _updateTabWindowWidth.call(this);

    const slideToTarget = target;

    // update left-most tab shown in tab window
    this.tabSlideTarget.el = slideToTarget;
    this.tabSlideTarget.index = [].slice.call(this.tabListItems).indexOf(slideToTarget);
  }
}

/**
 * Event handler to scroll tab into view (can be prevented with option).
 * @param {HTMLElement} tab - The selected tab element.
 * @param {boolean} scrollIntoView - Whether to scroll element into view.
 */
function _onShow(tab, scrollIntoView) {
  if (scrollIntoView) {
    tab.scrollIntoView({
      block: 'nearest', // vertical alignment
      inline: 'center', // horizontal alignment
      behavior: 'smooth'
    });
  }
}

/**
 * Scroll callback to move slider if triggered by keyboard events: left/right, tab/shift+tab.
 * @this TabSlider
 */
function _onScroll() {
  if (this.scrollTimeout !== null) {
    clearTimeout(this.scrollTimeout);
  }

  this.scrollTimeout = setTimeout(() => {
    _updateTabWindowWidth.call(this);
    _showHideArrow.call(this);

    // focus on the arrow only if an arrow was clicked (prevents keyboard presses from activating arrow focus)
    if (
      this.arrowDirection &&
      (document.activeElement === this.arrowNext || document.activeElement === this.arrowPrev)
    ) {
      _onArrowFocus.call(this);
    }

    // prevent scroll event from doing additional variable updates
    if (this.isArrowClicked) {
      this.isArrowClicked = false;
      return false;
    }

    // update left most tab shown in tab window
    for (let i = this.tabSlideTarget.index; i < this.tabListItems.length; i++) {
      if (this.tabListItems[i].getBoundingClientRect().left > 0) {
        this.tabSlideTarget.el = this.tabListItems[i];
        this.tabSlideTarget.index = i;
        break;
      }
    }
  }, 100);
}

/**
 * Accurately calculate all elements that make up the tab width.
 * @param {HTMLElement} tab - tab element
 * @return {number} tab width value
 */
function _getTabWidth(tab) {
  const eleStyleObj = getComputedStyle(tab);
  const marginLeft = Math.abs(parseInt(eleStyleObj.marginLeft, 10)) || 0;
  const marginRight = Math.abs(parseInt(eleStyleObj.marginRight, 10)) || 0;
  const borderLeft = parseInt(eleStyleObj.borderLeftWidth, 10) || 0;
  const borderRight = parseInt(eleStyleObj.borderRightWidth, 10) || 0;
  return tab.offsetWidth + (marginLeft + marginRight) + (borderLeft + borderRight);
}

/**
 * Update tab window width.
 * On page load, whitespace buffer is created to account for tab widths when letter-spacing increases,
 * but tab window should be readjusted to remove whitespace.
 * @this TabSlider
 */
function _updateTabWindowWidth() {
  this.tabListWidth = 0;
  this.tabListItems.forEach(tab => {
    this.tabListWidth += _getTabWidth(tab);
  });
  this.tabListWidth += 2 * 3; // account for outer VFIs

  // do not reset style on first load
  if (!this.isTabWindowWidthAdjusted && this.tabWindow.style.width) {
    this.tabWindow.style.width = this.tabListWidth + 'px';
    this.isTabWindowWidthAdjusted = true;
  }
}

/**
 * Get left (LTR) or right (RTL) rectangle bounding value.
 * @param {HTMLElement} tab - tab element
 * @param {('left'|'right')} side - side on which to calculate position.
 * @return {number} - left or right bounding value of element.
 */
function _getBoundingRectValue(tab, side = 'left') {
  const tabBounds = tab.getBoundingClientRect();

  if (side === 'left') {
    if (this.isRTL) {
      const elementStyles = getComputedStyle(tab);
      const borderRight = parseInt(elementStyles.borderRightWidth, 10);
      const marginRight = parseInt(elementStyles.marginRight, 10);
      return Math.abs(tabBounds.right + borderRight + marginRight - window.innerWidth);
    }

    return tabBounds.left;
  }

  if (this.isRTL) {
    return Math.abs(tabBounds.left - window.innerWidth);
  }

  return tabBounds.right;
}

/**
 * Tab slider
 * @class
 */
class TabSlider {
  /**
   * Create the tab slider controls.
   * @param {Object} opts - The tab slider control options.
   * @param {HTMLElement} opts.el - The tab slider DOM node.
   * @param {boolean} [opts.scrollIntoView=true] - Whether to scroll the selected tab into view (if overflowing container).
   * @param {Function} [opts.onPrevArrowClick] - Function to override the previous button click handler.
   * @param {Function} [opts.onNextArrowClick] - Function to override the next button click handler.
   * @param {Function} [opts.onFocusEvent] - Function to override the focus event handler.
   * @param {Function} [opts.onScrollEvent] - Function to override the scroll event handler.
   * @param {Function} [opts.onWindowResize] - Function to override the resize handler.
   */
  constructor({
    el,
    scrollIntoView = true,
    onPrevArrowClick,
    onNextArrowClick,
    onFocusEvent,
    onScrollEvent,
    onWindowResize
  }) {
    // select control nodes
    this.el = el;
    this.tabListItems = this.el.querySelectorAll(TabSelector.ROLE_TAB);
    this.scrollElement = this.el.querySelector(Selector.TAB_OVERFLOW);
    this.tabWindow = this.el.querySelector(Selector.TAB_WINDOW);
    this.tabGroup = this.el.querySelector(Selector.TAB_GROUP);
    this.tabContentCentered = this.tabGroup.classList.contains(ClassName.JUSTIFY_CENTER);
    this.arrows = this.el.querySelector(Selector.ARROWS);
    this.arrowPrev = this.el.querySelector(Selector.ARROW_PREV);
    this.arrowNext = this.el.querySelector(Selector.ARROW_NEXT);
    this.arrowOffsetWidth = parseInt(this.arrowNext.dataset.width, 10) || 40;

    // event controls
    this.onPrevArrowClick = onPrevArrowClick || _onArrowClick.bind(this);
    this.onNextArrowClick = onNextArrowClick || _onArrowClick.bind(this);
    this.onFocusEvent = onFocusEvent || _onFocus.bind(this);
    this.onScrollEvent = onScrollEvent || _onScroll.bind(this);
    this.onWindowResize = onWindowResize || _onWindowResize.bind(this);

    // internal variables
    this.isRTL = document.dir === 'rtl';
    this.isTabWindowWidthAdjusted = false;
    this.isArrowClicked = false;
    this.arrowDirection = Direction.LEFT;
    this.scrollTimeout = null;
    this.tabListWidth = 0;
    this.tabListWidthBuffer = 0; // a11y fix to increase tab list window width to allow for increased letter spacing
    this.lastTabBounds = this.tabListItems[this.tabListItems.length - 1].getBoundingClientRect();
    // keep track of tab that is on the far left of the tab window
    this.tabSlideTarget = {
      el: this.isRTL ? this.tabListItems[this.tabListItems.length - 1] : this.tabListItems[0],
      index: this.isRTL ? this.tabListItems.length - 1 : 0
    };
    this.scrollIntoView = scrollIntoView !== false && !this.el.hasAttribute(Attribute.DATA_DISABLE_SCROLL_INTO_VIEW);

    // get width of all tabs; include borders and margins
    this.tabListItems.forEach(tab => {
      this.tabListWidth += _getTabWidth(tab);
    });
    // create a buffer of the tab window width on page load
    this.tabListWidth *= 1.5;

    // add class name to arrows for mobile only
    if (Util.detectMobile(true)) {
      this.arrows.classList.add(ClassName.MOBILE_ARROWS);
    }

    // attach event listeners
    this.events = [
      { el: this.arrowPrev, type: EventName.CLICK_DATA_API, handler: this.onPrevArrowClick },
      { el: this.arrowNext, type: EventName.CLICK_DATA_API, handler: this.onNextArrowClick },
      { el: window, type: EventName.RESIZE_DATA_API, handler: throttle(100, this.onWindowResize) },
      { el: this.scrollElement, type: EventName.SCROLL_DATA_API, handler: throttle(100, this.onScrollEvent) }
    ];

    this.tabListItems.forEach(tab => {
      this.events.push(
        { el: tab, type: EventName.FOCUS_DATA_API, handler: this.onFocusEvent },
        {
          el: tab,
          type: TabEventName.SHOW,
          handler: _event => _onShow(tab, this.scrollIntoView)
        }
      );
    });

    Util.addEvents(this.events);

    tabSliders.push(this);

    this.observer = new IntersectionObserver(entries => {
      if (entries[0].isIntersecting) {
        this.onWindowResize();
      }
    });
    this.observer.observe(this.el);

    // Create custom events
    this[EventName.ON_SCROLL] = new CustomEvent(EventName.ON_SCROLL, { bubbles: true, cancelable: true });
  }

  /**
   * Remove event handlers.
   * @this TabSlider
   */
  remove() {
    Util.removeEvents(this.events);

    // Disconnect intersection observer
    this.observer.disconnect();

    // remove this reference from array of instances
    const index = tabSliders.indexOf(this);
    tabSliders.splice(index, 1);

    // Create and dispatch custom event
    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_REMOVE]);
  }

  /**
   * Go to next tabs
   * @this TabSlider
   */
  onClickNextArrow() {
    this.arrowNext.click();
    this.el.dispatchEvent(this[EventName.ON_SCROLL]);
  }

  /**
   * Go to previous tabs
   * @this TabSlider
   */
  onClickPrevArrow() {
    this.arrowPrev.click();
    this.el.dispatchEvent(this[EventName.ON_SCROLL]);
  }

  /**
   * Get instances.
   * @returns {Object} A object instance
   */
  static getInstances() {
    return tabSliders;
  }
}

export default TabSlider;
