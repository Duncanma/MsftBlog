import { debounce } from 'throttle-debounce';
import Util from '../../js/util';
import Collapse, { EventName as CollapseEventName, Selector as CollapseSelector } from '../collapse/collapse';
import imagesLoaded from 'imagesloaded';

export const Selector = {
  DATA_MOUNT: '[data-mount="multi-feature"]',
  FEATURE: '.multi-feature-feature',
  ACCORDION: '.accordion'
};

export const EventName = {
  ON_REMOVE: 'onRemove',
  ON_UPDATE: 'onUpdate'
};

export const ClassName = {
  DISPLAY: {
    BLOCK: 'block',
    NONE: 'd-none'
  }
};

const instances = [];

// Set accordion height so it is never taller than the shortest feature
function _setAccordionHeight() {
  if (this.inCustomViewport()) {
    // Wait for any images to load before calculating height
    imagesLoaded(this.el, () => {
      let maxAccordionHeight;
      let firstCollapseHeight;
      this.collapses.forEach((c, i) => {
        // Save current styles
        const { display } = c.el.style;
        const dNone = c.feature.classList.contains(ClassName.DISPLAY.NONE);

        // Set visible styles
        c.el.style.display = ClassName.DISPLAY.BLOCK;
        if (dNone) {
          c.feature.classList.remove(ClassName.DISPLAY.NONE);
        }

        // Calculate heights
        const featureHeight = c.feature.offsetHeight;
        if (!maxAccordionHeight || featureHeight < maxAccordionHeight) {
          maxAccordionHeight = featureHeight;
        }

        if (i === 0) {
          firstCollapseHeight = c.el.offsetHeight + c.triggerElement.offsetHeight;
        }

        // Reset styles to original state
        c.el.style.display = display;
        if (dNone) {
          c.feature.classList.add(ClassName.DISPLAY.NONE);
        }
      });

      // set a min height equal to the height of the first collapse while open, plus a peek of the second collapse button
      this.accordionElement.style.minHeight = `${firstCollapseHeight + 32}px`;

      if (maxAccordionHeight) {
        this.accordionElement.style.height = `${maxAccordionHeight}px`;
        this.accordionElement.style.overflowY = 'auto';
      }
    });
  } else {
    this.accordionElement.style.minHeight = '';
    this.accordionElement.style.height = '';
    this.accordionElement.style.overflowY = '';
  }
}

// Calculate height of absolute positioned content
function _setMultiFeatureHeight() {
  const featureHeight = this.open?.feature?.offsetHeight;
  if (this.inCustomViewport() && featureHeight) {
    this.el.style.height = `${featureHeight}px`;
  } else {
    this.el.style.height = '';
  }
}

function _onShown(collapse) {
  this.open = collapse;
  if (this.inCustomViewport()) {
    this.open.feature?.classList.remove(ClassName.DISPLAY.NONE);
    _setMultiFeatureHeight.call(this);
  }
}

function _onHide(e) {
  const otherOpen = this.collapses.some(collapse => {
    const notTarget = collapse.el !== e.target;
    const open = !collapse.isCollapsed && !collapse.isTransitioning && notTarget;
    const transitioningOpen = collapse.isCollapsed && collapse.isTransitioning && notTarget;
    return open || transitioningOpen;
  });

  if (this.inCustomViewport()) {
    if (otherOpen) {
      this.open.feature?.classList.add(ClassName.DISPLAY.NONE);
    } else {
      e.preventDefault();
    }
  } else if (!otherOpen) {
    this.open = undefined;
  }
}

function _onResize() {
  _setAccordionHeight.call(this);
  _setMultiFeatureHeight.call(this);
  if (this.inCustomViewport()) {
    if (!this.open && this.collapses.length) {
      this.collapses[0].toggle();
      this.open = this.collapses[0];
    }
  } else {
    this.collapses.forEach(collapse => {
      collapse.feature.classList.remove(ClassName.DISPLAY.NONE);
    });
  }
}

function _generateEvents() {
  const events = [
    { el: window, type: 'resize', handler: debounce(300, _onResize.bind(this)), options: { passive: true } }
  ];

  this.collapses.forEach(collapse => {
    events.push(
      {
        el: collapse.el,
        type: CollapseEventName.SHOWN,
        handler: () => {
          _onShown.call(this, collapse);
        }
      },
      {
        el: collapse.el,
        type: CollapseEventName.HIDE,
        handler: e => {
          _onHide.call(this, e);
        }
      }
    );
  });

  return events;
}

function _setupCollapse(collapse) {
  collapse.feature = collapse.el.querySelector(Selector.FEATURE);
  collapse.parent = `#${this.accordionElement.id}`;

  if (collapse.isCollapsed === false) {
    this.open = collapse;
  }
}

/**
 * Class representing a multi feature.
 */
class MultiFeature {
  /**
   * Create the multi feature.
   * @param {Object} opts - The multi feature options.
   * @param {Node} opts.el - The multi feature DOM node.
   * @param {Node} [opts.accordionElement] - The accordion DOM node.
   * @param {Collapse[]} [opts.collapses] - The list of Collapse instances.
   * @param {Array} [opts.customViewports] - The list of viewports with custom accordion logic.
   */
  constructor(opts) {
    this.el = opts.el;
    this.accordionElement = opts.accordion || this.el.querySelector(Selector.ACCORDION);
    this.collapses = opts.collapses || [];
    this.customViewports = opts.customViewports || ['lg', 'xl'];

    if (this.collapses.length) {
      this.collapses.forEach(collapse => {
        _setupCollapse.call(this, collapse);
      });
    } else {
      // Get the collapse instances and find the collapse elements
      const collapseTriggers = this.el.querySelectorAll(CollapseSelector.DATA_MOUNT);
      const collapseInstances = Collapse.getInstances();
      collapseTriggers.forEach(el => {
        const collapseInstance = collapseInstances.find(collapse => collapse.triggerElement === el);
        _setupCollapse.call(this, collapseInstance);
        this.collapses.push(collapseInstance);
      });
    }

    _setAccordionHeight.call(this);

    if (!this.open && this.collapses.length) {
      this.collapses[0].toggle();
      this.open = this.collapses[0];
    }

    this.events = _generateEvents.call(this);

    Util.addEvents(this.events);

    instances.push(this);
  }

  /**
   * Check if current viewport is in custom viewport list
   * @returns {Boolean}
   */
  inCustomViewport() {
    const viewport = Util.detectViewport();
    return this.customViewports.indexOf(viewport) > -1;
  }

  /**
   * Update instance.
   * @param {Object} opts - The multi feature options
   * @param {Node} [opts.accordionElement] - The accordion DOM node.
   * @param {Array} [opts.collapses] - The list of Collapse instances.
   * @param {Array} [opts.customViewports] - The list of viewports with custom accordion logic.
   */
  update(opts = {}) {
    // Remove event handlers
    Util.removeEvents(this.events);

    if (opts.accordionElement) {
      this.accordionElement = opts.accordionElement;
    }

    if (opts.customViewports) {
      this.customViewports = opts.customViewports;
    }

    if (opts.collapses) {
      this.open = null;
      this.collapses = opts.collapses;
      this.collapses.forEach(collapse => {
        _setupCollapse.call(this, collapse);
      });
    }

    _setAccordionHeight.call(this);

    if (!this.open && this.collapses.length) {
      this.collapses[0].toggle();
      this.open = this.collapses[0];
    }

    // Add event handlers
    this.events = _generateEvents.call(this);
    Util.addEvents(this.events);

    // Trigger event
    this[EventName.ON_UPDATE] = new CustomEvent(EventName.ON_UPDATE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_UPDATE]);
  }

  /**
   * Remove the multi feature.
   */
  remove() {
    // Remove event handlers
    Util.removeEvents(this.events);

    // remove this multi feature reference from array of instances
    const index = instances.indexOf(this);
    instances.splice(index, 1);

    // Trigger event
    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_REMOVE]);
  }

  /**
   * Get an array of multi feature instances.
   * @returns {Object[]} Array of multi feature instances.
   */
  static getInstances() {
    return instances;
  }
}

export default MultiFeature;
