import Util from '../../js/util';
import { ViewPort } from '../../js/util/detection';

export const Selector = {
  DATA_MOUNT: '[data-position="positioner"]'
};

export const EventName = {
  ON_UPDATE: 'onUpdate',
  ON_REMOVE: 'onRemove'
};

const BreakpointRank = {
  default: 0,
  xs: 0,
  sm: 1,
  md: 2,
  lg: 3,
  xl: 4
};

const RankedBreakpoints = ['default', 'sm', 'md', 'lg', 'xl'];

const breakpointWatchers = {};

const positionerInstances = [];

function _readBreakpointFromDataAttr(breakpointName) {
  if (
    this.el.getAttribute('data-position-top-' + breakpointName) &&
    this.el.getAttribute('data-position-left-' + breakpointName)
  ) {
    this.positionMap[breakpointName] = {};
    this.positionMap[breakpointName].top = parseFloat(this.el.getAttribute('data-position-top-' + breakpointName));
    this.positionMap[breakpointName].left = parseFloat(this.el.getAttribute('data-position-left-' + breakpointName));
  }
}

function _onBreakpointChange() {
  const detectedViewportName = Util.detectViewport();

  let i;
  let viewportName;
  for (i = BreakpointRank[detectedViewportName]; i >= 0; i--) {
    viewportName = RankedBreakpoints[i]; // prevent out of bounds if doing on tail end, translate 'xs' to 'default'

    if (
      this.positionMap[viewportName] &&
      Number.isFinite(this.positionMap[viewportName].top) &&
      Number.isFinite(this.positionMap[viewportName].left)
    ) {
      this.el.style.top = this.positionMap[viewportName].top + '%';
      this.el.style.left = this.positionMap[viewportName].left + '%';

      return; // done setting position
    }
  }

  // No default/xs case, remove inline styles
  Positioner.clearInlinePosition(this.el);
}

class Positioner {
  /**
   * Create a Positioner, which positions an absolutely or relatively positioned element by percentages
   * @param {Object} opts - The Positioner options
   * @param {Node} opts.el - The element that is positioned
   * @param {Object} [opts.positionMap] - A map of positions and breakpoints, see README for details
   */
  constructor(opts = {}) {
    this.el = opts.el;
    this.positionMap = {};

    // see if there are any positions to read from data- attributes
    let i;
    for (i = 0; i < RankedBreakpoints.length; i++) {
      _readBreakpointFromDataAttr.call(this, RankedBreakpoints[i]);
    }

    // object passed by JS takes precedence
    if (opts.positionMap) {
      Object.assign(this.positionMap, opts.positionMap); // position info passed in here takes precedence
    }

    // If this is the first Positioner instance on the page, set up the breakpoint watchers
    if (!breakpointWatchers.sm) {
      breakpointWatchers.sm = window.matchMedia('screen and (min-width: ' + ViewPort.SM + 'px)');
      breakpointWatchers.md = window.matchMedia('screen and (min-width: ' + ViewPort.MD + 'px)');
      breakpointWatchers.lg = window.matchMedia('screen and (min-width: ' + ViewPort.LG + 'px)');
      breakpointWatchers.xl = window.matchMedia('screen and (min-width: ' + ViewPort.XL + 'px)');
    }

    // Add event handlers
    this.events = [
      { el: breakpointWatchers.sm, type: 'change', handler: _onBreakpointChange.bind(this) },
      { el: breakpointWatchers.md, type: 'change', handler: _onBreakpointChange.bind(this) },
      { el: breakpointWatchers.lg, type: 'change', handler: _onBreakpointChange.bind(this) },
      { el: breakpointWatchers.xl, type: 'change', handler: _onBreakpointChange.bind(this) }
    ];
    Util.addEvents(this.events);

    // push to instances list
    positionerInstances.push(this);

    // check poisition initially
    _onBreakpointChange.call(this);
  }

  update(opts = {}) {
    if (opts.positionMap) {
      Object.assign(this.positionMap, opts.positionMap);
    }

    _onBreakpointChange.call(this);

    // Create and dispatch custom event
    this[EventName.ON_UPDATE] = new CustomEvent(EventName.ON_UPDATE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_UPDATE]);
  }

  remove() {
    Util.removeEvents(this.events);

    const index = positionerInstances.indexOf(this);
    positionerInstances.splice(index, 1);

    // Create and dispatch custom event
    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_REMOVE]);
  }

  static getInstances() {
    return positionerInstances;
  }

  static setPosition(node, xPos = 0, yPos = 0, unit = '') {
    if (node && node.style) {
      node.style.left = xPos + unit;
      node.style.top = yPos + unit;
      return node;
    }
  }

  static clearInlinePosition(node) {
    if (node && node.style) {
      node.style.left = null;
      node.style.top = null;
      node.style.bottom = null;
      node.style.top = null;

      return node;
    }
  }
}

export default Positioner;
