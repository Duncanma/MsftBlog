import ClickGroup, { Selector, EventName } from './click-group';

const clickGroupHtml =
  `<div data-mount="click-group">
    <a href="#" class="cta">Call to action</a>
  </div>`;

const clickGroupTargetHtml =
  `<div data-mount="click-group" data-target="buttonId">
    <a href="#" class="cta">Call to action</a>
  </div>
  <button id="buttonId">Button</button>`;

const multipleClickableHtml =
  `<div data-mount="click-group">
    <a href="#" class="cta">Shop now</a>
    <button>Add to Cart</button>
  </div>`;

const missingClickableHtml =
  `<div data-mount="click-group" data-target="notAppearingInThisTest">
    <p>Just a paragraph</p>
  </div>`;

const mockFn = jest.fn();
let instances;
let eventValue = '';

describe('Click group with no options passed in', () => {
  beforeAll(() => {
    // Set up our document body
    document.body.innerHTML = clickGroupHtml;

    document.querySelectorAll(Selector.DATA_MOUNT).forEach(node => {
      new ClickGroup({ el: node });
    });

    instances = ClickGroup.getInstances();

    // Setup event listeners for custom events
    instances[0].el.addEventListener(EventName.ON_UPDATE, () => {
      eventValue = 'updated';
    });
    instances[0].el.addEventListener(EventName.ON_CLICK, () => {
      eventValue = 'clicked';
    });
    instances[0].el.addEventListener(EventName.ON_REMOVE, () => {
      eventValue = 'removed';
    });

    // Mock the target click function
    instances[0].target.click = jest.fn();
  });

  afterAll(() => {
    document.body.innerHTML = '';
  });

  it('should be able to be initialized', () => {
    expect(instances.length).toEqual(1);
  });

  it('should dispatch the onClick event and fire the target click event when the element is clicked', () => {
    instances[0].el.click();
    expect(eventValue).toEqual('clicked');
    expect(instances[0].target.click).toHaveBeenCalledTimes(1);
  });

  it('should not get caught in an infinite loop', () => {
    instances[0].target.click();
    expect(eventValue).toEqual('clicked');
    expect(instances[0].target.click).toHaveBeenCalledTimes(2);
  });

  it('should be able to be updated', () => {
    instances[0].update();
    expect(eventValue).toEqual('updated');
  });

  it('should maintain current properties when updated with null', () => {
    const { target, onClick } = instances[0];
    instances[0].update(null);
    expect(ClickGroup.getInstances().length).toEqual(1);
    expect(target).toEqual(ClickGroup.getInstances()[0].target);
    expect(onClick).toEqual(ClickGroup.getInstances()[0].onClick);
  });

  it('should be able to be removed', () => {
    instances[0].remove();
    expect(ClickGroup.getInstances().length).toEqual(0);
    expect(eventValue).toEqual('removed');
  });
});

describe('Click group with multiple links or buttons', () => {
  beforeAll(() => {
    // Set up our document body
    document.body.innerHTML = multipleClickableHtml;

    document.querySelectorAll(Selector.DATA_MOUNT).forEach(node => {
      new ClickGroup({ el: node });
    });

    instances = ClickGroup.getInstances();

    // Setup event listeners for custom events
    instances[0].el.addEventListener(EventName.ON_UPDATE, () => {
      eventValue = 'updated';
    });
    instances[0].el.addEventListener(EventName.ON_CLICK, () => {
      eventValue = 'clicked';
    });
    instances[0].el.addEventListener(EventName.ON_REMOVE, () => {
      eventValue = 'removed';
    });
  });

  afterAll(() => {
    document.body.innerHTML = '';
  });

  it('should be able to be initialized', () => {
    expect(instances.length).toEqual(1);
  });

  it('should not have a target', () => {
    expect(instances[0].target).toEqual(null);
  });

  it('should be able to be updated', () => {
    instances[0].update();
    expect(eventValue).toEqual('updated');
  });

  it('should maintain current properties when updated with null', () => {
    const { target, onClick } = instances[0];
    instances[0].update(null);
    expect(ClickGroup.getInstances().length).toEqual(1);
    expect(target).toEqual(ClickGroup.getInstances()[0].target);
    expect(onClick).toEqual(ClickGroup.getInstances()[0].onClick);
  });

  it('should be able to be removed', () => {
    instances[0].remove();
    expect(ClickGroup.getInstances().length).toEqual(0);
    expect(eventValue).toEqual('removed');
  });
});

describe('Click group with missing target', () => {
  beforeAll(() => {
    // Set up our document body
    document.body.innerHTML = missingClickableHtml;

    document.querySelectorAll(Selector.DATA_MOUNT).forEach(node => {
      new ClickGroup({ el: node });
    });

    instances = ClickGroup.getInstances();

    // Setup event listeners for custom events
    instances[0].el.addEventListener(EventName.ON_UPDATE, () => {
      eventValue = 'updated';
    });
    instances[0].el.addEventListener(EventName.ON_CLICK, () => {
      eventValue = 'clicked';
    });
    instances[0].el.addEventListener(EventName.ON_REMOVE, () => {
      eventValue = 'removed';
    });
  });

  afterAll(() => {
    document.body.innerHTML = '';
  });

  it('should be able to be initialized', () => {
    expect(instances.length).toEqual(1);
  });

  it('should not have a target', () => {
    expect(instances[0].target).toEqual(null);
  });

  it('should be able to be updated', () => {
    instances[0].update();
    expect(eventValue).toEqual('updated');
  });

  it('should maintain current properties when updated with null', () => {
    const { target, onClick } = instances[0];
    instances[0].update(null);
    expect(ClickGroup.getInstances().length).toEqual(1);
    expect(target).toEqual(ClickGroup.getInstances()[0].target);
    expect(onClick).toEqual(ClickGroup.getInstances()[0].onClick);
  });

  it('should be able to be removed', () => {
    instances[0].remove();
    expect(ClickGroup.getInstances().length).toEqual(0);
    expect(eventValue).toEqual('removed');
  });
});

describe('Click group with data-target', () => {
  beforeAll(() => {
    // Set up our document body
    document.body.innerHTML = clickGroupTargetHtml;

    document.querySelectorAll(Selector.DATA_MOUNT).forEach(node => {
      new ClickGroup({ el: node });
    });

    instances = ClickGroup.getInstances();

    // Mock the target click function
    instances[0].target.click = jest.fn();
  });

  afterAll(() => {
    document.body.innerHTML = '';
  });

  it('should be able to be initialized', () => {
    expect(instances.length).toEqual(1);
  });

  it('should use the button element as the target', () => {
    expect(instances[0].target.getAttribute('id')).toEqual('buttonId');
  });

  it('should dispatch the onClick event and fire the target click event when the element is clicked', () => {
    instances[0].el.click();
    expect(instances[0].target.click).toHaveBeenCalledTimes(1);
  });

  it('should be able to be updated', () => {
    instances[0].update();
    expect(ClickGroup.getInstances().length).toEqual(1);
  });

  it('should maintain current properties when updated with null', () => {
    const { target, onClick } = instances[0];
    instances[0].update(null);
    expect(ClickGroup.getInstances().length).toEqual(1);
    expect(target).toEqual(ClickGroup.getInstances()[0].target);
    expect(onClick).toEqual(ClickGroup.getInstances()[0].onClick);
  });

  it('should be able to add target element when opts.target  is passed to update function', () => {
    const targetEl = document.createElement('div');
    targetEl.innerHTML = clickGroupHtml;
    instances[0].update({ target: targetEl });

    expect(instances[0].target).toEqual(targetEl);
    expect(instances[0].el.getElementsByTagName('a')[0]).toEqual(targetEl.getElementsByTagName('a')[0]);
  });

  it('should be able to be removed', () => {
    instances[0].remove();
    expect(ClickGroup.getInstances().length).toEqual(0);
  });
});

describe('Click group with options passed in', () => {
  beforeAll(() => {
    // Set up our document body
    document.body.innerHTML = clickGroupHtml;

    const button = document.createElement('button');
    button.setAttribute('id', 'buttonId2');

    document.body.append(button);

    document.querySelectorAll(Selector.DATA_MOUNT).forEach(node => {
      new ClickGroup({
        el: node,
        target: button,
        onClick: mockFn
      });
    });

    instances = ClickGroup.getInstances();
  });

  afterAll(() => {
    document.body.innerHTML = '';
  });

  it('should be able to be initialized', () => {
    expect(instances.length).toEqual(1);
  });

  it('should use the button element as the target', () => {
    expect(instances[0].target.getAttribute('id')).toEqual('buttonId2');
  });

  it('should dispatch the onClick event and fire the target click event when the element is clicked', () => {
    instances[0].el.click();
    expect(mockFn).toHaveBeenCalledTimes(1);
  });

  it('should dispatch the onClick event and fire the target click event when a click event bubbles up to the element', () => {
    instances[0].el.querySelector('a').click();
    expect(mockFn).toHaveBeenCalledTimes(2);
  });

  it('should be able to call opts.onClick when it is passed to update function', () => {
    const updateFn = jest.fn();
    instances[0].update({ onClick: updateFn });
    instances[0].el.click();
    expect(updateFn).toHaveBeenCalledTimes(1);
  });

  it('should be able to replace target element when opts.target  is passed to update function', () => {
    const targetEl = document.createElement('div');
    targetEl.innerHTML = clickGroupHtml;
    instances[0].update({ target: targetEl });

    expect(instances[0].target).toEqual(targetEl);
    expect(instances[0].el.getElementsByTagName('a')[0]).toEqual(targetEl.getElementsByTagName('a')[0]);
  });

  it('should be able to be removed', () => {
    instances[0].remove();
    expect(ClickGroup.getInstances().length).toEqual(0);
  });
});
