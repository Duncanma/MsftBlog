import Util from '../../js/util';
import { throttle } from 'throttle-debounce';
import Sticky, { Direction as StickyDirection, ClassName as StickyClassName } from '../sticky/sticky';

const backToTopInstances = [];

export const Selector = {
  DATA_MOUNT: '[data-mount="back-to-top"]'
};

export const EventName = {
  SCROLL: 'scroll',
  ON_REMOVE: 'onRemove',
  ON_RESIZE: 'resize',
  ON_UPDATE: 'onUpdate'
};

const Attributes = {
  TABINDEX: 'tabindex'
};

const DISPLAY_BUTTON_THRESHOLD = 0.7; // percentage of the page where button will display
let initialPageLoad = true;

/**
 * Switch the back to top element between static and sticky
 */
function _scrollListener() {
  // use offset margin and subtract the top position of the sentinel
  const offsetWithSentinel = this.stickyElement.sentinel.offsetTop - this.offsetMarginTop;
  const scrollY = window.scrollY || window.pageYOffset;

  if (scrollY > offsetWithSentinel) {
    this.stickyElement.setObserverStatus(true);
    this.el.style.opacity = 1;
  } else {
    const timeout = initialPageLoad ? 0 : 175; // prevent button flashing on page load
    this.el.style.opacity = 0;

    setTimeout(() => {
      this.el.classList.remove(StickyClassName.STUCK);
      this.stickyElement.enableObserver = false;
    }, timeout);

    initialPageLoad = false;
  }
}

/**
 * Update sticky offset margin top value when browser height changes
 * and remove/create new sticky element
 */
function _onWindowResize() {
  // extra conditional check to prevent code from constantly running on resize
  if (this.offsetMarginTop !== Util.getDocumentHeight() * DISPLAY_BUTTON_THRESHOLD) {
    this.offsetMarginTop = Util.getDocumentHeight() * DISPLAY_BUTTON_THRESHOLD;
    this.stickyElement.remove();
    this.stickyElement = new Sticky({ el: this.el, direction: StickyDirection.BOTTOM });
  }
}

/**
 * Class representing Back to Top.
 */
class BackToTop {
  /**
   * Create the Back to Top.
   * @param {Object} opts - The Back to Top options.
   * @param {Node} opts.el - The Back to Top DOM node.
   * @param {number} [opts.offsetMarginTop] - Offset in pixels from top of page where Back to Top should begin to be sticky.
   * @param {Function} [opts.onScroll] - Function to override the scroll event handler.
   * @param {Function} [opts.onWindowResize] - Function to override the window resize event handler.
   */
  constructor(opts) {
    this.el = opts.el;
    this.offsetMarginTop = opts.offsetMarginTop || Util.getDocumentHeight() * DISPLAY_BUTTON_THRESHOLD;
    this.onScroll = opts.onScroll || _scrollListener.bind(this);
    this.onWindowResize = opts.onWindowResize || _onWindowResize.bind(this);
    this.setTabindex();

    // Create custom events
    backToTopInstances.push(this);
    this.stickyElement = new Sticky({ el: this.el, direction: StickyDirection.BOTTOM });

    // Do the initial firing of the listener to set the state
    this.onScroll();

    // attach event listeners
    this.events = {
      scrollEvent: {
        el: document,
        type: EventName.SCROLL,
        handler: throttle(200, this.onScroll),
        options: { passive: true }
      },
      resizeEvent: {
        el: window,
        type: EventName.ON_RESIZE,
        handler: throttle(200, this.onWindowResize)
      }
    };

    Util.addEvents(Object.values(this.events));
  }

  /**
   * Check if the element needs a tabindex and set it
   */
  setTabindex() {
    const link = this.el.querySelector('a');
    const href = link.getAttribute('href');
    const targetElement = document.querySelector(href);
    const isElementFound = document.querySelector(href) !== null;
    if (
      isElementFound && // Only do something if the element is not tabbable
      !Util.isElementTabbable(targetElement)
    ) {
      const tabindex = targetElement.getAttribute(Attributes.TABINDEX);
      // If we don't have a tabindex
      if (tabindex === null) {
        // Set the tabindex of the element to -1
        targetElement.setAttribute(Attributes.TABINDEX, '-1');
      }
    }
  }

  /**
   * Update the Back to Top.
   * @param {Object} [opts] - The Back to Top options.
   * @param {number} [opts.offsetMarginTop] - Offset in pixels from top of page where Back to Top should begin to be sticky.
   * @param {Function} [opts.onScroll] - Function to override the scroll event handler.
   * @param {Function} [opts.onWindowResize] - Function to override the window resize event handler.
   */
  update(opts = {}) {
    if (opts.offsetMarginTop) {
      this.offsetMarginTop = opts.offsetMarginTop;
    }

    if (opts.onScroll) {
      Util.removeEvents([this.events.scrollEvent]);
      this.onScroll = opts.onScroll;
      Util.addEvents([this.events.scrollEvent]);
    }

    if (opts.onWindowResize) {
      Util.removeEvents([this.events.resizeEvent]);
      this.onWindowResize = opts.onWindowResize;
      Util.addEvents([this.events.resizeEvent]);
    }

    // Do the initial firing of the listener to set the state
    this.onScroll();

    // Create and dispatch custom event
    this[EventName.ON_UPDATE] = new CustomEvent(EventName.ON_UPDATE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_UPDATE]);
  }

  /**
   * Remove the event listener from the back to top element
   */
  remove() {
    Util.removeEvents(Object.values(this.events));
    this.stickyElement.remove();

    // remove this back to top reference from array of instances
    const index = backToTopInstances.indexOf(this);
    backToTopInstances.splice(index, 1);

    // Create and dispatch custom event
    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_REMOVE]);
  }

  /**
   * Get back to top instances.
   * @returns {Object[]} Array of back to top instances
   */
  static getInstances() {
    return backToTopInstances;
  }
}

export default BackToTop;
