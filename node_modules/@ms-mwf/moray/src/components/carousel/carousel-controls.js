import { debounce } from 'throttle-debounce';
import imagesLoaded from 'imagesloaded';
import Util from '../../js/util';
import TouchUtil from '../../js/util/touch';

export const ClassName = {
  ACTIVE: 'active',
  SLIDE: 'slide',
  SLIDE_IN: 'sliding-in',
  SNEAK_PEAK: 'carousel-sneak-peek',
  PRODUCT_CARD: 'carousel-product-card',
  VARIABLE_HEIGHT: 'carousel-variable-height',
  RIGHT: 'carousel-item-right',
  LEFT: 'carousel-item-left',
  NEXT: 'carousel-item-next',
  PREV: 'carousel-item-prev',
  GET_HEIGHT: 'get-height',
  MARGIN_X_0: 'mx-0',
  PADDING_X_0: 'px-0'
};

export const Direction = {
  NEXT: 'next',
  PREV: 'prev',
  LEFT: 'left',
  RIGHT: 'right'
};

export const Selector = {
  ACTIVE: '.active',
  ACTIVE_ITEM: '.active.carousel-item',
  ITEM: '.carousel-item',
  ITEM_IMG: '.carousel-item img',
  INDICATORS: '.carousel-indicators',
  DATA_SLIDE_PREV: '[data-slide="prev"]',
  DATA_SLIDE_NEXT: '[data-slide="next"]',
  DATA_MOUNT: '[data-mount="carousel"]',
  DATA_LOOP: 'data-loop',
  DATA_STATUS: 'data-status',
  CAROUSEL_INNER: '.carousel-inner',
  ROW: '.row',
  SLIDE_ITEM: '.slide-item',
  VISIBLE_STATUS: '[aria-hidden="true"]',
  SR_STATUS: '[aria-live]',
  BACK_TO_CONTROLS: '.back-to-controls'
};

export const EventName = {
  ON_CHANGE: 'onChange',
  ON_UPDATE: 'onUpdate',
  ON_REMOVE: 'onRemove'
};

/**
 * Private functions.
 */

function _getItemIndex(element) {
  const items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(Selector.ITEM)) : [];
  return items.indexOf(element);
}

function _getInitialSlideIndex() {
  const activeItem = this.el.querySelector(Selector.ACTIVE_ITEM);
  return _getItemIndex.bind(this)(activeItem);
}

function _getNextSlide() {
  const index = this.currentSlideIndex + 1;
  // If index exceeds slide length, return to index 0
  return index > this.slides.length - 1 ? 0 : index;
}

function _getPrevSlide() {
  const index = this.currentSlideIndex - 1;
  // If index is less than 0, move to last slide index
  return index < 0 ? this.slides.length - 1 : index;
}

function _getSlide(num) {
  // Record highest number, 0 or passed-in value
  const max = Math.max(num, 0);
  // Return lowest number, either previous number or the maximum slide index
  return Math.min(max, this.slides.length - 1);
}

function _getStatusContainer() {
  // Check if we are maintaing a status message for this carousel
  // and that the element exists on the page
  const statusContainer = this.el.getAttribute(Selector.DATA_STATUS);
  return statusContainer ? document.getElementById(statusContainer) : null;
}

function _shouldLoopSlides() {
  // Loop by default unless data-loop is set to false
  return !(this.el.getAttribute(Selector.DATA_LOOP) === 'false');
}

function _onFirstSlide() {
  return this.currentSlideIndex === 0;
}

function _onLastSlide() {
  return this.currentSlideIndex === this.slides.length - 1;
}

function _shouldGoForward() {
  return _onLastSlide.bind(this)() ? this.loopSlides : true;
}

function _shouldGoBack() {
  return _onFirstSlide.bind(this)() ? this.loopSlides : true;
}

function _prevBtnOnClick() {
  this.goToPrevSlide();
}

function _nextBtnOnClick() {
  // Add events to manage focus order for accessibility
  Util.addEvents(this.nextBtnEvents);
  this.goToNextSlide();
}

function _backToControlsBtnOnClick() {
  if (!this.backToControlsBtn) {
    return;
  }

  // focus logic: prefer "previous" button, then "next", otherwise carousel container
  if (!this.prevBtn.disabled) {
    this.prevBtn.focus();
    return;
  }

  if (!this.nextBtn.disabled) {
    this.nextBtn.focus();
    return;
  }

  this.el.setAttribute('tabindex', -1);
  this.el.focus();
}

function _imgOnDrag(event) {
  // Prevent images inside slides from being dragged and interfering with touch interaction
  event.preventDefault();
}

function _slide(direction, nextElementIndex) {
  const activeElement = this.slides[this.currentSlideIndex];
  const nextElement = this.slides[nextElementIndex];

  let directionalClassName;
  let orderClassName;

  if (direction === Direction.NEXT) {
    directionalClassName = ClassName.LEFT;
    orderClassName = ClassName.NEXT;
  } else {
    directionalClassName = ClassName.RIGHT;
    orderClassName = ClassName.PREV;
  }

  if (nextElement && nextElement.classList.contains(ClassName.ACTIVE)) {
    this.isSliding = false;
    return;
  }

  if (!activeElement || !nextElement) {
    // Some weirdness is happening, so we bail
    return;
  }

  this.isSliding = true;

  _setActiveIndicatorElement.bind(this)(nextElementIndex);

  if (this.el.classList.contains(ClassName.SNEAK_PEAK)) {
    _removeNextPrevClasses.bind(this)();
  }

  if (this.el.classList.contains(ClassName.SLIDE)) {
    if (this.el.classList.contains(ClassName.VARIABLE_HEIGHT)) {
      this.el.classList.add(ClassName.MARGIN_X_0, ClassName.PADDING_X_0);
    }

    nextElement.classList.add(orderClassName, ClassName.SLIDE_IN);

    Util.reflow(nextElement);

    activeElement.classList.add(directionalClassName);
    nextElement.classList.add(directionalClassName);

    const transitionDuration = Util.getTransitionDurationFromElement(activeElement);

    setTimeout(() => {
      nextElement.classList.remove(directionalClassName, orderClassName, ClassName.SLIDE_IN);
      nextElement.classList.add(ClassName.ACTIVE);

      activeElement.classList.remove(ClassName.ACTIVE, orderClassName, directionalClassName);

      if (this.el.classList.contains(ClassName.VARIABLE_HEIGHT)) {
        this.el.classList.remove(ClassName.MARGIN_X_0, ClassName.PADDING_X_0);
      }

      this.isSliding = false;
    }, transitionDuration);
  } else {
    activeElement.classList.remove(ClassName.ACTIVE);
    nextElement.classList.add(ClassName.ACTIVE);

    this.isSliding = false;
  }

  _setSlideAttributes.bind(this)(nextElementIndex);
  this.didSlide = true;

  this.currentSlideIndex = nextElementIndex;

  if (this.el.classList.contains(ClassName.SNEAK_PEAK)) {
    _addNextPrevClasses.bind(this)();
  }

  _setButtonAttributes.bind(this)();

  // Update the status message
  if (this.statusContainer) {
    _setStatusMessage.bind(this)(nextElementIndex);
  }
}

function _setActiveIndicatorElement(index) {
  if (this.indicators) {
    const indicators = [].slice.call(this.indicators.querySelectorAll(Selector.ACTIVE));
    indicators.forEach(indicator => {
      indicator.classList.remove(ClassName.ACTIVE);
    });

    const nextIndicator = this.indicators.children[index];

    if (nextIndicator) {
      nextIndicator.classList.add(ClassName.ACTIVE);
    }
  }
}

function _removeNextPrevClasses() {
  const nextElementIndex = _getNextSlide.bind(this)();
  const prevElementIndex = _getPrevSlide.bind(this)();

  this.slides[prevElementIndex].classList.remove(ClassName.PREV);
  this.slides[nextElementIndex].classList.remove(ClassName.NEXT);
}

function _addNextPrevClasses() {
  const nextElementIndex = _getNextSlide.bind(this)();
  const prevElementIndex = _getPrevSlide.bind(this)();

  this.slides[nextElementIndex].classList.add(ClassName.NEXT);
  this.slides[prevElementIndex].classList.add(ClassName.PREV);
}

function _setSlideAttributes(index) {
  for (let i = 0; i < this.slides.length; i++) {
    if (i === index) {
      this.slides[i].removeAttribute('aria-hidden');

      if (this.el.classList.contains(ClassName.PRODUCT_CARD)) {
        // Product card carousel needs the first product card focusable, not the whole slide
        const slideItems = [].slice.call(this.slides[i].querySelectorAll(Selector.SLIDE_ITEM));
        this.slides[i].removeAttribute('tabindex');
        slideItems[0].firstElementChild.setAttribute('tabindex', 0);
      } else {
        this.slides[i].setAttribute('tabindex', 0);
      }
    } else {
      this.slides[i].removeAttribute('tabindex');
      this.slides[i].setAttribute('aria-hidden', 'true');
    }
  }
}

function _setActiveClass(index) {
  for (let i = 0; i < this.slides.length; i++) {
    if (i === index) {
      this.slides[i].classList.add(ClassName.ACTIVE);
    } else {
      this.slides[i].classList.remove(ClassName.ACTIVE);
    }
  }
}

function _setButtonAttributes() {
  if (!this.loopSlides) {
    if (_onFirstSlide.bind(this)()) {
      this.prevBtn.setAttribute('disabled', '');
      this.prevBtn.setAttribute('tabindex', -1);
      this.nextBtn.removeAttribute('disabled');
    } else if (_onLastSlide.bind(this)()) {
      this.prevBtn.removeAttribute('disabled');
      this.prevBtn.removeAttribute('tabindex');
      this.nextBtn.setAttribute('disabled', '');
    } else {
      this.prevBtn.removeAttribute('disabled');
      this.prevBtn.removeAttribute('tabindex');
      this.nextBtn.removeAttribute('disabled');
    }
  }
}

/**
 * @desc finds appropriate title text for a carousel slide
 * @param {Node} searchNode the Node to seach
 * @returns {String} Appropriate text, or empty string if none is found
 */
function _getSlideTitleText(searchNode) {
  const headerSelectors = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
  let i;
  let headerNode = null;

  for (i = 0; i < headerSelectors.length; i++) {
    headerNode = searchNode.querySelector(headerSelectors[i]);

    if (headerNode) {
      return headerNode.textContent;
    }
  }

  const imageNodeList = searchNode.querySelectorAll('img');

  if (imageNodeList.length === 1 && imageNodeList[0].hasAttribute('alt')) {
    return imageNodeList[0].getAttribute('alt');
  }

  return '';
}

function _setStatusMessage(index) {
  // Sets status message if a status container (visible, screen reader, or both) was registered at initialization
  if (this.visibleStatusContainer || this.srStatusContainer) {
    // for carousels that display multiple items at once, like product cards, each item is a slideItem
    // one or more slideItems are grouped together in a slide.
    const slideItems = [].slice.call(this.el.querySelectorAll(Selector.SLIDE_ITEM)); // all slideItems
    const activeSlide = this.slides[index]; // The currently shown slide
    const activeSlideItems = activeSlide.querySelectorAll(Selector.SLIDE_ITEM); // the slideItems in the currently shown slide

    const start = slideItems.indexOf(activeSlideItems[0]) + 1;
    const separator = '–';
    const end = slideItems.indexOf(activeSlideItems[activeSlideItems.length - 1]) + 1;

    const data = {
      start,
      separator,
      end,
      total: slideItems.length,
      slideNumber: index + 1
    };

    // Check if there are no slideItems and we're instead just dealing with regular slides
    if (!slideItems || slideItems.length < 1) {
      data.start = index + 1;
      data.end = index + 1;
      data.total = this.slides.length;
    }

    // Check if we're showing exactly one thing
    if (activeSlide && start === end) {
      // Make title of shown slide available to template if there's only one
      data.slideTitle = _getSlideTitleText(activeSlide);
    }

    if (this.srStatusContainer && this.srStatusTemplate) {
      this.srStatusContainer.textContent = Util.interpolateString(this.srStatusTemplate, data);
    }

    // If we are only showing one item, set separator and end to an empty string for the visible template only
    if (start === end) {
      data.separator = '';
      data.end = '';
    }

    if (this.visibleStatusContainer && this.visibleStatusTemplate) {
      this.visibleStatusContainer.textContent = Util.interpolateString(this.visibleStatusTemplate, data);
    }
  }
}

function _setSlideHeights() {
  // Enforce consistent height (flexbox messes with animation)
  const slideArray = [].slice.call(this.slides);
  let maxHeight = slideArray[0].clientHeight;
  slideArray.forEach(slide => {
    if (!slide.classList.contains(ClassName.ACTIVE)) {
      slide.classList.add(ClassName.GET_HEIGHT);
    }

    if (slide.clientHeight > maxHeight) {
      maxHeight = slide.clientHeight;
    }

    slide.classList.remove(ClassName.GET_HEIGHT);
  });

  slideArray.forEach(slide => {
    slide.style.height = `${maxHeight}px`;
  });
}

function _removeSlideHeights() {
  const slideArray = [].slice.call(this.slides);
  slideArray.forEach(slide => {
    slide.style.height = '';
  });
}

function _recalculateSlideHeights() {
  _removeSlideHeights.bind(this)();
  imagesLoaded(this.el, () => {
    _setSlideHeights.bind(this)();
  });
}

function _handleKeyDown(event) {
  const keycode = event.keycode || event.which;

  if (keycode === Util.keyCodes.TAB && this.didSlide) {
    _focusOnSlide.bind(this)(this.currentSlideIndex);
    this.didSlide = false;
    event.preventDefault();
  }

  _removeControlEventListeners.bind(this)();
}

function _focusOnSlide(index) {
  this.slides[index].focus();
}

function _removeControlEventListeners() {
  this.didSlide = false;
  Util.removeEvents(this.nextBtnEvents);
}

function _reallocateSlideItems() {
  const inner = this.el.querySelector(Selector.CAROUSEL_INNER);
  const activeSlide = this.el.querySelector(Selector.ACTIVE_ITEM);
  const slideItemsContainer = activeSlide.querySelector(Selector.ROW);
  const slideItems = [].slice.call(this.el.querySelectorAll(Selector.SLIDE_ITEM));
  const activeSlideItems = activeSlide.querySelectorAll(Selector.SLIDE_ITEM);
  const maxItems = Math.round(slideItemsContainer.clientWidth / activeSlideItems[0].clientWidth);
  const slidesNeeded = Math.ceil(slideItems.length / maxItems);
  const slidesToAdd = slidesNeeded - this.slides.length;

  // Reset CSS properties
  _removeSlideHeights.bind(this)();
  this.prevBtn.style.display = '';
  this.nextBtn.style.display = '';

  if (this.statusContainer) {
    this.statusContainer.style.display = '';
    this.statusContainer.nextElementSibling.style.display = '';
  }

  if (slidesToAdd > 0) {
    // We need to add more slides
    for (let i = 0; i < slidesToAdd; i++) {
      const newNode = this.slides[this.slides.length - 1].cloneNode(true);
      inner.append(newNode);
      const newParent = newNode.querySelector(Selector.ROW);
      // Clear out duplicated slide items
      while (newParent.firstChild) {
        newParent.lastChild.remove();
      }
    }
  } else if (slidesToAdd < 0) {
    // We need to remove some slides
    for (let i = 0; i > slidesToAdd; i--) {
      inner.lastChild.remove();
    }
  }

  // Reallocate the slide items among the slides
  const slideItemsContainers = this.el.querySelectorAll(Selector.ROW);
  let itemsToAppend;
  for (let i = slideItemsContainers.length - 1; i >= 0; i--) {
    const remainder = slideItems.length % maxItems;

    if (remainder > 0) {
      itemsToAppend = slideItems.splice(slideItems.length - remainder, remainder);
    } else {
      itemsToAppend = slideItems.splice(slideItems.length - maxItems, maxItems);
    }

    itemsToAppend.forEach(item => {
      slideItemsContainers[i].append(item);
    });
  }

  // Update the slides property
  this.slides = this.el.querySelectorAll(Selector.ITEM);

  // Reset current slide index if it's on a slide that's been removed
  if (this.currentSlideIndex > this.slides.length - 1) {
    this.currentSlideIndex = this.slides.length - 1;
  }

  // If there is only one slide, hide the controls, status msg, and cta
  if (this.slides.length === 1) {
    this.prevBtn.style.display = 'none';
    this.nextBtn.style.display = 'none';

    if (this.statusContainer) {
      this.statusContainer.style.display = 'none';
      this.statusContainer.nextElementSibling.style.display = 'none';
    }
  }

  _recalculateSlideHeights.bind(this)();
}

function _setupDom() {
  // Reallocate slide items for product card carousel
  if (this.el.classList.contains(ClassName.PRODUCT_CARD)) {
    _reallocateSlideItems.bind(this)();
  }

  // Carousels that aren't layered can't use flexbox to ensure consistent height
  // so we need an option to set slide height via JS
  if (this.el.classList.contains(ClassName.VARIABLE_HEIGHT)) {
    _recalculateSlideHeights.bind(this)();
  }

  // Make sure slide attributes and indicators are up to date
  _setSlideAttributes.bind(this)(this.currentSlideIndex);
  _setActiveClass.bind(this)(this.currentSlideIndex);
  _setActiveIndicatorElement.bind(this)(this.currentSlideIndex);

  // For layered carousel layouts, add prev and next classes to slides
  if (this.el.classList.contains(ClassName.SNEAK_PEAK)) {
    _addNextPrevClasses.bind(this)();
  }

  // Update button attributes, for non-looping carousels
  _setButtonAttributes.bind(this)();

  // Update the status message
  if (this.statusContainer) {
    _setStatusMessage.bind(this)(this.currentSlideIndex);
    this.statusContainer.parentNode.classList.remove('d-none');
  }
}

/**
 * Class representing carousel controls.
 */
class CarouselControls {
  /**
   * Create the carousel controls.
   * @param {Object} opts - The carousel controls options.
   * @param {Node} opts.el - The carousel DOM node.
   * @param {Node[]} opts.slides - Array of carousel slides.
   * @param {number} [opts.initialSlideIndex] - Index of the first carousel slide.
   * @param {boolean} [opts.loopSlides=true] - Whether the carousel should loop. Defaults to true.
   * @param {Node} [opts.statusContainer] - Node that contains the status message templates.
   * @param {Function} [opts.prevOnClick] - Function to override the previous button click handler.
   * @param {Function} [opts.nextOnClick] - Function to override the next button click handler.
   */
  constructor(opts) {
    this.el = opts.el;
    this.slides = opts.slides;
    this.currentSlideIndex = opts.initialSlideIndex || _getInitialSlideIndex.bind(this)();
    this.loopSlides = typeof opts.loopSlides === 'boolean' ? opts.loopSlides : _shouldLoopSlides.bind(this)();
    this.statusContainer = opts.statusContainer || _getStatusContainer.bind(this)();
    this.prevOnClick = opts.prevOnClick || _prevBtnOnClick.bind(this);
    this.nextOnClick = opts.nextOnClick || _nextBtnOnClick.bind(this);
    this.backToControlsBtnOnClick = _backToControlsBtnOnClick.bind(this);

    // Internal variables
    this.isSliding = false;
    this.didSlide = false;
    this.touchUtil = new TouchUtil({
      el: this.el,
      positiveCallback: this.goToNextSlide.bind(this),
      negativeCallback: this.goToPrevSlide.bind(this)
    });

    // Select control nodes
    this.prevBtn = this.el.querySelector(Selector.DATA_SLIDE_PREV);
    this.nextBtn = this.el.querySelector(Selector.DATA_SLIDE_NEXT);
    this.backToControlsBtn = this.el.querySelector(Selector.BACK_TO_CONTROLS);
    this.indicators = this.el.querySelector(Selector.INDICATORS);
    this.itemImg = this.el.querySelectorAll(Selector.ITEM_IMG);

    if (this.statusContainer) {
      this.visibleStatusContainer = this.statusContainer.querySelector(Selector.VISIBLE_STATUS);
      this.srStatusContainer = this.statusContainer.querySelector(Selector.SR_STATUS);

      if (this.visibleStatusContainer) {
        this.visibleStatusTemplate = this.visibleStatusContainer.textContent;
      }

      if (this.srStatusContainer) {
        this.srStatusTemplate = this.srStatusContainer.textContent;
      }
    }

    // Attach event listeners
    this.events = [
      { el: this.prevBtn, type: 'click', handler: this.prevOnClick },
      { el: this.nextBtn, type: 'click', handler: this.nextOnClick }
    ];

    // Can be null
    if (this.backToControlsBtn) {
      this.events.push({ el: this.backToControlsBtn, type: 'click', handler: this.backToControlsBtnOnClick });
    }

    if (this.itemImg) {
      this.itemImg.forEach(img => {
        this.events.push({ el: img, type: 'dragstart', handler: _imgOnDrag });
      });
    }

    // Product card and variable height carousels need an event listener for window resize
    if (this.el.classList.contains(ClassName.PRODUCT_CARD) || this.el.classList.contains(ClassName.VARIABLE_HEIGHT)) {
      this.events.push({
        el: window,
        type: 'resize',
        handler: debounce(300, this.update.bind(this)),
        options: { passive: true }
      });
    }

    Util.addEvents(this.events);
    this.touchUtil.addEventListeners();

    // Event listeners that need to be added/removed based on user interaction for accessibility
    // After someone activates the next button, but before the slide animation is over, the next tab keypress
    // needs to direct focus to the next slide
    this.nextBtnEvents = [
      { el: this.nextBtn, type: 'keydown', handler: _handleKeyDown.bind(this) },
      { el: this.nextBtn, type: 'blur', handler: _removeControlEventListeners.bind(this) }
    ];

    // Create custom events
    this[EventName.ON_CHANGE] = new CustomEvent(EventName.ON_CHANGE, { bubbles: true, cancelable: true });

    // Fix for product card and variable height carousels placed inside other interactive elements like tabs or modals
    if (this.el.classList.contains(ClassName.PRODUCT_CARD) || this.el.classList.contains(ClassName.VARIABLE_HEIGHT)) {
      this.observer = new IntersectionObserver(entries => {
        if (entries[0].isIntersecting) {
          this.update();
        }
      });
      this.observer.observe(this.el);
    }

    // Setup DOM
    _setupDom.bind(this)();
  }

  /**
   * Remove the carousel controls event handlers.
   */
  remove() {
    // Remove event listeners
    Util.removeEvents(this.events);
    this.touchUtil.removeEventListeners();
    _removeControlEventListeners.bind(this)();

    // Disconnect intersection observer
    if (this.el.classList.contains(ClassName.PRODUCT_CARD) || this.el.classList.contains(ClassName.VARIABLE_HEIGHT)) {
      this.observer.disconnect();
    }

    // Create and dispatch custom event
    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_REMOVE]);
  }

  /**
   * Update the carousel controls instance.
   */
  update() {
    // For layered carousel layouts, remove prev and next classes from existing slides
    if (this.el.classList.contains(ClassName.SNEAK_PEAK)) {
      _removeNextPrevClasses.bind(this)();
    }

    // Update the slides property
    this.slides = this.el.querySelectorAll(Selector.ITEM);

    // Setup DOM
    _setupDom.bind(this)();

    // Create and dispatch custom event
    this[EventName.ON_UPDATE] = new CustomEvent(EventName.ON_UPDATE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_UPDATE]);
  }

  /**
   * Go forward to the next slide.
   */
  goToNextSlide() {
    if (!this.isSliding && _shouldGoForward.bind(this)()) {
      _slide.bind(this)(Direction.NEXT, _getNextSlide.bind(this)());
      this.el.dispatchEvent(this[EventName.ON_CHANGE]);
    }
  }

  /**
   * Go back to the previous slide.
   */
  goToPrevSlide() {
    if (!this.isSliding && _shouldGoBack.bind(this)()) {
      _slide.bind(this)(Direction.PREV, _getPrevSlide.bind(this)());
      this.el.dispatchEvent(this[EventName.ON_CHANGE]);
    }
  }

  /**
   * Go to a specific slide.
   * @param {number} num - 0-based index of the slide to change to.
   */
  goToSlide(num) {
    if (!this.isSliding) {
      _slide.bind(this)(Direction.PREV, _getSlide.bind(this)(num));
      this.el.dispatchEvent(this[EventName.ON_CHANGE]);
    }
  }
}

export default CarouselControls;
