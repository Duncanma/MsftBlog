/* eslint-disable max-nested-callbacks */
import Util from '../../js/util';
import Carousel from './carousel';
import { EventName, Selector } from './carousel-controls';

const statusMessageTemplate = 'Slide %{start} of %{total}. %{slideTitle}';

jest.useFakeTimers();

function render({ statusMessage = false, backToControls = false } = {}) {
  return `
    ${statusMessage && `
      <div id="status-container">
        <span id="status-msg" class="sr-only" aria-hidden="true" aria-live="polite">${statusMessageTemplate}</span>
      </div>
    `}
    <div class="carousel slide" data-mount="carousel" data-status="status-container">
      <div class="carousel-controls">
        <button type="button" class="carousel-control-prev" data-slide="prev">
          <span class="sr-only">Previous</span>
        </button>
        <ol class="carousel-indicators" aria-hidden="true">
          <li class="active"></li>
          <li></li>
          <li></li>
        </ol>
        <button type="button" class="carousel-control-next" data-slide="next">
          <span class="sr-only">Next</span>
        </button>
      </div>
      <div class="carousel-inner">
        <div class="carousel-item active">
          <img class="d-block w-100" src="https://via.placeholder.com/690x345?text=First+slide" alt="First slide">
        </div>
        <div class="carousel-item">
          <img class="d-block w-100" src="https://via.placeholder.com/690x345?text=Second+slide" alt="Second slide">
        </div>
        <div class="carousel-item">
          <img class="d-block w-100" src="https://via.placeholder.com/690x345?text=Third+slide" alt="Third slide">
        </div>
      </div>
      ${backToControls && `
        <button class="btn btn-link back-to-controls text-left sr-only-focusable w-100 position-absolute bottom-2">Back to Next and Previous controls</button>
      `}
    </div>
  `;
}

describe(Carousel.name, () => {
  describe('constructor()', () => {
    describe('initialization: default', () => {
      let instances;

      beforeAll(() => {
        Util.tearDownComponentList(Carousel.getInstances());

        document.body.innerHTML = render({ statusMessage: true });
        document.querySelectorAll(Selector.DATA_MOUNT).forEach(node => new Carousel({ el: node }));

        instances = Carousel.getInstances();
      });

      it('should be initialized with the correct instance properties', () => {
        expect(instances.length).toEqual(1);
        expect(instances[0].controls.observer).toBeUndefined();
        expect(instances[0].controls.visibleStatusContainer).toBeDefined();
        expect(instances[0].controls.visibleStatusTemplate).toEqual(statusMessageTemplate);
        expect(instances[0].controls.srStatusContainer).toBeDefined();
        expect(instances[0].controls.currentSlideIndex).toEqual(0);
        expect(instances[0].controls.backToControlsBtn).toBeNull();
      });

      it('should NOT have a click event with an el value referencing the back to controls link', () => {
        const hasBackToControlsEvent = instances[0].controls.events.some(
          e => e && e.el && e.el.classList && e.el.classList.contains('back-to-controls')
        );

        expect(hasBackToControlsEvent).toBe(false);
      });
    });

    describe('initialization: with JS options configured', () => {
      const mockFn = jest.fn();
      let instances;

      beforeAll(() => {
        Util.tearDownComponentList(Carousel.getInstances());
        document.body.innerHTML = render({ statusMessage: true });

        document.querySelectorAll(Selector.DATA_MOUNT).forEach(
          node =>
            new Carousel({
              el: node,
              initialSlideIndex: 2,
              prevOnClick: mockFn,
              loopSlides: false
            })
        );

        instances = Carousel.getInstances();
      });

      it('should be initialized with the proper instance properties', () => {
        expect(instances.length).toEqual(1);
        expect(instances[0].controls.observer).toBeUndefined();
        expect(instances[0].controls.visibleStatusContainer).toBeDefined();
        expect(instances[0].controls.visibleStatusTemplate).toEqual(statusMessageTemplate);
        expect(instances[0].controls.srStatusContainer).toBeDefined();
        expect(instances[0].controls.currentSlideIndex).toEqual(2);
        expect(instances[0].controls.backToControlsBtn).toBeNull();
      });

      it('should NOT have a click event with an el value referencing the back to controls link', () => {
        const hasBackToControlsEvent = instances[0].controls.events.some(
          e => e && e.el && e.el.classList && e.el.classList.contains('back-to-controls')
        );

        expect(hasBackToControlsEvent).toBe(false);
      });

      it('should have a disabled next button since the current slide is the last one', () => {
        expect(instances[0].controls.nextBtn.getAttribute('disabled')).not.toBeNull();
        expect(instances[0].controls.prevBtn.getAttribute('disabled')).toBeNull();
      });

      it('should call the function provided to override the prevBtn click handler and not change slides', () => {
        instances[0].controls.prevBtn.click();
        jest.runAllTimers();
        expect(instances[0].controls.currentSlideIndex).toEqual(2);
        expect(mockFn).toBeCalled();
      });
    });
  });

  describe('goToSlide()', () => {
    it('should go to the slide index provided', () => {
      const instance = new Carousel({ el: document.querySelector(Selector.DATA_MOUNT) });

      instance.controls.goToSlide(0);
      jest.runAllTimers();
      expect(instance.controls.currentSlideIndex).toEqual(0);
    });
  });

  describe('getInstances()', () => {
    beforeAll(() => {
      Util.tearDownComponentList(Carousel.getInstances());

      document.body.innerHTML = render();
    });

    it('should return the proper number of Carousel instances', () => {
      const el = document.querySelector(Selector.DATA_MOUNT);
      // for simulation – do not target the same element IRL
      new Carousel({ el });
      new Carousel({ el });

      expect(Carousel.getInstances()).toHaveLength(2);
    });
  });

  describe('remove()', () => {
    beforeAll(() => {
      Util.tearDownComponentList(Carousel.getInstances());

      document.body.innerHTML = render();
    });

    it('should remove one Carousel when called', () => {
      const el = document.querySelector(Selector.DATA_MOUNT);
      // for simulation – do not target the same element IRL
      new Carousel({ el });
      new Carousel({ el });
      new Carousel({ el });

      const instance2 = Carousel.getInstances()[1];
      instance2.remove();

      expect(Carousel.getInstances()).toHaveLength(2);
      // ensure the proper instance was deleted
      expect(Carousel.getInstances()).not.toContain(instance2);
    });

    it('should dispatch an "onRemove" event when called', () => {
      const instance = new Carousel({ el: document.querySelector(Selector.DATA_MOUNT) });

      instance.el.dispatchEvent = jest.fn();
      instance.remove();

      expect(instance.el.dispatchEvent).toBeCalled();
      expect(instance.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_REMOVE);
    });
  });
});

describe('update()', () => {
  beforeAll(() => {
    Util.tearDownComponentList(Carousel.getInstances());
    document.body.innerHTML = render();
  });
  it('should be able to be updated with options passed in', () => {
    const mock = jest.fn();
    const instance = new Carousel({ el: document.querySelector(Selector.DATA_MOUNT) });
    instance.update({
      slides: instance.el,
      initialSlideIndex: 3,
      loopSlides: false,
      prevOnClick: mock,
      nextOnClick: mock
    });
    expect(instance.controls.slides).toEqual(instance.el);
    expect(instance.controls.initialSlideIndex).toBe(3);
    expect(instance.controls.loopSlides).toBe(false);
    expect(instance.controls.prevOnClick).toEqual(mock);
    expect(instance.controls.nextOnClick).toEqual(mock);
  });
});

describe('next/previous controls behavior', () => {
  let instance;

  beforeAll(() => {
    Util.tearDownComponentList(Carousel.getInstances());
    document.body.innerHTML = render();

    instance = new Carousel({ el: document.querySelector(Selector.DATA_MOUNT) });
  });

  it('should advance to the next slide when the button is clicked', () => {
    // start at slide 0
    instance.controls.nextBtn.click();
    jest.runAllTimers();
    expect(instance.controls.currentSlideIndex).toEqual(1);
  });

  it('should go back to the previous slide when the button is clicked', () => {
    instance.controls.prevBtn.click();
    jest.runAllTimers();
    expect(instance.controls.currentSlideIndex).toEqual(0);
  });

  it('should loop back to the first slide when the next button is clicked from the last slide', () => {
    instance.controls.goToSlide(2);
    jest.runAllTimers();
    instance.controls.nextBtn.click();
    jest.runAllTimers();
    expect(instance.controls.currentSlideIndex).toEqual(0);
  });

  it('should cancel "onChange" event if default is prevented', () => {
    instance.controls.goToSlide(0);
    instance.el.dispatchEvent = jest.fn(e => e.preventDefault());
    instance.controls.goToSlide(2);
    jest.runAllTimers();

    expect(instance.el.dispatchEvent).toBeCalled();
    expect(instance.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_CHANGE);
    expect(instance.el.dispatchEvent.mock.calls[0][0].defaultPrevented).toBe(true);
    expect(instance.controls.currentSlideIndex).toBe(0);
  });

  it('should dispatch an "onChange" event when slides change', () => {
    instance.el.dispatchEvent = jest.fn();
    instance.controls.goToSlide(0);
    jest.runAllTimers();

    expect(instance.el.dispatchEvent).toBeCalled();
    expect(instance.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_CHANGE);
  });
});

describe('with back to controls link', () => {
  let instance;
  let backToControlsEl;

  beforeAll(() => {
    Util.tearDownComponentList(Carousel.getInstances());
    document.body.innerHTML = render({ backToControls: true });

    instance = new Carousel({ el: document.querySelector(Selector.DATA_MOUNT) });
    backToControlsEl = document.querySelector(Selector.BACK_TO_CONTROLS);
  });

  it('should have a backToControlsBtn', () => {
    expect(instance.controls.backToControlsBtn).toBe(backToControlsEl);
  });

  it('should have a click event with an el value referencing the back to controls link', () => {
    const hasBackToControlsEvent = instance.controls.events.some(
      e => e && e.el && e.el === backToControlsEl
    );

    expect(hasBackToControlsEvent).toBe(true);
  });
});
