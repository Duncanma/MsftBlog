import Util from '../../js/util';

export const Selector = {
  TOGGLE: '.show-more-show-less-toggle',
  ELLIPSIS: '.show-more-show-less-ellipsis',
  TOGGLEABLE_CONTENT: '.show-more-show-less-toggleable-content',
  DATA_MOUNT: '[data-mount="show-more-show-less"]'
};

export const ClassName = {
  DISPLAY_NONE: 'd-none'
};

export const EventName = {
  ON_HIDE: 'onHide',
  ON_SHOW: 'onShow',
  ON_REMOVE: 'onRemove',
  ON_UPDATE: 'onUpdate'
};

const instances = [];

function _elOnClick() {
  this.toggle();
}

// Makes hidden content untabbable after hide()
function _toggleableContentOnFocusOut(element) {
  element.removeAttribute('tabindex');
}

class ShowMoreShowLess {
  /**
   * Create a show-more-show-less component.
   * @param {Object} opts - The show-more-show-less options.
   * @param {Node} opts.el - The container element for content that will be hidden/shown.
   * @returns {Object} show-more-show-less instance.
   */
  constructor(opts) {
    /**
     * Defines which variant should be instantiated.
     */
    if (opts.el.hasAttribute('data-count')) {
      // eslint-disable-next-line no-constructor-return
      return new ShowMoreShowLessMultiElement({ el: opts.el, hideAfter: opts.el.getAttribute('data-count') });
    }

    // eslint-disable-next-line no-constructor-return
    return new ShowMoreShowLessSingleElement({ el: opts.el });
  }

  /**
   * Return the number of instances.
   * @returns {Object[]} an array of active instances.
   */
  static getInstances() {
    return instances;
  }
}

class ShowMoreShowLessBase {
  /**
   * Defines a show-more-show-less base component.
   * @param {Object} opts - The show-more-show-less options.
   */
  constructor(opts) {
    /**
     * The container element for content that will be hidden/shown.
     */
    this.el = opts.el;

    /**
     * The element bound with the toggle event handler.
     */
    this.control = this.el.querySelector(Selector.TOGGLE);

    /**
     * The control text values.
     */
    this.showMoreText = opts.showMoreText || this.control.textContent;
    this.showLessText = opts.showLessText || this.control.getAttribute('data-show-less-text');

    /**
     * The optional control aria-label values.
     */
    if (this.control.hasAttribute('aria-label')) {
      this.showMoreLabelText = this.control.getAttribute('aria-label');
      this.showLessLabelText =
        opts.showLessAriaLabel || this.control.getAttribute('data-alternate-aria-label') || this.showLessText;
    }

    /**
     * The element demarking shown and hidden content.
     */
    this.ellipsis = this.el.querySelector(Selector.ELLIPSIS);
    this.shown = false;

    /**
     * Event binders.
     */
    this.events = [{ el: this.control, type: 'click', handler: _elOnClick.bind(this) }];

    instances.push(this);
  }

  /**
   * Focus new element when show and hide.
   * @param {Node} element. The element to focus.
   */
  setFocusToElement(element) {
    element.setAttribute('tabindex', 0);
    document.activeElement.blur();
    element.focus();
  }

  /**
   * Show toggleable content.
   */
  show() {
    // Create and dispatch custom event
    this[EventName.ON_SHOW] = new CustomEvent(EventName.ON_SHOW, { bubbles: true, cancelable: true });
    this.control.dispatchEvent(this[EventName.ON_SHOW]);
    if (this[EventName.ON_SHOW].defaultPrevented) {
      return;
    }

    this.shown = true;

    if (this.ellipsis) {
      this.ellipsis.classList.add(ClassName.DISPLAY_NONE);
    }

    this.control.setAttribute('aria-expanded', true);
    this.control.textContent = this.showLessText;
    if (this.control.hasAttribute('aria-label')) {
      this.control.setAttribute('aria-label', this.showLessLabelText);
    }
  }

  /**
   * Hide toggleable content.
   */
  hide() {
    // Create and dispatch custom event
    this[EventName.ON_HIDE] = new CustomEvent(EventName.ON_HIDE, { bubbles: true, cancelable: true });
    this.control.dispatchEvent(this[EventName.ON_HIDE]);
    if (this[EventName.ON_HIDE].defaultPrevented) {
      return;
    }

    this.shown = false;

    if (this.ellipsis) {
      this.ellipsis.classList.remove(ClassName.DISPLAY_NONE);
    }

    this.control.setAttribute('aria-expanded', false);

    if (this.control.hasAttribute('aria-label')) {
      this.control.setAttribute('aria-label', this.showMoreLabelText);
    }

    this.control.textContent = this.showMoreText;
  }

  /**
   * Event handler for control click event.
   */
  toggle() {
    if (this.shown) {
      this.hide();
    } else {
      this.show();
    }
  }

  /**
   * Removes active instance of component.
   */
  remove() {
    Util.removeEvents(this.events);

    // Remove this reference from the array of instances.
    const index = instances.indexOf(this);
    instances.splice(index, 1);

    // Create and dispatch custom event
    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.control.dispatchEvent(this[EventName.ON_REMOVE]);
  }
}

class ShowMoreShowLessSingleElement extends ShowMoreShowLessBase {
  /**
   * Create a single-element variant, inherits from ShowMoreShowLessBase.
   *  @param {Object} opts - The show-more-show-less options.
   */
  constructor(opts) {
    super(opts);

    /**
     * The content that will be shown/hidden.
     */
    this.toggleableContent = this.el.querySelector(Selector.TOGGLEABLE_CONTENT);

    this.events.push({
      el: this.toggleableContent,
      type: 'focusout',
      handler: _toggleableContentOnFocusOut.bind(null, this.toggleableContent)
    });
    Util.addEvents(this.events);

    this.toggleableContent.setAttribute('tabindex', -1);
    this.toggleableContent.classList.add(ClassName.DISPLAY_NONE);
  }

  /**
   * Show toggleable content.
   */
  show() {
    super.show();
    this.toggleableContent.classList.remove(ClassName.DISPLAY_NONE);
    super.setFocusToElement(this.toggleableContent);
  }

  /**
   * Hide toggleable content.
   */
  hide() {
    super.hide();
    this.toggleableContent.classList.add(ClassName.DISPLAY_NONE);
    this.toggleableContent.setAttribute('tabindex', -1);
  }

  /**
   * Updates component element if content changes dynamically.
   * @param {Object} opts The options defined for the updated component.
   */
  update(opts = {}) {
    const _self = opts._self || this;

    if (_self.toggleableContent.innerHTML) {
      _self.control.classList.remove(ClassName.DISPLAY_NONE);
      _self.hide();
    } else {
      _self.control.classList.add(ClassName.DISPLAY_NONE);
      _self.ellipsis.classList.add(ClassName.DISPLAY_NONE);
    }

    // Create and dispatch custom event
    _self[EventName.ON_UPDATE] = new CustomEvent(EventName.ON_UPDATE, { bubbles: true });
    _self.el.dispatchEvent(_self[EventName.ON_UPDATE]);
  }
}

class ShowMoreShowLessMultiElement extends ShowMoreShowLessBase {
  /**
   * Create a multi-element variant, inherits from ShowMoreShowLessBase.
   * @param {Object} opts - The show-more-show-less options.
   * @param {Number} opts.hideAfter - The index of the element in the multi-element variant after which elements will be toggleable.
   */
  constructor(opts) {
    super(opts);
    this.hideAfter = opts.hideAfter || null;

    this.setChildren();

    const focusOuttarget = this.toggleableContent[0];

    this.events.push({
      el: this.toggleableContent[0],
      type: 'focusout',
      handler: _toggleableContentOnFocusOut.bind(null, focusOuttarget)
    });
    Util.addEvents(this.events);

    // Set attributes on html elements
    // Tabindex set to -1 so content can be focused when shown.
    this.toggleableContent[0].setAttribute('tabindex', -1);

    // Set default state to hidden.
    this.toggleableContent.forEach(node => {
      node.classList.add(ClassName.DISPLAY_NONE);
    });

    // Add mutation observers.
    this.childObserver = new MutationObserver(() => {
      this.update({ _self: this });
    });
    this.childObserver.observe(this.el.querySelector(Selector.TOGGLEABLE_CONTENT), { childList: true, subtree: true });
  }

  /**
   * Define visible and non-visible children in toggleable content based on data-count attribute passed to constructor.
   */
  setChildren() {
    this.visibleContent = this.el.querySelectorAll(
      Selector.TOGGLEABLE_CONTENT + ' > :nth-child(-n+' + (this.hideAfter - 1) + ')'
    );
    this.toggleableContent = this.el.querySelectorAll(
      Selector.TOGGLEABLE_CONTENT + ' > :nth-child(n+' + this.hideAfter + ')'
    );
  }

  /**
   * Show toggleable child elements.
   */
  show() {
    super.show();
    this.toggleableContent.forEach(node => {
      node.classList.remove(ClassName.DISPLAY_NONE);
    });

    if (this.toggleableContent) {
      super.setFocusToElement(this.toggleableContent[0]);
    }
  }

  /**
   * Hide toggleable child elements.
   */
  hide() {
    super.hide();

    if (this.toggleableContent.length > 0) {
      this.toggleableContent.forEach(node => {
        node.classList.add(ClassName.DISPLAY_NONE);
      });
      this.toggleableContent[0].setAttribute('tabindex', -1);
    }
  }

  /**
   * Updates the visible and nonvisible children if elements are added/removed dynamically.
   * @param {Object} opts the options for the updated component.
   */
  update(opts = {}) {
    const _self = opts._self || this;

    _self.setChildren();
    _self.visibleContent.forEach(node => {
      if (node.classList.contains(ClassName.DISPLAY_NONE)) {
        node.classList.remove(ClassName.DISPLAY_NONE);
      }

      if (node.hasAttribute('tabindex')) {
        node.removeAttribute('tabindex');
      }
    });

    if (_self.toggleableContent.length > 0) {
      _self.hide();
    }

    if (_self.toggleableContent.length > 1) {
      let hasTabIndex = false;
      _self.toggleableContent.forEach(node => {
        if (hasTabIndex) {
          node.removeAttribute('tabindex');
        }

        if (node.hasAttribute('tabindex')) {
          hasTabIndex = true;
        }
      });
    }

    if (_self.toggleableContent.length === 0 && !_self.el.classList.contains(ClassName.DISPLAY_NONE)) {
      _self.el.classList.add(ClassName.DISPLAY_NONE);
    }

    if (_self.toggleableContent.length > 0 && _self.el.classList.contains(ClassName.DISPLAY_NONE)) {
      _self.el.classList.remove(ClassName.DISPLAY_NONE);
    }

    // Create and dispatch custom event
    _self[EventName.ON_UPDATE] = new CustomEvent(EventName.ON_UPDATE, { bubbles: true });
    _self.el.dispatchEvent(_self[EventName.ON_UPDATE]);
  }

  /**
   * Remove instance of ShowMoreShowLess.
   */

  remove() {
    super.remove();
    this.childObserver.disconnect();
  }
}

export default ShowMoreShowLess;
