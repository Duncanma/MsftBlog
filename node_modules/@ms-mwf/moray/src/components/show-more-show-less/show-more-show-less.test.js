import ShowMoreShowLess, { Selector, EventName } from './show-more-show-less';

const idMap = [
  {
    container: 'id001cont',
    ellipsis: 'id002ellip',
    toggleableContent: 'toggleContent01',
    toggleButton: 'id003togg'
  },
  {
    container: 'id004cont',
    ellipsis: 'id005ellip',
    toggleableContent: 'toggleContent02',
    toggleButton: 'id006togg'
  },
  {
    container: 'id007cont',
    ellipsis: null,
    contentContainer: 'id008cont',
    visibleContent: ['visibleContent01'],
    toggleableContent: ['toggleContent03', 'toggleContent04', 'toggleContent05', 'toggleContent06'],
    toggleButton: 'id009togg'
  }
];
const eventValues = {
  hide: 'hidden',
  show: 'shown',
  remove: 'removed',
  update: 'updated'
};
const displayNoneClass = 'd-none';

const splitParagraphHtml = `<div id="${idMap[0].container}" data-mount="show-more-show-less" class="show-more-show-less">
  <div>
  <span>Visible Content</span>
  <span id="${idMap[0].ellipsis}" class="show-more-show-less-ellipsis">...</span>
  <span id="${idMap[0].toggleableContent}" class="${displayNoneClass} show-more-show-less-toggleable-content">Toggleable Content</span>
  </div>
  <button id="${idMap[0].toggleButton}" class="show-more-show-less-toggle" aria-controls="${idMap[0].toggleableContent}" aria-expanded="false" data-show-less-text="Show less">Show more</button>
  </div>`;

const splitParagraphWithLinksHtml = `<div id="${idMap[1].container}" data-mount="show-more-show-less"  class="show-more-show-less">
  <div>
  <span>Visible Content with links. <a href="#">link</a></span>
  <span id="${idMap[1].ellipsis}" class="show-more-show-less-ellipsis">...</span>
  <span id="${idMap[1].toggleableContent}" class="${displayNoneClass}  show-more-show-less-toggleable-content" tabindex="-1">Toggleable Content with links. <a href="#">Link</a> <a href="#">Link</a></span>
  </div>
  <button id="${idMap[1].toggleButton}" aria-controls="${idMap[1].toggleableContent}" class="show-more-show-less-toggle" aria-expanded="false" data-show-less-text="Show less">Show more</button>
  </div>`;

const inlineBlockElementsHtml = `<div id="${idMap[2].container}" data-mount="show-more-show-less" class="show-more-show-less" data-count="8">
  <div id="${idMap[2].contentContainer}" class="show-more-show-less-toggleable-content">

  <div>Item 1</div><div>Item 2</div><div>Item 3</div><div>Item 4</div><div>Item 5</div><div>Item 6</div>
  <div id="${idMap[2].visibleContent[0]}">Item 7</div>
  <div id="${idMap[2].toggleableContent[0]}">Item 8</div>
  <div id="${idMap[2].toggleableContent[1]}">Item 9</div>
  <div id="${idMap[2].toggleableContent[2]}">Item 10</div>

  </div>
  <button id="${idMap[2].toggleButton}" aria-controls="${idMap[2].toggleableContent}" class="show-more-show-less-toggle" aria-expanded="true" data-show-less-text="Show less">Show more</button>
  </div>`;

const newToggleableElement = `<div id="${idMap[2].toggleableContent[3]}">Item 11</div>`;

document.body.innerHTML = splitParagraphHtml + splitParagraphWithLinksHtml + inlineBlockElementsHtml;

describe.each`
  name                          | index
  ${'Split paragraph'}          | ${0}
  ${'Split paragraph w/ links'} | ${1}
  ${'Inline block elements'}    | ${2}
`('$name show more show less with no options passed in', ({ index }) => {
  let instances;
  let obj;
  let objIds;
  let eventValue = '';

  beforeAll(() => {
    // Initialize
    document.querySelectorAll(Selector.DATA_MOUNT).forEach(element => {
      new ShowMoreShowLess({ el: element });
    });

    instances = ShowMoreShowLess.getInstances();
    obj = instances.find(inst => inst.el.id === idMap[index].container);
    objIds = idMap[index];

    // Setup event listeners for custom events
    obj.el.addEventListener('onHide', () => {
      eventValue = eventValues.hide;
    });
    obj.el.addEventListener('onShow', () => {
      eventValue = eventValues.show;
    });
    obj.el.addEventListener('onRemove', () => {
      eventValue = eventValues.remove;
    });
  });

  it('should be initialized', () => {
    expect(obj.el.id).toEqual(objIds.container);

    if (obj.constructor.name === 'ShowMoreShowLessSingleElement') {
      expect(obj.toggleableContent.id).toEqual(objIds.toggleableContent);
    } else {
      expect(obj.toggleableContent[0].id).toEqual(objIds.toggleableContent[0]);
      expect(obj.toggleableContent[1].id).toEqual(objIds.toggleableContent[1]);
      expect(obj.toggleableContent[2].id).toEqual(objIds.toggleableContent[2]);
    }

    if (obj.ellipsis) {
      expect(obj.ellipsis.id).toEqual(objIds.ellipsis);
    }

    expect(obj.shown).toEqual(false);

    expect(obj.showMoreText).toEqual('Show more');
    expect(obj.showLessText).toEqual('Show less');

    if (obj.constructor.name === 'ShowMoreShowLessSingleElement') {
      expect(obj.toggleableContent.classList.contains(displayNoneClass)).toEqual(true);
    } else {
      expect(obj.toggleableContent[0].classList.contains(displayNoneClass)).toEqual(true);
      expect(obj.toggleableContent[1].classList.contains(displayNoneClass)).toEqual(true);
      expect(obj.toggleableContent[2].classList.contains(displayNoneClass)).toEqual(true);
    }
  });

  describe('when more text is shown', () => {
    beforeAll(() => {
      obj.show();
    });

    it('should show toggleable text', () => {
      expect(obj.shown).toEqual(true);
      expect(obj.control.attributes['aria-expanded'].value).toEqual('true');
      expect(obj.el.classList.contains(displayNoneClass)).toEqual(false);
    });

    it('should hide the ellipsis if there is one', () => {
      if (obj.ellipsis) {
        expect(obj.ellipsis.classList.contains(displayNoneClass)).toEqual(true);
      }
    });

    it('should trigger a custom event', () => {
      expect(eventValue).toEqual(eventValues.show);
    });

    it('should focus the toggleable content', () => {
      if (obj.constructor.name === 'ShowMoreShowLessSingleElement') {
        expect(document.activeElement.id).toEqual(objIds.toggleableContent);
      } else {
        expect(document.activeElement.id).toEqual(objIds.toggleableContent[0]);
      }
    });
  });

  describe('when more text is hidden', () => {
    beforeAll(() => {
      obj.hide();
    });

    it('should hide toggleable text', () => {
      expect(obj.shown).toEqual(false);
      expect(obj.control.attributes['aria-expanded'].value).toEqual('false');
      expect(obj.el.classList.contains(displayNoneClass)).toEqual(false);
    });

    it('should hide the ellipsis if there is one', () => {
      if (obj.ellipsis) {
        expect(obj.ellipsis.classList.contains(displayNoneClass)).toEqual(false);
      }
    });

    it('should trigger a custom event', () => {
      expect(eventValue).toEqual(eventValues.hide);
    });
  });

  describe('when the instance is removed', () => {
    beforeAll(() => {
      obj.remove();
    });

    it('should be removed from the instances array', () => {
      expect(
        instances.some(inst => inst.el.id !== idMap[index].toggleButton)
      ).toBeTruthy();
    });

    it('should trigger a custom event', () => {
      expect(eventValue).toEqual(eventValues.remove);
    });
  });

  describe('show and hide with preventDefault', () => {
    afterEach(() => {
      jest.resetAllMocks();
    });

    it('should cancel show if default is prevented', () => {
      obj.hide();
      obj.control.dispatchEvent = jest.fn(e => e.preventDefault());
      obj.show();

      expect(obj.control.dispatchEvent).toBeCalled();
      expect(obj.control.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_SHOW);
      expect(obj.control.dispatchEvent.mock.calls[0][0].defaultPrevented).toBe(true);
      expect(obj.shown).toEqual(false);
      expect(obj.control.getAttribute('aria-expanded')).toEqual('false');
      expect(obj.control.textContent).toEqual('Show more');
    });

    it('should cancel hide when default is prevented', () => {
      obj.show();
      obj.control.dispatchEvent = jest.fn(e => e.preventDefault());
      obj.hide();

      expect(obj.control.dispatchEvent).toBeCalled();
      expect(obj.control.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_HIDE);
      expect(obj.control.dispatchEvent.mock.calls[0][0].defaultPrevented).toBe(true);
      expect(obj.shown).toEqual(true);
      expect(obj.control.getAttribute('aria-expanded')).toEqual('true');
      expect(obj.control.textContent).toEqual('Show less');
    });
  });
});

describe('Single-element update method', () => {
  let instance;

  describe('When the toggleable content is removed', () => {
    beforeAll(() => {
      instance = new ShowMoreShowLess({ el: document.getElementById(idMap[0].container) });
      instance.el.querySelector(`#${idMap[0].toggleableContent}`).innerHTML = '';
      instance.update();
    });

    it('should not display the toggle button and ellipsis', () => {
      expect(instance.control.classList.contains(displayNoneClass)).toBeTruthy();
      expect(instance.ellipsis.classList.contains(displayNoneClass)).toBeTruthy();
    });

    it('should show the button and ellipsis if overflow text is added', () => {
      instance.el.querySelector(`#${idMap[0].toggleableContent}`).innerHTML = '<div>Toggleable content added.</div>';
      instance.update();
      expect(instance.control.classList.contains(displayNoneClass)).toBeFalsy();
      expect(instance.ellipsis.classList.contains(displayNoneClass)).toBeFalsy();
    });
  });
});

describe('Multi-element update tests', () => {
  let instances;
  let obj;
  let eventValue;

  describe('When a new element is inserted as the first toggleable element', () => {
    beforeAll(() => {
      document.querySelectorAll(Selector.DATA_MOUNT).forEach(element => {
        new ShowMoreShowLess({ el: element });
      });

      instances = ShowMoreShowLess.getInstances();
      obj = instances.find(inst => inst.el.id === idMap[2].container && inst.toggleableContent && inst.visibleContent);
      document
        .querySelector('#' + idMap[2].toggleableContent[0])
        .insertAdjacentHTML('beforebegin', newToggleableElement);

      obj.el.addEventListener('onUpdate', () => {
        eventValue = eventValues.update;
      });
    });

    it('should trigger a custom event', () => {
      expect(eventValue).toEqual(eventValues.update);
    });

    it('togglable content should have a length of 4', () => {
      expect(obj.toggleableContent.length).toEqual(4);
    });

    it('visible content should have a length of 7', () => {
      expect(obj.visibleContent.length).toEqual(7);
    });

    it('added element should be the at the first index in toggleable content', () => {
      expect(obj.toggleableContent[0].id).toEqual(idMap[2].toggleableContent[3]);
    });

    it('added element should should have a class of d-none', () => {
      expect(obj.toggleableContent[0].classList.contains('d-none')).toBeTruthy();
    });

    it('previous first toggleable element should have its tabindex removed', () => {
      expect(obj.toggleableContent[1].hasAttribute('tabindex')).toBeFalsy();
    });

    it('added element should have a tabindex value of -1', () => {
      expect(obj.toggleableContent[0].getAttribute('tabindex')).toEqual('-1');
    });
  });

  describe('When a new element is inserted as the last visible element', () => {
    beforeAll(() => {
      document.querySelector('#' + idMap[2].toggleableContent[3]).remove();
      document
        .querySelector('#' + obj.visibleContent[obj.visibleContent.length - 1].id)
        .insertAdjacentHTML('beforebegin', newToggleableElement);
    });

    it('should trigger a custom event', () => {
      expect(eventValue).toEqual(eventValues.update);
    });

    it('togglable content should have a length of 4', () => {
      expect(obj.toggleableContent.length).toEqual(4);
    });

    it('visible content should have a length of 7', () => {
      expect(obj.visibleContent.length).toEqual(7);
    });

    it('added element should be the at the last index in visible content', () => {
      expect(obj.visibleContent[obj.visibleContent.length - 1].id).toEqual(idMap[2].toggleableContent[3]);
    });

    it('previous last visible element should be the first toggleable element', () => {
      expect(obj.toggleableContent[0].id).toEqual(idMap[2].visibleContent[0]);
    });

    it('previous last visible element should have a class of d-none', () => {
      expect(obj.toggleableContent[0].classList.contains('d-none')).toBeTruthy();
    });

    it('previous first toggleable element should have its tabindex removed', () => {
      expect(document.querySelector('#' + idMap[2].toggleableContent[0]).hasAttribute('tabindex')).toBeFalsy();
    });

    it('previous first visible element should have a tabindex value of -1', () => {
      expect(document.querySelector('#' + idMap[2].visibleContent[0]).getAttribute('tabindex')).toEqual('-1');
    });
  });

  describe('When a visible element is removed', () => {
    beforeAll(() => {
      document.querySelector('#' + idMap[2].toggleableContent[3]).remove();
      obj.visibleContent[0].remove();
    });

    it('should trigger a custom event', () => {
      expect(eventValue).toEqual(eventValues.update);
    });

    it('togglable content should have a length of 2', () => {
      expect(obj.toggleableContent.length).toEqual(2);
    });

    it('visible content should have a length of 7', () => {
      expect(obj.visibleContent.length).toEqual(7);
    });

    it('previous first toggleable element should now be the last visible element', () => {
      expect(obj.visibleContent[obj.visibleContent.length - 1].id).toEqual(idMap[2].toggleableContent[0]);
    });

    it('previous first toggleable element should not have a class of d-none', () => {
      expect(obj.visibleContent[obj.visibleContent.length - 1].classList.contains('d-none')).toBeFalsy();
    });

    it('previous first toggleable element should not have a tabindex', () => {
      expect(obj.visibleContent[obj.visibleContent.length - 1].hasAttribute('tabindex')).toBeFalsy();
    });

    it('second toggleable element should now be first toggleable element', () => {
      expect(obj.toggleableContent[0].id).toEqual(idMap[2].toggleableContent[1]);
    });

    it('second toggleable element should have a tabindex value of -1', () => {
      expect(obj.visibleContent[obj.visibleContent.length - 1].hasAttribute('tabindex')).toBeFalsy();
    });
  });

  describe('When all toggleable elements are removed', () => {
    beforeAll(() => {
      obj.toggleableContent.forEach(element => {
        element.remove();
      });
    });

    it('should trigger a custom event', () => {
      expect(eventValue).toEqual(eventValues.update);
    });

    it('togglable content should have a length of 0', () => {
      expect(obj.toggleableContent.length).toEqual(0);
    });

    it('toggle element should have a d-none class', () => {
      expect(obj.el.classList.contains('d-none')).toBeTruthy();
    });
  });
});
