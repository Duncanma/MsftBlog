import Util from '../../js/util';

const instances = [];

export const EventName = {
  HIDE: 'onHide',
  HIDDEN: 'onHidden',
  SHOW: 'onShow',
  SHOWN: 'onShown',
  ON_REMOVE: 'onRemove',
  FOCUSIN: 'focusin',
  RESIZE: 'resize',
  CLICK_DISMISS: 'click.dismiss',
  KEYDOWN: 'keydown'
};

const ClassName = {
  SCROLLABLE: 'modal-dialog-scrollable',
  SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
  BACKDROP: 'modal-backdrop',
  OPEN: 'modal-open',
  FADE: 'fade',
  SHOW: 'show'
};

export const Selector = {
  DIALOG: '.modal-dialog',
  MODAL_BODY: '.modal-body',
  DATA_MOUNT: '[data-mount="modal"]',
  DATA_DISMISS: '[data-dismiss="modal"]',
  FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
  STICKY_CONTENT: '.sticky-top'
};

// Event Handlers
/**
 * Handler for keydown event
 * @param {Event} event The event fired by the listener
 */
function keydownEvent(event) {
  switch (Util.getKeyCode(event)) {
    case Util.keyCodes.ESC:
      event.preventDefault();
      this.hide();
      break;
    case Util.keyCodes.TAB:
      if (
        (document.activeElement === this.firstTabbableElement || document.activeElement === this.el) &&
        event.shiftKey
      ) {
        event.preventDefault();
        this.lastTabbableElement.focus();
      }

      if (document.activeElement === this.lastTabbableElement && !event.shiftKey) {
        event.preventDefault();
        this.firstTabbableElement.focus();
      }

      break;
    default:
      break;
  }
}

/**
 * Handler for focus event
 * @param {Event} event The event fired by the listener
 */
function focusEvent(event) {
  if (document !== event.target && this.el !== event.target && !this.el.contains(event.target)) {
    this.el.focus();
  }
}

/**
 * Handler for backdrop event
 * @param {Event} event The event fired by the listener
 */
function backdropEvent(event) {
  if (!this.dialog.contains(event.target)) {
    // create and dispatch the event
    this.el.dispatchEvent(this[EventName.CLICK_DISMISS]);
  }
}

/**
 * Handler for dismiss click event
 * @param {Event} event The event fired by the listener
 */
function clickDismissHandler(event) {
  if (this.ignoreBackdropClick) {
    this.ignoreBackdropClick = false;
    return;
  }

  if (event.target !== event.currentTarget) {
    return;
  }

  this.hide();
}

/**
 * Handles the internal logic for showing an element
 */
function _showElement() {
  const transition = this.el.classList.contains(ClassName.FADE);

  if (!this.el.parentNode || this.el.parentNode.nodeType !== Node.ELEMENT_NODE) {
    // Don't move modal's DOM position
    document.body.append(this.el);
  }

  this.el.style.display = 'block';
  this.el.removeAttribute('aria-hidden');
  this.el.setAttribute('aria-modal', true);

  if (this.dialog.classList.contains(ClassName.SCROLLABLE)) {
    this.dialog.querySelector(Selector.MODAL_BODY).scrollTop = 0;
  } else {
    this.el.scrollTop = 0;
  }

  if (transition) {
    Util.reflow(this.el);
  }

  this.el.classList.add(ClassName.SHOW);

  _enforceFocus.call(this);

  const transitionComplete = () => {
    const modalHeader = this.el.querySelector('.modal-header');
    // For accessibility purposes, scrollable modals will have the focus set to the header if the following conditions are met:
    // 1) Modal is scrollable
    // 2) There is a value for title.
    // If there is no value for title, then there will be no text in the header. So, focus will be set to the modal window.
    // Implemented for instances such as image gallery, where content is automatically read by screen readers when shown (2439).
    const elementReceivingFocus = modalHeader.getAttribute('tabindex') === '-1' ? modalHeader : this.el;

    elementReceivingFocus.focus();

    this.isTransitioning = false;
    this.el.dispatchEvent(this[EventName.SHOWN]);
  };

  if (transition) {
    const transitionDuration = Util.getTransitionDurationFromElement(this.dialog);

    this.dialog.addEventListener(Util.TRANSITION_END, transitionComplete.bind(this), { once: true });
    Util.emulateTransitionEnd(this.dialog, transitionDuration);
  } else {
    transitionComplete.call(this);
  }
}

/**
 * Ensures the the focus is enforced on an element
 */
function _enforceFocus() {
  document.removeEventListener(EventName.FOCUSIN, focusEvent); // Guard against infinite focus loop
  document.addEventListener(EventName.FOCUSIN, focusEvent.bind(this));
}

/**
 * Add and remove the event listeners for the keydown event
 */
function _setKeydownEvents() {
  if (this.isShown) {
    this.el.addEventListener(EventName.KEYDOWN, keydownEvent.bind(this));
  } else {
    this.el.removeEventListener(EventName.KEYDOWN, keydownEvent);
  }
}

/**
 * Add and remove the resize event
 */
function _setResizeEvent() {
  if (this.isShown) {
    window.addEventListener(EventName.RESIZE, event => this.handleUpdate(event));
  } else {
    window.removeEventListener(EventName.RESIZE, event => this.handleUpdate(event));
  }
}

/**
 * Private handler for hiding a modal
 */
function _hideModal() {
  this.el.style.display = 'none';
  this.el.setAttribute('aria-hidden', true);
  this.el.removeAttribute('aria-modal');
  this.isTransitioning = false;
  _showBackdrop.call(this, () => {
    document.body.classList.remove(ClassName.OPEN);
    _resetAdjustments.call(this);
    _resetScrollbar.call(this);
    this.el.dispatchEvent(this[EventName.HIDDEN]);
    document.body.removeEventListener('click', backdropEvent);
  });
}

/**
 * Remove backdrop from DOM
 */
function _removeBackdrop() {
  if (this.backdrop) {
    this.backdrop.remove();
    this.backdrop = null;
  }

  // Return the focus to the trigger
  if (this.trigger) {
    this.trigger.focus();
  }
}

/**
 * Show Backdrop
 * @param {*} callback Function to callback once backdrop is shown
 */
function _showBackdrop(callback) {
  const animate = this.el.classList.contains(ClassName.FADE) ? ClassName.FADE : '';

  if (this.isShown) {
    this.backdrop = document.createElement('div');
    this.backdrop.className = ClassName.BACKDROP;

    if (animate) {
      this.backdrop.classList.add(animate);
    }

    document.body.append(this.backdrop);

    document.body.addEventListener('click', backdropEvent.bind(this));

    this.el.addEventListener(EventName.CLICK_DISMISS, clickDismissHandler.bind(this));

    if (animate) {
      Util.reflow(this.backdrop);
    }

    this.backdrop.classList.add(ClassName.SHOW);

    if (!callback) {
      return;
    }

    if (!animate) {
      callback();
      return;
    }

    const backdropTransitionDuration = Util.getTransitionDurationFromElement(this.backdrop);

    this.backdrop.addEventListener(Util.TRANSITION_END, callback, { once: true });
    Util.emulateTransitionEnd(this.backdrop, backdropTransitionDuration);
  } else if (!this.isShown && this.backdrop) {
    this.backdrop.classList.remove(ClassName.SHOW);

    const callbackRemove = () => {
      _removeBackdrop.call(this);
      if (callback) {
        callback();
      }
    };

    if (this.el.classList.contains(ClassName.FADE)) {
      const backdropTransitionDuration = Util.getTransitionDurationFromElement(this.backdrop);
      this.backdrop.addEventListener(Util.TRANSITION_END, callbackRemove, { once: true });
      Util.emulateTransitionEnd(this.backdrop, backdropTransitionDuration);
    } else {
      callbackRemove();
    }
  } else if (callback) {
    callback();
  }
}

// ----------------------------------------------------------------------
// the following methods are used to handle overflowing modals
// ----------------------------------------------------------------------

function _adjustDialog() {
  const isModalOverflowing = this.el.scrollHeight > document.documentElement.clientHeight;

  if (!this.isBodyOverflowing && isModalOverflowing) {
    this.el.style.paddingLeft = `${this.scrollbarWidth}px`;
  }

  if (this.isBodyOverflowing && !isModalOverflowing) {
    this.el.style.paddingRight = `${this.scrollbarWidth}px`;
  }
}

function _resetAdjustments() {
  this.el.style.paddingLeft = '';
  this.el.style.paddingRight = '';
}

function _checkScrollbar() {
  const rect = document.body.getBoundingClientRect();
  this.isBodyOverflowing = rect.left + rect.right < window.innerWidth;
  this.scrollbarWidth = _getScrollbarWidth();
}

function _setScrollbar() {
  if (this.isBodyOverflowing) {
    // Note: DOMNode.style.paddingRight returns the actual value or '' if not set
    const fixedContent = [].slice.call(document.querySelectorAll(Selector.FIXED_CONTENT));
    const stickyContent = [].slice.call(document.querySelectorAll(Selector.STICKY_CONTENT));

    // Adjust fixed content padding
    fixedContent.forEach(element => {
      const actualPadding = element.style.paddingRight ? element.style.paddingRight : 0;
      const calculatedPadding = getComputedStyle(element)['padding-right'];
      this.data.set({ element, attribute: 'padding-right' }, actualPadding);
      element.style.paddingRight = `${parseFloat(calculatedPadding) + this.scrollbarWidth}px`;
    });

    // Adjust sticky content margin
    stickyContent.forEach(element => {
      const actualMargin = element.style.marginRight ? element.style.marginRight : 0;
      const calculatedMargin = getComputedStyle(element)['margin-right'];
      this.data.set({ element, attribute: 'margin-right' }, actualMargin);
      element.style.marginRight = `${parseFloat(calculatedMargin) - this.scrollbarWidth}px`;
    });

    // Adjust body padding
    const actualPadding = document.body.style.paddingRight ? document.body.style.paddingRight : 0;
    const calculatedPadding = getComputedStyle(document.body)['padding-right'];
    this.data.set({ element: document.body, attribute: 'padding-right' }, actualPadding);
    document.body.style.paddingRight = `${parseFloat(calculatedPadding) + this.scrollbarWidth}px`;
  }

  document.body.classList.add(ClassName.OPEN);
}

function _resetScrollbar() {
  // Restore fixed content padding
  const fixedContent = [].slice.call(document.querySelectorAll(Selector.FIXED_CONTENT));
  fixedContent.forEach(element => {
    const key = { element, attribute: 'padding-right' };
    // Retrieve the element from the Map
    const padding = this.data.get(key);
    element.style.paddingRight = padding ? padding : '';
    // Remove the item from the map
    this.data.delete(key);
  });

  // Restore sticky content
  const elements = [].slice.call(document.querySelectorAll(`${Selector.STICKY_CONTENT}`));
  elements.forEach(element => {
    const key = { element, attribute: 'margin-right' };
    // Retrieve the element from the Map
    const margin = this.data.get(key);
    if (typeof margin !== 'undefined') {
      element.style.marginRight = margin;
      this.data.delete(key);
    }
  });

  // Restore body padding
  const key = { element: document.body, attribute: 'padding-right' };
  const padding = this.data.get(key);
  this.data.delete(key);
  document.body.style.paddingRight = padding ? padding : '';
}

function _getScrollbarWidth() {
  // thx d.walsh
  const scrollDiv = document.createElement('div');
  scrollDiv.className = ClassName.SCROLLBAR_MEASURER;
  document.body.append(scrollDiv);
  const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
  scrollDiv.remove();
  return scrollbarWidth;
}

function _setTabbableElements() {
  this.tabbableElements = Util.getTabbableElements(this.dialog).filter(el => el.offsetHeight > 0);
  this.firstTabbableElement = this.tabbableElements[0];
  this.lastTabbableElement = this.tabbableElements[this.tabbableElements.length - 1];
}

/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

class Modal {
  /**
   * Create a Modal.
   * @param {Object} opts - The modal options.
   * @param {Node} opts.el - The modal.
   * @param {Boolean} opts.displayOnInit - whether to display modal after init, defaults to false
   */
  constructor(opts) {
    // Modal element
    this.el = opts.el;

    // Toggle button for modal
    this.button = document.querySelector(`[data-target="#${this.el.id}"]`);

    this.dialog = this.el.querySelector(Selector.DIALOG);
    this.backdrop = null;
    this.isShown = false;
    this.isBodyOverflowing = false;
    this.ignoreBackdropClick = false;
    this.isTransitioning = false;
    this.scrollbarWidth = 0;
    this.data = new WeakMap();

    this.dialogObserver = new MutationObserver(_setTabbableElements.bind(this));

    this[EventName.SHOWN] = new CustomEvent(EventName.SHOWN, { detail: this.el });
    this[EventName.SHOW] = new CustomEvent(EventName.SHOW, { detail: this.el });
    this[EventName.HIDE] = new CustomEvent(EventName.HIDE);
    this[EventName.HIDDEN] = new CustomEvent(EventName.HIDDEN);
    this[EventName.CLICK_DISMISS] = new CustomEvent(EventName.CLICK_DISMISS);

    // Add event handlers
    this.events = [];
    if (this.button) {
      this.events = [
        {
          el: this.button,
          type: 'click',
          handler: event => {
            this.toggle(event);
          }
        }
      ];
      Util.addEvents(this.events);
    }

    if (opts.displayOnInit || this.el.dataset.displayOnInit === 'true') {
      this.show();
    }

    instances.push(this);
  }

  /**
   * Toggle hide and show states of the modal
   * @param {Event} event - The event that fired the toggle
   */
  toggle(event) {
    if (event) {
      this.trigger = event.target;
    }

    return this.isShown ? this.hide() : this.show();
  }

  /**
   * Show the modal
   */
  show() {
    if (this.isShown || this.isTransitioning) {
      return;
    }

    if (this.el.classList.contains(ClassName.FADE)) {
      this.isTransitioning = true;
    }

    this.el.dispatchEvent(this[EventName.SHOW]);

    if (this.isShown || this[EventName.SHOW].defaultPrevented) {
      return;
    }

    this.isShown = true;

    _checkScrollbar.call(this);
    _setScrollbar.call(this);

    _adjustDialog.call(this);

    _setResizeEvent.call(this);

    // Add event listeners to the dismiss action
    this.el.addEventListener(EventName.CLICK_DISMISS, event => this.hide(event));

    // Find all the dismiss attribute elements and cause the modal to hide
    this.el
    .querySelectorAll(Selector.DATA_DISMISS)
    .forEach(_element => _element.addEventListener('click', event => this.hide(event)));

    _showBackdrop.call(this, () => {
      _showElement.call(this);

      _setTabbableElements.call(this);
      _setKeydownEvents.call(this);

      this.dialogObserver.observe(this.dialog, { attributes: true, childList: true, subtree: true });
    });
  }

  /**
   * Hide the modal
   * @param {Event} event the event that triggered the hide
   */
  hide(event) {
    if (event) {
      event.preventDefault();
    }

    if (!this.isShown || this.isTransitioning) {
      return;
    }

    this.el.dispatchEvent(this[EventName.HIDE]);

    if (!this.isShown || this[EventName.HIDE].defaultPrevented) {
      return;
    }

    this.isShown = false;
    const transition = this.el.classList.contains(ClassName.FADE);

    if (transition) {
      this.isTransitioning = true;
    }

    _setKeydownEvents.call(this);
    _setResizeEvent.call(this);

    const mainContent = document.querySelector('body > main');
    if (mainContent && mainContent.getAttribute('aria-hidden') === 'true') {
      mainContent.removeAttribute('aria-hidden');
    }

    document.removeEventListener(EventName.FOCUSIN, focusEvent);

    this.el.classList.remove(ClassName.SHOW);

    this.el.removeEventListener(EventName.CLICK_DISMISS, clickDismissHandler);

    this.dialogObserver.disconnect();

    if (transition) {
      const transitionDuration = Util.getTransitionDurationFromElement(this.el);

      this.el.addEventListener(Util.TRANSITION_END, event => _hideModal.call(this, event), { once: true });
      Util.emulateTransitionEnd(this.el, transitionDuration);
    } else {
      _hideModal.call(this);
    }
  }

  /**
   * Handle update that happens with the modal
   */
  handleUpdate() {
    _adjustDialog.call(this);
  }

  /**
   * Remove the event handlers
   */
  remove() {
    // Remove event handlers, observers, etc.
    Util.removeEvents(this.events);
    document.removeEventListener(EventName.FOCUSIN, focusEvent);

    // Remove this reference from the array of instances.
    const index = instances.indexOf(this);
    instances.splice(index, 1);

    // Create and dispatch custom event
    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_REMOVE]);
  }

  /**
   * Get the modal instances.
   * @returns {Object[]} An array of modal instances
   */
  static getInstances() {
    return instances;
  }
}

export default Modal;
