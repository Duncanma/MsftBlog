import Util from '../../js/util';
import Modal, { EventName } from './modal';

const modalButtonHtml =
  '<button type="button" class="btn btn-primary" data-target="#example-modal">Example Modal</button>';
const modalHtml = `
  <div data-mount="modal" class="modal" id="example-modal" tabindex="-1" role="dialog" aria-labelledby="modal-label-id" aria-hidden="true">
    <div class="modal-dialog" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="modal-title h6" id="modal-label-id">Down the Rabbit-Hole</h2>
          <button type="button" class="close " data-dismiss="modal" aria-label="Close dialog window"></button>
        </div>
        <div class="modal-body">
          <p>Alice was beginning to get very tired of sitting by her sister on the bank, and of having nothing to do: once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it, ‘and what is the use of a book,’ thought Alice ‘without pictures or conversations?’</p>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary mr-2" data-dismiss="modal">Close</button> <button type="button" class="btn btn-primary">Save changes</button>
        </div>
      </div>
    </div>
  </div>
`;

document.body.innerHTML = modalButtonHtml + modalHtml;

const escapePressed = new KeyboardEvent('keydown', { keyCode: Util.keyCodes.ESC, bubbles: true, shiftKey: false });

describe('Modal', () => {
  let modalInstance;

  beforeEach(() => {
    // Set up document body
    modalInstance = new Modal({ el: document.getElementById('example-modal') });
  });

  afterEach(() => {
    modalInstance.remove();
    jest.clearAllMocks();
  });

  it('should be initialized', () => {
    expect(modalInstance.el).toBeDefined();
  });

  it('should close the modal when the escape key is pressed', () => {
    modalInstance.show();
    modalInstance.el.dispatchEvent(escapePressed);
    expect(modalInstance.isShown).toBe(false);
  });

  it('should close the modal when the backdrop is clicked', () => {
    modalInstance.show();
    expect(modalInstance.isShown).toBe(true);
    document.querySelector('.modal-backdrop').click();
    expect(modalInstance.isShown).toBe(false);
  });

  it('should close the modal when the dismiss button is clicked', () => {
    modalInstance.show();
    expect(modalInstance.isShown).toBe(true);
    document.querySelector('[data-dismiss]').click();
    expect(modalInstance.isShown).toBe(false);
  });

  it('should be able to be removed', () => {
    modalInstance.remove();
    const instances = Modal.getInstances();
    expect(instances.length).toBe(0);
  });

  it('should set the modal body scrolltop if scrollable', () => {
    const modalBody = modalInstance.el.querySelector('.modal-body');
    modalBody.scrollTop = 20;
    modalInstance.el.querySelector('.modal-dialog').classList.add('modal-dialog-scrollable');
    modalInstance.show();
    expect(modalBody.scrollTop).toBe(0);
  });

  it('should animate the backdrop when set to animate', () => {
    modalInstance.el.classList.add('fade');
    const spy = jest.spyOn(Util, 'emulateTransitionEnd');
    modalInstance.show();
    modalInstance.isTransitioning = false;
    modalInstance.hide();
    expect(spy).toHaveBeenCalledTimes(2);
  });

  describe('Event triggers', () => {
    describe('show()', () => {
      beforeEach(() => {
        modalInstance.el.dispatchEvent = jest.fn();
        modalInstance.show();
      });

      it('should trigger the `onShow` custom event', () => {
        expect(modalInstance.el.dispatchEvent).toBeCalled();
        expect(modalInstance.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.SHOW);
      });
    });
    describe('hide()', () => {
      beforeEach(() => {
        modalInstance.isShown = true;
        modalInstance.el.dispatchEvent = jest.fn();
        modalInstance.hide();
      });

      it('should trigger the `hidden` custom event', () => {
        expect(modalInstance.el.dispatchEvent).toBeCalled();
        expect(modalInstance.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.HIDE);
      });
    });
    describe('remove()', () => {
      beforeEach(() => {
        modalInstance.el.dispatchEvent = jest.fn();
        modalInstance.remove();
      });

      it('should trigger the `onRemove` custom event', () => {
        expect(modalInstance.el.dispatchEvent).toBeCalled();
        expect(modalInstance.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_REMOVE);
      });
    });
    describe('update()', () => {
      beforeEach(() => {
        modalInstance.el.dispatchEvent = jest.fn();
        modalInstance.update();
      });

      it('should trigger the `onUpdate` custom event', () => {
        expect(modalInstance.el.dispatchEvent).toBeCalled();
        expect(modalInstance.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_UPDATE);
      });
    });
  });
});
