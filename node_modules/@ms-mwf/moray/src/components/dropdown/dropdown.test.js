import Dropdown, { EventName } from './dropdown';
import Util from '../../js/util';

const dropdownAltClass = 'dropleft';
const dropdownAltPlacement = 'top';

const dropdownBadClass = 'dropout';
const dropdownBadPlacement = 'zigzag';

const dropdownDefaultHtml = `
  <div class="dropdown">
    <button id="dd01" data-mount="dropdown" aria-controls="ddmenu01">Test button</button>
    <ul class="dropdown-menu" id="ddmenu01">
      <li>
        <a class="dropdown-item" href="#" id="dd01_item01">Item 1</a>
      </li>
      <li>
        <a class="dropdown-item" href="#" id="dd01_item02">Item 2</a>
      </li>
      <li>
        <a class="dropdown-item" href="#" id="dd01_item03">Item 3</a>
      </li>
    </ul>
  </div>
`;

const dropdownAltHtml = `
  <div class="${dropdownAltClass}">
    <button id="dd02" data-mount="dropdown" aria-controls="ddmenu02" data-placement="${dropdownAltPlacement}" data-alignment="end" data-disable-reflow>Test button</button>
    <ul class="dropdown-menu" id="ddmenu02">
      <li>
        <a class="dropdown-item" href="#" id="dd02_item01">Item 1</a>
      </li>
      <li>
        <a class="dropdown-item" href="#" id="dd02_item02">Item 2</a>
      </li>
      <li>
        <a class="dropdown-item" href="#" id="dd02_item03">Item 3</a>
      </li>
    </ul>
  </div>
`;

const dropdownBadHtml = `
  <div class="${dropdownBadClass}">
    <button id="dd03" data-mount="dropdown" aria-controls="ddmenu03" data-placement="${dropdownBadPlacement}" data-alignment="end" data-disable-reflow>Test button</button>
    <ul class="dropdown-menu" id="ddmenu03">
      <li>
        <a class="dropdown-item" href="#" id="dd03_item01">Item 1</a>
      </li>
      <li>
        <a class="dropdown-item" href="#" id="dd03_item02">Item 2</a>
      </li>
      <li>
        <a class="dropdown-item" href="#" id="dd03_item03">Item 3</a>
      </li>
    </ul>
  </div>
`;

const dropdownNotListHtml = `
  <div class="dropdown">
    <button id="dd04" data-mount="dropdown" aria-controls="ddmenu04">Test button</button>
    <div class="dropdown-menu" id="ddmenu04">
      <button>Zuul</button>
    </div>
  </div>
`;

const enterKeyPressed = new KeyboardEvent('keydown', { keyCode: Util.keyCodes.ENTER, bubbles: true });
const spaceBarPressed = new KeyboardEvent('keydown', { keyCode: Util.keyCodes.SPACE, bubbles: true });
const escKeyPressed = new KeyboardEvent('keydown', { keyCode: Util.keyCodes.ESC, bubbles: true });
const downArrowPressed = new KeyboardEvent('keydown', { keyCode: Util.keyCodes.ARROW_DOWN, bubbles: true });
const upArrowPressed = new KeyboardEvent('keydown', { keyCode: Util.keyCodes.ARROW_UP, bubbles: true });
// const clickEvent = new MouseEvent('click', { bubbles: true, cancelable: true });
const mouseDownEvent = new MouseEvent('mousedown', { bubbles: true, cancelable: true });
const focusInEvent = new MouseEvent('focusin', { bubbles: true, cancelable: true });

// Set up our document body
document.body.innerHTML = dropdownDefaultHtml + dropdownAltHtml + dropdownBadHtml + dropdownNotListHtml;

describe(Dropdown.name, () => {
  let dropdownDefault;

  it('should be initialized', () => {
    dropdownDefault = new Dropdown({
      el: document.querySelector('#dd01')
    });

    const instances = Dropdown.getInstances();
    expect(instances.indexOf(dropdownDefault)).not.toEqual(-1);
    expect(dropdownDefault.el.id).toEqual('dd01');
    expect(dropdownDefault.menu.id).toEqual('ddmenu01');
    expect(dropdownDefault.placement).toEqual('bottom');
    expect(dropdownDefault.alignment).toEqual('start');
    expect(dropdownDefault.offset).toEqual(0);
    expect(dropdownDefault.enableReflow).toEqual(true);
    expect(dropdownDefault.enableFade).toEqual(false);
    expect(dropdownDefault.shown).toEqual(false);
  });

  describe('with options set using HTML attributes', () => {
    let dropdownAlt;

    beforeEach(() => {
      dropdownAlt = new Dropdown({
        el: document.querySelector('#dd02')
      });
    });

    it('should be initialized', () => {
      expect(dropdownAlt.el.id).toEqual('dd02');
      expect(dropdownAlt.menu.id).toEqual('ddmenu02');
      expect(dropdownAlt.placement).toEqual('left');
      expect(dropdownAlt.alignment).toEqual('end');
      expect(dropdownAlt.offset).toEqual(0);
      expect(dropdownAlt.enableReflow).toEqual(false);
      expect(dropdownAlt.enableFade).toEqual(false);
      expect(dropdownAlt.shown).toEqual(false);
    });
  });

  describe('with different options set using HTML attributes', () => {
    let dropdownAlt;
    let dropdownEl;

    beforeEach(() => {
      Util.tearDownComponentList(Dropdown.getInstances());

      dropdownEl = document.querySelector('#dd02');
      dropdownEl.dataset.placement = 'bottom';
      dropdownEl.parentElement.setAttribute('class', 'dropright');

      dropdownAlt = new Dropdown({
        el: dropdownEl
      });
    });

    afterEach(() => {
      // reset properties for next tests
      dropdownEl.dataset.placement = 'top';
      dropdownEl.parentElement.setAttribute('class', 'dropleft');
    });

    it('should be initialized', () => {
      expect(dropdownAlt.el.id).toEqual('dd02');
      expect(dropdownAlt.menu.id).toEqual('ddmenu02');
      expect(dropdownAlt.placement).toEqual('right');
      expect(dropdownAlt.alignment).toEqual('end');
      expect(dropdownAlt.offset).toEqual(0);
      expect(dropdownAlt.enableReflow).toEqual(false);
      expect(dropdownAlt.enableFade).toEqual(false);
      expect(dropdownAlt.shown).toEqual(false);
    });
  });

  describe('with bad options set using HTML attributes', () => {
    let dropdownBad;

    beforeEach(() => {
      Util.tearDownComponentList(Dropdown.getInstances());

      dropdownBad = new Dropdown({
        el: document.querySelector('#dd03')
      });
    });

    it('should be initialized', () => {
      expect(dropdownBad.el.id).toEqual('dd03');
      expect(dropdownBad.menu.id).toEqual('ddmenu03');
      expect(dropdownBad.placement).toEqual('right');
      expect(dropdownBad.alignment).toEqual('end');
      expect(dropdownBad.offset).toEqual(0);
      expect(dropdownBad.enableReflow).toEqual(false);
      expect(dropdownBad.enableFade).toEqual(false);
      expect(dropdownBad.shown).toEqual(false);
    });
  });

  describe('without a list', () => {
    let dropdownNotList;

    beforeEach(() => {
      Util.tearDownComponentList(Dropdown.getInstances());

      dropdownNotList = new Dropdown({
        el: document.querySelector('#dd04')
      });
    });

    it('should be initialized', () => {
      expect(typeof dropdownNotList.arrowableItems).toEqual('undefined');
      expect(dropdownNotList.el.id).toEqual('dd04');
      expect(dropdownNotList.menu.id).toEqual('ddmenu04');
      expect(dropdownNotList.placement).toEqual('bottom');
      expect(dropdownNotList.alignment).toEqual('start');
      expect(dropdownNotList.offset).toEqual(0);
      expect(dropdownNotList.enableReflow).toEqual(true);
      expect(dropdownNotList.enableFade).toEqual(false);
      expect(dropdownNotList.shown).toEqual(false);
    });

    it('should not try to update `arrowableItems` if not initially defined', () => {
      dropdownNotList.update();

      expect(typeof dropdownNotList.arrowableItems).toEqual('undefined');
    });
  });

  describe('without a wrapping drop class or data-placement attribute', () => {
    let dropdownAltSelector;
    let dropdownAlt;

    beforeEach(() => {
      Util.tearDownComponentList(Dropdown.getInstances());

      dropdownAltSelector = document.querySelector('#dd02');
      dropdownAltSelector.parentElement.setAttribute('class', '');
      dropdownAltSelector.removeAttribute('data-placement');

      dropdownAlt = new Dropdown({
        el: dropdownAltSelector
      });
    });

    afterEach(() => {
      // reset properties for next tests
      dropdownAltSelector.parentElement.classList.add(dropdownAltClass);
      dropdownAltSelector.dataset.placement = dropdownAltPlacement;
    });

    it('should be initialized', () => {
      expect(dropdownAlt.el.id).toEqual('dd02');
      expect(dropdownAlt.parent.classList.contains('dropdown')).toEqual(true);
      expect(dropdownAlt.menu.id).toEqual('ddmenu02');
      expect(dropdownAlt.placement).toEqual('bottom');
      expect(dropdownAlt.alignment).toEqual('end');
      expect(dropdownAlt.offset).toEqual(0);
      expect(dropdownAlt.enableReflow).toEqual(false);
      expect(dropdownAlt.enableFade).toEqual(false);
      expect(dropdownAlt.shown).toEqual(false);
    });
  });

  describe('with a data-placement attribute but no wrapping drop class', () => {
    let dropdownAltSelector;
    let dropdownAlt;

    beforeEach(() => {
      Util.tearDownComponentList(Dropdown.getInstances());

      dropdownAltSelector = document.querySelector('#dd02');
      dropdownAltSelector.parentElement.setAttribute('class', '');

      dropdownAlt = new Dropdown({
        el: dropdownAltSelector
      });
    });

    afterEach(() => {
      // reset properties for next tests
      dropdownAltSelector.parentElement.classList.add(dropdownAltClass);
    });

    it('should be initialized', () => {
      expect(dropdownAlt.el.id).toEqual('dd02');
      expect(dropdownAlt.parent.classList.contains('dropup')).toEqual(true);
      expect(dropdownAlt.menu.id).toEqual('ddmenu02');
      expect(dropdownAlt.placement).toEqual('top');
      expect(dropdownAlt.alignment).toEqual('end');
      expect(dropdownAlt.offset).toEqual(0);
      expect(dropdownAlt.enableReflow).toEqual(false);
      expect(dropdownAlt.enableFade).toEqual(false);
      expect(dropdownAlt.shown).toEqual(false);
    });
  });

  describe('with a conflicting placement option passed', () => {
    let dropdownAlt;

    beforeEach(() => {
      Util.tearDownComponentList(Dropdown.getInstances());

      dropdownAlt = new Dropdown({
        el: document.querySelector('#dd02'),
        placement: 'top'
      });
    });

    it('should be initialized', () => {
      expect(dropdownAlt.el.id).toEqual('dd02');
      expect(dropdownAlt.parent.classList.contains('dropup')).toEqual(true);
      expect(dropdownAlt.menu.id).toEqual('ddmenu02');
      expect(dropdownAlt.placement).toEqual('top');
      expect(dropdownAlt.alignment).toEqual('end');
      expect(dropdownAlt.offset).toEqual(0);
      expect(dropdownAlt.enableReflow).toEqual(false);
      expect(dropdownAlt.enableFade).toEqual(false);
      expect(dropdownAlt.shown).toEqual(false);
    });
  });

  describe('when the menu is hidden', () => {
    let eventValue;

    beforeAll(() => {
      dropdownDefault.el.addEventListener('onHide', () => {
        eventValue = 'hidden';
      });
    });

    beforeEach(() => {
      dropdownDefault.hide();
    });

    it('should hide the menu', () => {
      expect(dropdownDefault.shown).toEqual(false);
      expect(dropdownDefault.el.classList.contains('active')).toEqual(false);
      expect(dropdownDefault.menu.classList.contains('show')).toEqual(false);
      expect(dropdownDefault.el.getAttribute('aria-expanded')).toEqual('false');
    });

    it('should open the menu when the trigger is clicked', () => {
      dropdownDefault.el.click();
      expect(dropdownDefault.shown).toEqual(true);
      expect(dropdownDefault.el.classList.contains('active')).toEqual(true);
      expect(dropdownDefault.menu.classList.contains('show')).toEqual(true);
    });

    it('should open the menu when the enter key is pressed on the trigger', () => {
      dropdownDefault.el.dispatchEvent(enterKeyPressed);
      expect(dropdownDefault.shown).toEqual(true);
      expect(dropdownDefault.el.classList.contains('active')).toEqual(true);
      expect(dropdownDefault.menu.classList.contains('show')).toEqual(true);
    });

    it('should open the menu when the space bar is pressed on the trigger', () => {
      dropdownDefault.el.dispatchEvent(spaceBarPressed);
      expect(dropdownDefault.shown).toEqual(true);
      expect(dropdownDefault.el.classList.contains('active')).toEqual(true);
      expect(dropdownDefault.menu.classList.contains('show')).toEqual(true);
    });

    it('should do nothing when the esc key is pressed on the trigger', () => {
      dropdownDefault.el.dispatchEvent(escKeyPressed);
      expect(dropdownDefault.shown).toEqual(false);
      expect(dropdownDefault.el.classList.contains('active')).toEqual(false);
      expect(dropdownDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should do nothing when clicking outside the menu', () => {
      document.activeElement.blur(); // ensure JSDom behavior isn't interfering with the test by neutralizing focus first
      document.dispatchEvent(mouseDownEvent);
      expect(dropdownDefault.shown).toEqual(false);
      expect(dropdownDefault.el.classList.contains('active')).toEqual(false);
      expect(dropdownDefault.menu.classList.contains('show')).toEqual(false);
      expect(dropdownDefault.el.getAttribute('aria-expanded')).toEqual('false');
      expect(document.activeElement).not.toEqual(dropdownDefault.el);
    });

    it('should trigger the `onHide` custom event', () => {
      expect(eventValue).toEqual('hidden');
    });
  });

  describe('when the menu is shown', () => {
    let eventValue;

    beforeAll(() => {
      dropdownDefault.el.addEventListener('onShow', () => {
        eventValue = 'shown';
      });
    });

    beforeEach(() => {
      dropdownDefault.show();
    });

    it('should show the menu', () => {
      expect(dropdownDefault.shown).toEqual(true);
      expect(dropdownDefault.el.classList.contains('active')).toEqual(true);
      expect(dropdownDefault.menu.classList.contains('show')).toEqual(true);
      expect(dropdownDefault.el.getAttribute('aria-expanded')).toEqual('true');
    });

    it('should close the menu when the trigger is clicked', () => {
      dropdownDefault.el.click();
      expect(dropdownDefault.shown).toEqual(false);
      expect(dropdownDefault.el.classList.contains('active')).toEqual(false);
      expect(dropdownDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should close the menu when the enter key is pressed on the trigger', () => {
      dropdownDefault.el.dispatchEvent(enterKeyPressed);
      expect(dropdownDefault.shown).toEqual(false);
      expect(dropdownDefault.el.classList.contains('active')).toEqual(false);
      expect(dropdownDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should close the menu when the space bar is pressed on the trigger', () => {
      dropdownDefault.el.dispatchEvent(spaceBarPressed);
      expect(dropdownDefault.shown).toEqual(false);
      expect(dropdownDefault.el.classList.contains('active')).toEqual(false);
      expect(dropdownDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should close the menu when the esc key is pressed on the trigger', () => {
      dropdownDefault.el.dispatchEvent(escKeyPressed);
      expect(dropdownDefault.shown).toEqual(false);
      expect(dropdownDefault.el.classList.contains('active')).toEqual(false);
      expect(dropdownDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should close the menu when the esc key is pressed on the menu', () => {
      dropdownDefault.menu.dispatchEvent(escKeyPressed);
      expect(dropdownDefault.shown).toEqual(false);
      expect(dropdownDefault.el.classList.contains('active')).toEqual(false);
      expect(dropdownDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should close the menu when clicking outside the menu', () => {
      document.activeElement.blur(); // ensure JSDom behavior isn't interfering with the test by neutralizing focus first
      document.dispatchEvent(mouseDownEvent);
      expect(dropdownDefault.shown).toEqual(false);
      expect(dropdownDefault.el.classList.contains('active')).toEqual(false);
      expect(dropdownDefault.menu.classList.contains('show')).toEqual(false);
      expect(dropdownDefault.el.getAttribute('aria-expanded')).toEqual('false');
      expect(document.activeElement).not.toEqual(dropdownDefault.el);
    });

    it('should close the menu when tabbing outside the menu', () => {
      document.dispatchEvent(focusInEvent);
      expect(dropdownDefault.shown).toEqual(false);
      expect(dropdownDefault.el.classList.contains('active')).toEqual(false);
      expect(dropdownDefault.menu.classList.contains('show')).toEqual(false);
      expect(dropdownDefault.el.getAttribute('aria-expanded')).toEqual('false');
      expect(document.activeElement).toEqual(dropdownDefault.el);
    });

    it('should close the menu when the esc key is pressed', () => {
      dropdownDefault.menu.dispatchEvent(escKeyPressed);
      expect(dropdownDefault.shown).toEqual(false);
      expect(dropdownDefault.el.classList.contains('active')).toEqual(false);
      expect(dropdownDefault.menu.classList.contains('show')).toEqual(false);
      expect(dropdownDefault.el.getAttribute('aria-expanded')).toEqual('false');
      expect(document.activeElement).toEqual(dropdownDefault.el);
    });

    it('should focus on the first item in the menu when the down arrow is pressed on the button', () => {
      dropdownDefault.el.dispatchEvent(downArrowPressed);
      expect(dropdownDefault.shown).toEqual(true);
      expect(dropdownDefault.el.classList.contains('active')).toEqual(true);
      expect(dropdownDefault.menu.classList.contains('show')).toEqual(true);
      expect(dropdownDefault.el.getAttribute('aria-expanded')).toEqual('true');
      expect(document.activeElement.id === 'dd01_item01').toEqual(true);
    });

    it('should trigger the `onShow` custom event', () => {
      expect(eventValue).toEqual('shown');
    });

    describe('when the first menu item has focus', () => {
      let menuItems;

      beforeAll(() => {
        menuItems = Array.from(dropdownDefault.menu.querySelectorAll('a'));
      });

      beforeEach(() => {
        dropdownDefault.show();
        document.activeElement.blur();
        menuItems[0].focus();
      });

      it('should focus on the next item in the menu when the down arrow is pressed', () => {
        menuItems[0].dispatchEvent(downArrowPressed);
        expect(document.activeElement === menuItems[1]).toEqual(true);
      });

      it('should close the menu when the up arrow is pressed', () => {
        menuItems[0].dispatchEvent(upArrowPressed);
        expect(dropdownDefault.shown).toEqual(false);
        expect(dropdownDefault.el.classList.contains('active')).toEqual(false);
        expect(dropdownDefault.menu.classList.contains('show')).toEqual(false);
        expect(dropdownDefault.el.getAttribute('aria-expanded')).toEqual('false');
        expect(document.activeElement).toEqual(dropdownDefault.el);
      });
    });

    describe('when the last menu item has focus', () => {
      let menuItems;
      let lastMenuItem;
      let prevMenuItem;

      beforeAll(() => {
        menuItems = Array.from(dropdownDefault.menu.querySelectorAll('a'));
        lastMenuItem = menuItems[menuItems.length - 1];
        prevMenuItem = menuItems[menuItems.length - 2];
      });

      beforeEach(() => {
        dropdownDefault.show();
        document.activeElement.blur();
        lastMenuItem.focus();
      });

      it('should close the menu when the down arrow is pressed', () => {
        lastMenuItem.dispatchEvent(downArrowPressed);
        expect(dropdownDefault.shown).toEqual(false);
        expect(dropdownDefault.el.classList.contains('active')).toEqual(false);
        expect(dropdownDefault.menu.classList.contains('show')).toEqual(false);
        expect(dropdownDefault.el.getAttribute('aria-expanded')).toEqual('false');
        expect(document.activeElement).toEqual(dropdownDefault.el);
      });

      it('should focus on the next item in the menu when the up arrow is pressed', () => {
        lastMenuItem.dispatchEvent(upArrowPressed);
        expect(document.activeElement === prevMenuItem).toEqual(true);
      });
    });
  });

  describe('when the instance is updated', () => {
    let eventValue;

    beforeAll(() => {
      dropdownDefault.el.addEventListener('onUpdate', () => {
        eventValue = 'updated';
      });
    });

    it('should update the placement property with a valid enum', () => {
      dropdownDefault.update({ placement: 'left' });
      expect(dropdownDefault.placement).toEqual('left');
      expect(dropdownDefault.parent.classList.contains('dropleft')).toEqual(true);
      expect(dropdownDefault.parent.classList.contains('dropdown')).toEqual(false);

      dropdownDefault.update({ placement: 'hi' });
      expect(dropdownDefault.placement).toEqual('bottom');
      expect(dropdownDefault.parent.classList.contains('dropleft')).toEqual(false);
      expect(dropdownDefault.parent.classList.contains('dropdown')).toEqual(true);
    });

    it('should trigger the `onUpdate` custom event', () => {
      dropdownDefault.update();
      expect(eventValue).toEqual('updated');
    });
  });

  describe('when the instance is removed', () => {
    let eventValue;

    beforeAll(() => {
      dropdownDefault.el.addEventListener('onRemove', () => {
        eventValue = 'removed';
      });
    });

    beforeEach(() => {
      dropdownDefault.remove();
    });

    it('should be removed from the list of instances', () => {
      const instances = Dropdown.getInstances();
      expect(instances.indexOf(dropdownDefault)).toEqual(-1);
    });

    it('should trigger the `onRemove` custom event', () => {
      expect(eventValue).toEqual('removed');
    });
  });

  describe('hide with preventDefault', () => {
    it('should cancel hide if default prevented', () => {
      dropdownDefault.el.dispatchEvent = jest.fn();
      dropdownDefault.show();
      dropdownDefault.el.dispatchEvent = jest.fn(e => e.preventDefault());
      dropdownDefault.hide();

      expect(dropdownDefault.el.dispatchEvent).toBeCalled();
      expect(dropdownDefault.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_HIDE);
      expect(dropdownDefault.el.dispatchEvent.mock.calls[0][0].defaultPrevented).toBe(true);
      expect(dropdownDefault.el.getAttribute('aria-expanded')).toEqual('true');
      expect(dropdownDefault.shown).toBe(true);
    });
  });

  describe('show with preventDefault', () => {
    it('should cancel show if default prevented', () => {
      dropdownDefault.el.dispatchEvent = jest.fn();
      dropdownDefault.hide();
      dropdownDefault.el.dispatchEvent = jest.fn(e => e.preventDefault());
      dropdownDefault.show();

      expect(dropdownDefault.el.dispatchEvent).toBeCalled();
      expect(dropdownDefault.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_SHOW);
      expect(dropdownDefault.el.dispatchEvent.mock.calls[0][0].defaultPrevented).toBe(true);
      expect(dropdownDefault.el.getAttribute('aria-expanded')).toEqual('false');
      expect(dropdownDefault.shown).toBe(false);
    });
  });
});
