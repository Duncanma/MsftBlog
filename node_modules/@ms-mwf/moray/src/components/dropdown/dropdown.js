import Util from '../../js/util';
import Flyout from '../flyout/flyout';
import * as FlyoutConfig from '../flyout/flyout';

export const Selector = {
  DATA_MOUNT: '[data-mount="dropdown"]',
  MENU: '.dropdown-menu'
};

export const EventName = {
  ON_HIDE: 'onHide',
  ON_SHOW: 'onShow',
  ON_UPDATE: 'onUpdate',
  ON_REMOVE: 'onRemove'
};

export const ClassName = {
  SHOW: 'show',
  ACTIVE: 'active',
  BOTTOM: 'dropdown',
  TOP: 'dropup',
  RIGHT: 'dropright',
  LEFT: 'dropleft',
  MENU_RIGHT: 'dropdown-menu-right',
  MENU_LEFT: 'dropdown-menu-left'
};

export const Default = {
  ...FlyoutConfig.Default,
  PLACEMENT: 'bottom'
};

const dropdowns = [];

/**
 * The event handler for when the target element is clicked.
 * @param {MouseEvent} event - The event object.
 */
function _elOnClick(event) {
  // Prevent page from trying to scroll to a page anchor.
  event.preventDefault();
  this.toggle();
}

/**
 * The event handler for when a key is pressed on the target element.
 * @param {KeyboardEvent} event - The event object.
 */
function _elOnKeydown(event) {
  // Override keyboard functionality if element is an anchor.
  if (event.keyCode === Util.keyCodes.SPACE || event.keyCode === Util.keyCodes.ENTER) {
    // Trigger the same event as a click for consistency.
    event.preventDefault();
    _elOnClick.bind(this)(event);
  }

  // Events for when the menu is open.
  if (this.shown) {
    // Menu should close with the Esc key.
    if (event.keyCode === Util.keyCodes.ESC) {
      this.hide();
    }

    if (this.arrowableItems && event.keyCode === Util.keyCodes.ARROW_DOWN) {
      // Prevent scrolling page on down arrow.
      event.preventDefault();
      // Set focus to first focusable element in menu.
      this.arrowableItems[0].focus();
    }
  }
}

/**
 * The event handler for when a key is pressed on the menu
 * @param {KeyboardEvent} event - The event object
 */
function _menuOnKeydown(event) {
  if (event.keyCode === Util.keyCodes.ESC) {
    this.hide();
  }

  if (this.arrowableItems && (event.keyCode === Util.keyCodes.ARROW_DOWN || event.keyCode === Util.keyCodes.ARROW_UP)) {
    // Prevent scrolling page on down arrow.
    event.preventDefault();

    if (
      event.keyCode === Util.keyCodes.ARROW_DOWN &&
      document.activeElement !== this.arrowableItems[this.arrowableItems.length - 1]
    ) {
      // If the down key is pressed and its NOT on the last item in the list
      this.arrowableItems[this.arrowableItems.indexOf(document.activeElement) + 1].focus();
    } else if (event.keyCode === Util.keyCodes.ARROW_UP && document.activeElement !== this.arrowableItems[0]) {
      // If the up key is pressed and its NOT on the first item in the list
      this.arrowableItems[this.arrowableItems.indexOf(document.activeElement) - 1].focus();
    } else {
      this.hide();
    }
  }
}

/**
 * The event handler for when mousedown is triggered on the document.
 * Happens before mouseup, click, and focusin to control closing of the menu without conflicting with other events.
 * @param {Event} event - The event object
 */
function _documentOnMousedown(event) {
  if (this.shown && !this.menu.contains(event.target) && !this.el.contains(event.target)) {
    this.hide({ setFocus: false });
  }
}

/**
 * The event handler for when the document receives focus
 * @param {Event} event - The event object
 */
function _documentOnFocusin(event) {
  if (this.shown && !this.menu.contains(event.target)) {
    this.hide();
  }
}

/**
 * Get the placement of a dropdown from the parent node class
 * @param {Node} node - The element to check for a placement class
 * @returns {string} The placement of the dropdown
 */
function _getPlacementFromClass(node) {
  for (let i = 0; i < node.classList.length; i++) {
    switch (node.classList[i]) {
      case ClassName.BOTTOM:
        return 'bottom';
      case ClassName.TOP:
        return 'top';
      case ClassName.LEFT:
        return 'start';
      case ClassName.RIGHT:
        return 'end';
      default:
        break;
    }
  }
}

/**
 * Apply the correct `drop{direction}` class according to the placement
 * @param {Node} node - The element to apply the class to
 * @returns {string} The placement enum of the dropdown
 */
function _updatePlacementClass(node, placement) {
  const className = ClassName[placement.toUpperCase()];
  node.classList.remove(ClassName.BOTTOM, ClassName.TOP, ClassName.RIGHT, ClassName.LEFT);
  node.classList.add(className);
}

class Dropdown extends Flyout {
  /**
   * Create a dropdown, inherited from flyout
   * @param {Object} opts - The flyout options
   * @param {Node} opts.el - The element that toggles the flyout
   * @param {Node} [opts.menu] - The element that defines the flyout menu
   * @param {string} [opts.placement=bottom] - A string that defines the placement of the menu
   * @param {string} [opts.alignment=start] - A string that defines the alignment of the menu
   * @param {number} [opts.offset=0] - The number of pixels the menu should be offset from the trigger
   * @param {boolean} [opts.enableReflow=true] - Whether the menu should reflow to fit within the window as best as possible
   */
  constructor(opts) {
    // Set super options
    const flyoutOpts = { ...opts };
    const parent = flyoutOpts.el.offsetParent || flyoutOpts.el.parentElement;
    const placementFromClass = _getPlacementFromClass(parent);

    flyoutOpts.placement =
      opts.placement || placementFromClass || flyoutOpts.el.getAttribute('data-placement') || Default.PLACEMENT;
    flyoutOpts.enableFade = false;

    super(flyoutOpts);

    // Dropdown-specific setup

    // Ensure `drop` class matches the placement of the menu
    // Invert
    const invertedPlacement = FlyoutConfig._getPlacement(this.placement, Default.PLACEMENT);
    _updatePlacementClass(this.parent, invertedPlacement);

    if (this.menu.nodeName.toLowerCase() === 'ul' || this.menu.nodeName.toLowerCase() === 'ol') {
      this.arrowableItems = Util.getTabbableElements(this.menu);
    }

    // Add event handlers.
    this.events = [
      { el: this.el, type: 'click', handler: _elOnClick.bind(this) },
      { el: this.el, type: 'keydown', handler: _elOnKeydown.bind(this) },
      { el: this.menu, type: 'keydown', handler: _menuOnKeydown.bind(this) },
      { el: document, type: 'mousedown', handler: _documentOnMousedown.bind(this) },
      { el: document, type: 'focusin', handler: _documentOnFocusin.bind(this) }
    ];
    Util.addEvents(this.events);

    // Add mutation observers.
    this.menuObserver = new MutationObserver(this.update.bind(this));
    this.menuObserver.observe(this.menu, { childList: true, subtree: true });

    // Create custom events.
    this[EventName.ON_HIDE] = new CustomEvent(EventName.ON_HIDE, { bubbles: true, cancelable: true });
    this[EventName.ON_SHOW] = new CustomEvent(EventName.ON_SHOW, { bubbles: true, cancelable: true });

    dropdowns.push(this);
  }

  /**
   * Show the menu
   */
  show() {
    super.show();
    this.el.setAttribute('aria-expanded', this.shown);

    this.el.dispatchEvent(this[EventName.ON_SHOW]);
  }

  /**
   * Hide the menu
   * @param {string} [opts={}] - Options for hiding the menu
   * @param {boolean} [opts.setFocus=true] - Whether or not the focus should be set on the toggling element; defaults to true
   */
  hide(opts = {}) {
    super.hide(opts);
    this.el.setAttribute('aria-expanded', this.shown);

    this.el.dispatchEvent(this[EventName.ON_HIDE]);
  }

  /**
   * Update the dropdown instance
   * @param {string} [opts={}] - Options for updating the instance
   */
  update(opts = {}) {
    const flyoutOpts = { ...opts };
    flyoutOpts.enableFade = false; // disable flyout fade feature

    if (typeof this.arrowableItems !== 'undefined') {
      // Update the list of known focusable items within the menu.
      this.arrowableItems = Util.getTabbableElements(this.menu);
    }

    if (opts.placement) {
      flyoutOpts.placement = FlyoutConfig._getPlacement(opts.placement, Default.PLACEMENT);
    }

    super.update(flyoutOpts);

    // Invert dropleft/dropright classes that switch orientation in RTL
    const invertedPlacement = FlyoutConfig._getPlacement(this.placement, Default.PLACEMENT);
    _updatePlacementClass(this.parent, invertedPlacement);

    // Create and dispatch custom event
    this[EventName.ON_UPDATE] = new CustomEvent(EventName.ON_UPDATE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_UPDATE]);
  }

  /**
   * Remove the dropdown instance
   */
  remove() {
    // Remove event handlers, observers, etc.
    Util.removeEvents(this.events);

    // Remove this reference from the array of instances
    const index = dropdowns.indexOf(this);
    dropdowns.splice(index, 1);

    // Create and dispatch custom event
    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_REMOVE]);
  }

  /**
   * Get an array of dropdown instances
   * @returns {Object[]} Array of dropdown instances
   */
  static getInstances() {
    return dropdowns;
  }
}

export default Dropdown;
