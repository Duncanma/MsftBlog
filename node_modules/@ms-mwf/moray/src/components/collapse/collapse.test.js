import Collapse, { ClassName, EventName } from './collapse';

jest.useFakeTimers();

describe(Collapse.name, () => {
  const triggerId = 'collapseTrigger';
  const targetId = 'collapseTarget';
  const html = `
    <button class="btn btn-collapse" id="${triggerId}" data-mount="collapse" data-target="#${targetId}" aria-expanded="false" aria-controls="collapseExample">Collapse Trigger</button>
    <div class="collapse" id="${targetId}" aria-labelledby="${triggerId}">Text</div>
  `;
  let trigger;
  let target;

  beforeEach(() => {
    document.body.innerHTML = html;
    trigger = document.querySelector(`#${triggerId}`);
    target = document.querySelector(`#${targetId}`);

    // clear all Collapse instances
    while (Collapse.getInstances().length) {
      Collapse.getInstances()[0].remove();
    }
  });

  describe('constructor', () => {
    beforeEach(() => {
      target.classList.remove(ClassName.SHOW); // simulate hidden
    });

    it('should set "aria-expanded" and "collapse" class if collapsed', () => {
      new Collapse({ el: trigger });

      expect(trigger.classList.contains(ClassName.COLLAPSED)).toBe(true);
      expect(trigger.getAttribute('aria-expanded')).toBe('false');
    });

    it('should set "aria-expanded" and "collapse" class if expanded', () => {
      target.classList.add(ClassName.SHOW); // simulate shown
      new Collapse({ el: trigger });
      jest.runAllTimers(); // complete transitions

      expect(trigger.classList.contains(ClassName.COLLAPSED)).toBe(false);
      expect(trigger.getAttribute('aria-expanded')).toBe('true');
    });

    it('should toggle on init if option is provided', () => {
      new Collapse({ el: trigger, toggle: true });
      jest.runAllTimers(); // complete transitions

      // test `toggle()` output to avoid mocking constructor
      expect(target.classList.contains(ClassName.SHOW)).toBe(true);
    });

    it('should NOT toggle on init if option is not provided', () => {
      new Collapse({ el: trigger });
      jest.runAllTimers(); // complete transitions

      // test `toggle()` output to avoid mocking constructor
      expect(target.classList.contains(ClassName.SHOW)).toBe(false);
    });

    it('should add a click event handler to the trigger element', () => {
      const instance = new Collapse({ el: trigger });
      instance.toggle = jest.fn();
      trigger.click();

      expect(instance.toggle).toBeCalled();
    });
  });

  describe('toggle()', () => {
    let instance;

    beforeEach(() => {
      instance = new Collapse({ el: trigger });
      instance.show = jest.fn();
      instance.hide = jest.fn();
    });

    it('should call show() if hidden', () => {
      target.classList.remove(ClassName.SHOW); // simulate hidden
      instance.toggle();

      expect(instance.show).toBeCalled();
      expect(instance.hide).not.toBeCalled();
    });

    it('should call hide() if shown', () => {
      target.classList.add(ClassName.SHOW); // simulate shown
      instance.toggle();

      expect(instance.hide).toBeCalled();
      expect(instance.show).not.toBeCalled();
    });
  });

  describe('show()', () => {
    let instance;

    beforeEach(() => {
      instance = new Collapse({ el: trigger });
    });

    it('should initially add "collapsing" class and remove "collapse"', () => {
      instance.show();

      expect(instance.el.classList.contains(ClassName.COLLAPSING)).toBe(true);
      expect(instance.el.classList.contains(ClassName.COLLAPSE)).toBe(false);
    });

    it('should reset styles and classes when transitions end', () => {
      instance.show();
      jest.runAllTimers(); // complete transitions

      expect(instance.el.classList.contains(ClassName.COLLAPSING)).toBe(false);
      expect(instance.el.classList.contains(ClassName.SHOW, ClassName.COLLAPSE)).toBe(true);
    });

    it('should set width style if `width` class is present', () => {
      target.classList.add('width');
      instance.show();

      // dimension size can't be calculated in jest
      expect(instance.el.style.width).toBeTruthy();
      expect(instance.el.style.height).toBeFalsy();
    });

    it('should set height style if `width` class is NOT present', () => {
      instance.show();

      // dimension size can't be calculated in jest
      expect(instance.el.style.height).toBeTruthy();
      expect(instance.el.style.width).toBeFalsy();
    });

    it('should dispatch a "show" event if not transitioning or shown', () => {
      instance.el.dispatchEvent = jest.fn();
      instance.show();

      expect(instance.el.dispatchEvent).toBeCalled();
      expect(instance.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.SHOW);
    });

    it('should NOT dispatch a "show" event if transitioning', () => {
      instance.isTransitioning = true;
      instance.el.dispatchEvent = jest.fn();
      instance.show();

      expect(instance.el.dispatchEvent).not.toBeCalled();
    });

    it('should NOT dispatch a "show" event if target element is shown', () => {
      target.classList.add(ClassName.SHOW); // simulate shown
      instance.el.dispatchEvent = jest.fn();
      instance.show();

      expect(instance.el.dispatchEvent).not.toBeCalled();
    });

    it('should cancel show if default is prevented', () => {
      instance.el.dispatchEvent = jest.fn(e => e.preventDefault());
      instance.show();

      expect(instance.el.dispatchEvent).toBeCalled();
      expect(instance.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.SHOW);
      expect(instance.el.dispatchEvent.mock.calls[0][0].defaultPrevented).toBe(true);
      expect(instance.el.classList.contains(ClassName.COLLAPSING)).toBe(false);
      expect(instance.el.classList.contains(ClassName.COLLAPSE)).toBe(true);
    });
  });

  describe('hide()', () => {
    let instance;

    beforeEach(() => {
      instance = new Collapse({ el: trigger });
      target.classList.add(ClassName.SHOW); // simulate shown
    });

    it('should initially add "collapsing" class and remove "collapse" and "show"', () => {
      instance.hide();

      expect(instance.el.classList.contains(ClassName.COLLAPSING)).toBe(true);
      expect(instance.el.classList.contains(ClassName.COLLAPSE, ClassName.SHOW)).toBe(false);
    });

    it('should reset styles and classes when transitions end', () => {
      instance.hide();
      jest.runAllTimers(); // complete transitions

      expect(instance.el.classList.contains(ClassName.COLLAPSING)).toBe(false);
      expect(instance.el.classList.contains(ClassName.COLLAPSE)).toBe(true);
    });

    it('should dispatch a "hide" event if not transitioning or hidden', () => {
      instance.el.dispatchEvent = jest.fn();
      instance.hide();

      expect(instance.el.dispatchEvent).toBeCalled();
      expect(instance.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.HIDE);
    });

    it('should NOT dispatch a "hide" event if transitioning', () => {
      instance.isTransitioning = true;
      instance.el.dispatchEvent = jest.fn();
      instance.hide();

      expect(instance.el.dispatchEvent).not.toBeCalled();
    });

    it('should NOT dispatch a "hide" event if hidden', () => {
      target.classList.remove(ClassName.SHOW); // simulate hidden
      instance.el.dispatchEvent = jest.fn();
      instance.hide();

      expect(instance.el.dispatchEvent).not.toBeCalled();
    });

    it('should cancel hide if default is prevented', () => {
      instance.el.dispatchEvent = jest.fn(e => e.preventDefault());
      instance.hide();

      expect(instance.el.dispatchEvent).toBeCalled();
      expect(instance.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.HIDE);
      expect(instance.el.dispatchEvent.mock.calls[0][0].defaultPrevented).toBe(true);
      expect(instance.el.classList.contains(ClassName.COLLAPSING)).toBe(false);
      expect(instance.el.classList.contains(ClassName.COLLAPSE, ClassName.SHOW)).toBe(true);
    });
  });

  describe('getInstances()', () => {
    it('should return 1 Collapse instance when called once', () => {
      new Collapse({ el: trigger });

      expect(Collapse.getInstances()).toHaveLength(1);
    });

    it('should return 2 Collapse instances when called twice', () => {
      // for simulation – do not target the same element IRL
      new Collapse({ el: trigger });
      new Collapse({ el: trigger });

      expect(Collapse.getInstances()).toHaveLength(2);
    });
  });

  describe('update()', () => {
    let instance;

    beforeEach(() => {
      instance = new Collapse({ el: trigger });
    });

    it('should update instance without creating a new one', () => {
      instance.update();

      expect(Collapse.getInstances()).toHaveLength(1);
      expect(Collapse.getInstances()).toContain(instance);
    });

    it('should dispatch an "onUpdate" event when called', () => {
      instance.el.dispatchEvent = jest.fn();

      instance.update();

      expect(instance.el.dispatchEvent).toBeCalled();
      expect(instance.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_UPDATE);
    });
  });

  describe('remove()', () => {
    it('should remove one Collapse when called', () => {
      // for simulation – do not target the same element IRL
      new Collapse({ el: trigger });
      new Collapse({ el: trigger });
      new Collapse({ el: trigger });

      const instance2 = Collapse.getInstances()[1];
      instance2.remove();

      expect(Collapse.getInstances()).toHaveLength(2);
      // ensure the proper instance was deleted
      expect(Collapse.getInstances()).not.toContain(instance2);
    });

    it('should dispatch an "onRemove" event when called', () => {
      const instance = new Collapse({ el: trigger });

      instance.el.dispatchEvent = jest.fn();
      instance.remove();

      expect(instance.el.dispatchEvent).toBeCalled();
      expect(instance.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_REMOVE);
    });
  });
});
