import Util from '../../js/util';

const instances = [];

export const EventName = {
  SHOW: 'onShow',
  SHOWN: 'onShown',
  HIDE: 'onHide',
  HIDDEN: 'onHidden',
  ON_REMOVE: 'onRemove',
  ON_UPDATE: 'onUpdate'
};

export const ClassName = {
  SHOW: 'show',
  COLLAPSE: 'collapse',
  COLLAPSING: 'collapsing',
  COLLAPSED: 'collapsed'
};

const Dimension = {
  WIDTH: 'width',
  HEIGHT: 'height'
};

export const Selector = {
  ACTIVES: '.show, .collapsing',
  DATA_MOUNT: '[data-mount="collapse"]'
};

function _getDimension() {
  const hasWidth = this.el.classList.contains(Dimension.WIDTH);
  return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
}

function _addAriaAndCollapsedClass(element, triggerArray) {
  const isOpen = element.classList.contains(ClassName.SHOW);

  if (triggerArray.length) {
    triggerArray.forEach(triggerItem => {
      triggerItem.classList.toggle(ClassName.COLLAPSED, !isOpen);
      triggerItem.setAttribute('aria-expanded', isOpen);
    });
  }
}

class Collapse {
  /**
   * Create the Collapse
   * @param {Object} opts - the Collapse options
   * @param {Node} opts.el - the Collapse trigger element
   * @param {boolean} [opts.toggle] - whether to toggle the Collapse on initialization
   * @param {Node} [opts.parent] - the parent (accordion) element for group management
   * @param {boolean} [opts.addEventListener] - suppress event listeners on Collapse trigger (when false)
   */
  constructor(opts) {
    this.isTransitioning = false;
    this.isCollapsed = true;
    this.triggerElement = opts.el;
    if (this.triggerElement.getAttribute('aria-expanded').toString() === 'true') {
      this.isCollapsed = false;
    }

    // Get the affected selectors
    const element = Util.getSelectorFromElement(this.triggerElement);
    this.el = document.querySelector(element);
    this.toggleOnInit = opts.toggle ? opts.toggle : false;
    this.toggleArray = [].slice.call(
      document.querySelectorAll(
        `${Selector.DATA_MOUNT}[href="#${this.el.id}"],${Selector.DATA_MOUNT}[data-target="#${this.el.id}"]`
      )
    );

    // Create custom events.
    this[EventName.SHOWN] = new CustomEvent(EventName.SHOWN);
    this[EventName.HIDDEN] = new CustomEvent(EventName.HIDDEN);

    const toggleList = [].slice.call(document.querySelectorAll(Selector.DATA_MOUNT));
    toggleList.forEach(elem => {
      const selector = Util.getSelectorFromElement(elem);
      const filterElement = [].slice
        .call(document.querySelectorAll(selector))
        .filter(foundElem => foundElem === opts.el);

      if (selector !== null && filterElement.length > 0) {
        this._selector = selector;
        this.toggleArray.push(elem);
      }
    });

    this.parent = this.el.getAttribute('data-parent');

    if (!opts.parent) {
      _addAriaAndCollapsedClass.bind(this)(this.el, this.toggleArray);
    }

    if (this.toggleOnInit) {
      this.toggle();
    }

    // Add event handlers
    if (opts.addEventListener !== false) {
      this.events = [
        {
          el: opts.el,
          type: 'click',
          handler: event => {
            // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
            if (event.currentTarget.tagName === 'A') {
              event.preventDefault();
            }

            this.toggle();
          }
        }
      ];

      Util.addEvents(this.events);
    }

    instances.push(this);
  }

  /**
   * Toggles the collapse from show to hide and vice versa
   */
  toggle() {
    if (this.el.classList.contains(ClassName.SHOW)) {
      this.hide();
    } else {
      this.show();
    }
  }

  /**
   * Shows the collapse
   */
  show() {
    if (this.isTransitioning || this.el.classList.contains(ClassName.SHOW)) {
      return;
    }

    this[EventName.SHOW] = new CustomEvent(EventName.SHOW, { cancelable: true });
    this.el.dispatchEvent(this[EventName.SHOW]);
    if (this[EventName.SHOW].defaultPrevented) {
      return;
    }

    const dimension = _getDimension.bind(this)();

    this.el.classList.remove(ClassName.COLLAPSE);
    this.el.classList.add(ClassName.COLLAPSING);

    this.el.style[dimension] = 0;

    if (this.toggleArray.length) {
      this.toggleArray.forEach(elem => {
        elem.classList.remove(ClassName.COLLAPSED);
        elem.setAttribute('aria-expanded', true);
      });
    }

    this.isTransitioning = true;

    // If we have a parent (group management), hide the other elements when other is shown
    if (this.parent) {
      const collapseInstances = Collapse.getInstances();
      collapseInstances.forEach(collapse => {
        if (collapse !== this && collapse.parent === this.parent && !collapse.isCollapsed) {
          // Hide the collapse
          collapse.toggle();
        }
      });
    }

    const complete = () => {
      this.el.classList.remove(ClassName.COLLAPSING);
      this.el.classList.add(ClassName.COLLAPSE);
      this.el.classList.add(ClassName.SHOW);

      this.el.style[dimension] = '';

      this.isTransitioning = false;
      this.isCollapsed = false;
      this.el.dispatchEvent(this[EventName.SHOWN]);
    };

    const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
    const scrollSize = `scroll${capitalizedDimension}`;
    const transitionDuration = Util.getTransitionDurationFromElement(this.el);

    this.el.addEventListener(Util.TRANSITION_END, complete.bind(this), { once: true });
    Util.emulateTransitionEnd(this.el, transitionDuration);

    this.el.style[dimension] = `${this.el[scrollSize]}px`;
  }

  /**
   * Hides the collapse
   */
  hide() {
    if (this.isTransitioning || !this.el.classList.contains(ClassName.SHOW)) {
      return;
    }

    this[EventName.HIDE] = new CustomEvent(EventName.HIDE, { cancelable: true });
    this.el.dispatchEvent(this[EventName.HIDE]);
    if (this[EventName.HIDE].defaultPrevented) {
      return;
    }

    const dimension = _getDimension.bind(this)();

    this.el.style[dimension] = `${this.el.getBoundingClientRect()[dimension]}px`;

    Util.reflow(this.el);

    this.el.classList.add(ClassName.COLLAPSING);
    this.el.classList.remove(ClassName.COLLAPSE);
    this.el.classList.remove(ClassName.SHOW);

    this.toggleArray.forEach(toggle => {
      const toggleSelector = Util.getSelectorFromElement(toggle);

      if (toggleSelector !== null) {
        const toggleArray = [].slice.call(document.querySelectorAll(toggleSelector));
        toggleArray.forEach(el => {
          if (!el.classList.contains(ClassName.SHOW)) {
            toggle.classList.add(ClassName.COLLAPSED);
            toggle.setAttribute('aria-expanded', false);
          }
        });
      }
    });

    this.isTransitioning = true;

    const complete = () => {
      this.isTransitioning = false;
      this.el.classList.remove(ClassName.COLLAPSING);
      this.el.classList.add(ClassName.COLLAPSE);
      this.isCollapsed = true;
      this.el.dispatchEvent(this[EventName.HIDDEN]);
    };

    this.el.style[dimension] = '';
    const transitionDuration = Util.getTransitionDurationFromElement(this.el);

    this.el.addEventListener(Util.TRANSITION_END, complete.bind(this), { once: true });
    Util.emulateTransitionEnd(this.el, transitionDuration);
  }

  /**
   * Update instance
   */
  update() {
    // TODO: Add ability to pass in an event handler function as an option to override the default behavior.
    this[EventName.ON_UPDATE] = new CustomEvent(EventName.ON_UPDATE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_UPDATE]);
  }

  /**
   * Remove the event listener and the instance
   */
  remove() {
    Util.removeEvents(this.events);

    // remove this collapse reference from array of instances
    const index = instances.indexOf(this);
    instances.splice(index, 1);

    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_REMOVE]);
  }

  /**
   * Get instances.
   * @returns {Object[]} An array of instances
   */
  static getInstances() {
    return instances;
  }
}

export default Collapse;
