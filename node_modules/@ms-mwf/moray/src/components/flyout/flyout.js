import Util from '../../js/util';

const biDirectional = Util.isBiDirectional();

export const ClassName = {
  SHOW: 'show',
  FADE: 'fade',
  FADING_OUT: 'fading-out',
  ACTIVE: 'active',
  FLYOUT: 'flyout'
};

export const Default = {
  START: (biDirectional) ? 'right' : 'left',
  END: (biDirectional) ? 'left' : 'right',
  ALIGNMENT: 'start'
};

export const DefaultReflow = {
  left: ['left', 'bottom', 'top', 'right'],
  right: ['right', 'bottom', 'top', 'left'],
  top: ['top', 'right', 'bottom', 'left'],
  bottom: ['bottom', 'right', 'top', 'left']
};

/**
 * Private functions
 */

function _hasReflow(node) {
  if (node.hasAttribute('data-disable-reflow') && node.getAttribute('data-disable-reflow') !== 'false') {
    return false;
  }

  return true;
}

/**
 * Get the placement of a flyout.
 * @param {string} string - The string to parse.
 * @param {string} [defaultValue=start] - The default value to fallback to.
 * @returns {string} The placement of the flyout.
 */
export function _getPlacement(str, defaultValue = Default.END) {
  switch (str) {
    case 'top':
    case 'bottom':
      return str;
    case 'left':
    case 'start':
      return Default.START;
    case 'right':
    case 'end':
      return Default.END;
    default:
      return defaultValue;
  }
}

/**
 * Get the alignment of a flyout.
 * @param {string} str - The string to parse.
 * @param {string} [defaultValue=start] - The default value to fallback to.
 * @returns {string} The alignment enum of the flyout.
 */
export function _getAlignment(str, defaultValue = Default.ALIGNMENT) {
  switch (str) {
    case 'center':
    case 'start':
    case 'end':
      return str;
    default:
      return defaultValue;
  }
}

/**
 * Get the related menu for an element.
 * @param {Node} node - The element to find a related menu for, typically the flyout instance target.
 * @returns {Node} The menu element.
 */
function _getRelatedMenu(node) {
  if (node.attributes['aria-controls']) {
    return document.querySelector(`#${node.attributes['aria-controls'].value}`);
  }
}

/**
* Get the X distance for menu positioning.
* @param {string} textAlignment - The text alignment of the flyout's parent. Affects the left/right CSS positioning, therefore changes the translate coordinates.
* @param {string} placement - Menu's placement in relation to the flyout trigger: 'left', 'right', 'top', or 'bottom'.
* @param {string} alignment - Menu's alignment with the flyout trigger, correlates to read order: 'center', 'start', 'end'.
* @param {object} boundingRect - An object containing the getBoundingClientRect() objects for the trigger and the menu.
* @returns {number} The X distance to translate the menu.
*/
function _getTranslateX(textAlignment, placement, alignment) {
  let translateX = 0;
  let overflowOffset = 0;

  /* eslint-disable no-lonely-if */
  // If text is aligned left
  if (textAlignment === 'left') {
    if (placement === 'right') {
      // Place menu right of trigger
      translateX += this.boundingRect.el.width + this.offset;
    } else if (placement === 'left') {
      // Place menu left of trigger
      translateX -= this.boundingRect.menu.width + this.offset;
    } else {
      // Adjust alignment for top and bottom menus

      if (alignment === 'center') {
        translateX -= (this.boundingRect.menu.width - this.boundingRect.el.width) / 2;
      } else if (alignment === 'end' && !biDirectional || alignment === 'start' && biDirectional) {
        translateX -= this.boundingRect.menu.width - this.boundingRect.el.width;
        // Shift menu left if needed to fit menu in tiny window sizes, record offset for future use
        overflowOffset = _shiftLeftToFitWindow.call(this, translateX);
        translateX += overflowOffset;
      } else {
        // Shift menu right if needed to fit menu in tiny window sizes, record offset for future use
        overflowOffset = _shiftRightToFitWindow.call(this, translateX);
        translateX += overflowOffset;
      }
    }
  // If text is aligned right
  } else {
    if (placement === 'right') {
      translateX += this.boundingRect.menu.width + this.offset;
    } else if (placement === 'left') {
      translateX -= this.boundingRect.el.width + this.offset;
    } else {
      if (alignment === 'center') {
        translateX += (this.boundingRect.menu.width - this.boundingRect.el.width) / 2;
      } else if (alignment === 'start' && !biDirectional || alignment === 'end' && biDirectional) {
        translateX += this.boundingRect.menu.width - this.boundingRect.el.width;
        // Shift menu right if needed to fit menu in tiny window sizes, record offset for future use
        overflowOffset = _shiftRightToFitWindow.call(this, translateX);
        translateX += overflowOffset;
      } else {
        // Shift menu left if needed to fit menu in tiny window sizes, record offset for future use
        overflowOffset = _shiftLeftToFitWindow.call(this, translateX);
        translateX += overflowOffset;
      }
    }
  }
  /* eslint-enable no-lonely-if */

  // Save any overflowOffset (rounded) to the instance for later use
  this.overflowOffset = Math.round(overflowOffset);

  return translateX;
}

/**
* Returns distance in pixels needed to prevent overflow on the right side of the window.
* @returns {number} The distance in pixels to shift the menu left.
*/
function _shiftLeftToFitWindow() {
  const xOverflow = (this.boundingRect.window.width - (this.boundingRect.el.x + this.boundingRect.el.width)) + this.boundingRect.menu.width;

  return (xOverflow > this.boundingRect.window.width) ? xOverflow - this.boundingRect.window.width : 0;
}

/**
* Returns distance in pixels needed to prevent overflow on the left side of the window.
* @returns {number} The distance in pixels to shift the menu right.
*/
function _shiftRightToFitWindow() {
  const xOverflow = this.boundingRect.el.x + this.boundingRect.menu.width;

  return (xOverflow > this.boundingRect.window.width) ? -(xOverflow - this.boundingRect.window.width) : 0;
}

/**
 * Get the Y distance for menu positioning.
 * @param {string} placement - Menu's placement in relation to the flyout trigger: 'left', 'right', 'top', or 'bottom'.
 * @param {string} alignment - Menu's alignment with the flyout trigger, correlates to read order: 'center', 'start', 'end'.
 * @param {object} boundingRect - An object containing the getBoundingClientRect() objects for the trigger and the menu.
 * @returns {number} The Y distance to translate the menu.
 */
function _getTranslateY(placement, alignment) {
  let translateY = 0;

  // Place menu above trigger
  if (placement === 'top') {
    translateY -= this.boundingRect.menu.height + this.offset;
  // Place menu below trigger
  } else if (placement === 'bottom') {
    translateY += this.boundingRect.el.height + this.offset;
  } else {
    // Adjust alignment for left and right menus
    /* eslint-disable no-lonely-if */
    if (alignment === 'center') {
      translateY -= (this.boundingRect.menu.height - this.boundingRect.el.height) / 2;
    } else if (alignment === 'end') {
      translateY -= this.boundingRect.menu.height - this.boundingRect.el.height;
    }
    /* eslint-enable no-lonely-if */
  }

  return translateY;
}

class Flyout {
  /**
   * Create a flyout
   * @param {Object} opts - The flyout options
   * @param {Node} opts.el - The element that toggles the flyout
   * @param {Node} [opts.menu] - The element that defines the flyout menu
   * @param {string} [opts.placement=right] - A string that defines the placement of the menu
   * @param {string} [opts.alignment=start] - A string that defines the alignment of the menu
   * @param {number} [opts.offset=0] - The number of pixels the menu should be offset from the trigger
   * @param {boolean} [opts.enableReflow=true] - Whether the menu should reflow to fit within the window as best as possible
   * @param {boolean} [opts.enableFade=true] - Whether the menu should fade in and out
   */
  constructor(opts) {
    this.el = opts.el; // the toggle
    this.menu = opts.menu || _getRelatedMenu(this.el); // the flyout menu
    this.parent = this.el.offsetParent || this.el.parentElement;
    this.placement = _getPlacement(opts.placement || this.el.getAttribute('data-placement'));
    this.alignment = _getAlignment(opts.alignment || this.el.getAttribute('data-alignment'));
    this.offset = (opts.offset) ? parseInt(opts.offset, 10) : 0;
    this.translateX = 0;
    this.translateY = 0;
    this.overflowOffset = 0;
    this.enableReflow = (typeof opts.enableReflow === 'boolean') ? opts.enableReflow : _hasReflow(this.el);
    this.enableFade = (typeof opts.enableFade === 'boolean') ? opts.enableFade : this.menu.classList.contains(ClassName.FADE);
    this.shown = false;

    // Ensure position is set on parent element, needed for absolute positioning of menu
    const parentPositionProperty = window.getComputedStyle(this.parent).position;
    if (parentPositionProperty !== 'relative' && parentPositionProperty !== 'absolute') {
      this.parent.style.position = 'relative';
    }

    // Setup fade animation based on options supplied
    if (opts.enableFade === true) {
      this.menu.classList.add(ClassName.FADE);
    } else if (opts.enableFade === false) {
      this.menu.classList.remove(ClassName.FADE);
    }
  }

  /**
   * Get the current position of the menu based on enableReflow setting
   * @returns {object} The instance's position object
   */
  get currentPosition() {
    const position = { placement: this.placement, alignment: this.alignment };

    if (this.enableReflow) {
      return this.reflowPosition || position; // fallback to original position, if undefined
    }

    return position;
  }

  /**
   * Calculates and sets the reflow position value (placement and alignment)
   */
  calcReflowPosition() {
    // Calculate the distance of the trigger from each side of the window
    const distFrom = {
      top: this.boundingRect.el.top,
      bottom: window.innerHeight - this.boundingRect.el.bottom,
      left: this.boundingRect.el.left,
      right: document.body.clientWidth - this.boundingRect.el.right
    };
    // Add the menu offset spacing to the width and height of the menu
    const menuWidth = this.boundingRect.menu.width + this.offset;
    const menuHeight = this.boundingRect.menu.height + this.offset;
    const placements = DefaultReflow[this.placement].slice();
    // Calculate the distance needed for the menu to fit inside the window
    let distX = menuWidth - this.boundingRect.el.width;
    let distY = menuHeight - this.boundingRect.el.height;

    if (this.alignment === 'center') {
      distX /= 2;
      distY /= 2;
    }

    // Copy values so we don't override original instance property
    let { placement, alignment } = this;

    // Eliminate the placements that won't fit
    if (distFrom.left < menuWidth) {
      placements.splice(placements.indexOf('left'), 1);
    }

    if (distFrom.right < menuWidth) {
      placements.splice(placements.indexOf('right'), 1);
    }

    if (distFrom.top < menuHeight) {
      placements.splice(placements.indexOf('top'), 1);
    }

    if (distFrom.bottom < menuHeight) {
      placements.splice(placements.indexOf('bottom'), 1);
    }

    placement = (placements.length) ? placements.shift() : 'bottom'; // fallback placement is always bottom

    // Adjust the alignment of the chosen placement
    // NOTE: Keep this logic as is for readability and sanity
    if (placement === 'bottom' || placement === 'top') {
      // If neither side is ideal
      if (distFrom.left < distX && distFrom.right < distX) {
        // Align to the Read order
        alignment = 'start';
      // LTR: If distFrom.left < distX
      } else if (distFrom[Default.START] < distX) {
        alignment = 'start';
      } else if (distFrom[Default.END] <= distX) {
        alignment = 'end';
      }
    } else {
      // If placement is 'left' or 'right'
      // If neither above nor below is ideal
      /* eslint-disable no-lonely-if */
      if (distFrom.top < distY && distFrom.bottom < distY) {
        // Force the beginning of the menu content to be in view,
        // which should force window to grow, enabling user to scroll to view entire menu
        alignment = 'start';
      } else if (distFrom.top < distY) {
        alignment = 'start';
      } else if (distFrom.bottom <= distY) {
        alignment = 'end';
      }
      /* eslint-enable no-lonely-if */
    }

    this.reflowPosition = { placement, alignment };
  }

  /**
   * Position the flyout menu
   */
  positionMenu() {
    if (this.enableReflow) {
      this.calcReflowPosition();
    }

    const position = this.currentPosition;

    // TODO - make this more robust to check box alignment (Grid/Flex) as well as inline alignment (text-align)
    // Get the direction of text flow (affected by cascade of text-align css property and/or RTL)
    const textAlignProperty = window.getComputedStyle(this.parent).textAlign;
    let textAlignment = Default.START;
    if (textAlignProperty === 'left' || textAlignProperty === 'right') {
      textAlignment = textAlignProperty;
    } else if (textAlignProperty === 'end') {
      textAlignment = Default.END;
    }

    // Set the transformation's "origin" based on text alignment
    this.menu.style.top = Math.round(this.boundingRect.el.top - this.boundingRect.parent.top) + 'px';
    if (textAlignment === 'left') {
      this.menu.style.left = Math.round(this.boundingRect.el.left - this.boundingRect.parent.left) + 'px';
      this.menu.style.right = 'auto';
    } else {
      this.menu.style.left = 'auto';
      this.menu.style.right = -(Math.round(this.boundingRect.el.right - this.boundingRect.parent.right)) + 'px';
    }

    // Allow the menu to define its own width according to the needed width of its contents
    this.menu.style.minWidth = Math.round(this.boundingRect.menu.width) + 'px';

    // Calculate the x and y distances needed to push the menu to the correct position.
    this.translateX = Math.round(_getTranslateX.call(this, textAlignment, position.placement, position.alignment));
    this.translateY = Math.round(_getTranslateY.call(this, position.placement, position.alignment));

    // Set the transform style
    this.menu.style.transform = `translate(${this.translateX}px, ${this.translateY}px)`;

    // Reset menu classes associated with position
    this.menu.classList.remove(
      `${ClassName.FLYOUT}-left`,
      `${ClassName.FLYOUT}-right`,
      `${ClassName.FLYOUT}-top`,
      `${ClassName.FLYOUT}-bottom`,
      `${ClassName.FLYOUT}-align-start`,
      `${ClassName.FLYOUT}-align-end`,
      `${ClassName.FLYOUT}-align-center`
    );
    // Set the menu classes associated with position
    this.menu.classList.add(`${ClassName.FLYOUT}-${position.placement}`, `${ClassName.FLYOUT}-align-${position.alignment}`);
  }

  /**
   * Show the menu
   */
  show() {
    // Record window width prior to showing the menu,
    // otherwise the menu will effect the window width
    const windowWidth = window.innerWidth;

    this.shown = true;
    this.el.classList.add(ClassName.ACTIVE);
    this.menu.classList.add(ClassName.SHOW);

    // Store the coordinates of the associated elements for ease of reuse now that the menu has layout
    this.boundingRect = {
      el: this.el.getBoundingClientRect(),
      menu: this.menu.getBoundingClientRect(),
      parent: this.parent.getBoundingClientRect(),
      window: { width: windowWidth }
    };

    this.positionMenu();
  }

  /**
   * Hide the menu
   * @param {string} [opts={}] - Options for hiding the menu
   * @param {boolean} [opts.setFocus=true] - Whether or not the focus should be set on the toggling element; defaults to true
   */
  hide(opts = {}) {
    // Default behavior should be to set focus on toggling element
    const setFocus = (typeof opts.setFocus === 'boolean') ? opts.setFocus : true;

    this.shown = false;
    this.el.classList.remove(ClassName.ACTIVE);
    this.menu.classList.remove(ClassName.SHOW);

    // 1. Add a class that triggers a CSS animation
    // 2. Create an event listener that removes the class once it's animation is complete
    if (this.enableFade) {
      this.menu.addEventListener('animationend', () => {
        this.menu.classList.remove(ClassName.FADING_OUT);
      }, { once: true }); // 2.
      this.menu.classList.add(ClassName.FADING_OUT); // 1.
    }

    if (setFocus) {
      // Set focus on the toggle
      this.el.focus();
    }
  }

  /**
   * Toggle the menu state
   */
  toggle() {
    if (this.shown) {
      this.hide();
    } else {
      this.show();
    }
  }

  /**
   * Update the flyout instance
   * @param {string} [opts={}] - Options for updating the flyout instance
   */
  update(opts = {}) {
    // Change the placement of the menu
    if (opts.placement) {
      this.placement = _getPlacement(opts.placement);
    }

    // Change the alignment of the menu
    if (opts.alignment) {
      this.alignment = _getAlignment(opts.alignment);
    }

    // Change the offset of the menu
    if (typeof opts.offset !== 'undefined') {
      const offset = parseInt(opts.offset, 10);
      if (!isNaN(offset)) {
        this.offset = offset;
      }
    }

    // Change whether the menu should reflow
    if (typeof opts.enableReflow === 'boolean') {
      this.enableReflow = opts.enableReflow;
    }

    // Change whether the menu should enable a fade animation
    if (typeof opts.enableFade === 'boolean' && opts.enableFade !== this.enableFade) {
      this.enableFade = opts.enableFade;
      this.menu.classList.toggle(ClassName.FADE);
    }

    // Update the menu position if its open
    if (this.shown) {
      this.positionMenu();
    }
  }
}

export default Flyout;
