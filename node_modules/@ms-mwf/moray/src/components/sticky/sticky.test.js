import Sticky, { ClassName, EventName } from './sticky';
import Util from '../../js/util';
import 'intersection-observer';

const id = 'sticky01';
const showStuckHeight = 100;
const showStuckHtml = `<div class="sticky-show-stuck" style="height: ${showStuckHeight}px"></div>`;
// Mock values of the sticky's boundingClientRect at the threshold of 'static' for each direction
const boundingClientRectStatic = {
  top: { bottom: 0, height: 0, left: 0, right: 0, top: 0, width: 0, x: 0, y: 0 },
  bottom: { bottom: window.innerHeight, height: 0, left: 0, right: 0, top: window.innerHeight, width: 0, x: 0, y: window.innerHeight }
};
// Mock values of the sticky's boundingClientRect at the threshold of 'stuck' for each direction
const boundingClientRectStuck = {
  top: { bottom: -1, height: 0, left: 0, right: 0, top: -1, width: 0, x: 0, y: -1 },
  bottom: { bottom: (window.innerHeight + 1), height: 0, left: 0, right: 0, top: (window.innerHeight + 1), width: 0, x: 0, y: (window.innerHeight + 1) }
};

// Set up our document body
document.body.innerHTML = `<div id="${id}"></div>`;

const el = document.getElementById(id);

describe('Sticky', () => {
  let sticky;

  afterEach(() => {
    // Remove the instance for garbage collection
    if (sticky) {
      sticky.remove();
    }
  });

  describe('static getInstances()', () => {
    beforeAll(() => {
      const opts = { el };

      sticky = new Sticky(opts);
    });

    it('should return an array of all sticky instances', () => {
      const instances = Sticky.getInstances();
      expect(instances.length).toEqual(1);
    });
  });

  describe('constructor()', () => {
    beforeAll(() => {
      const opts = { el };

      sticky = new Sticky(opts);
    });

    it('should create the sticky and sentinel elements', () => {
      expect(sticky.el.id).toEqual(id);
      expect(sticky.el.classList.contains('sticky')).toEqual(true);
    });

    it('should create an observer', () => {
      expect(sticky.observer).toBeDefined();
      expect(sticky.observer).toBeInstanceOf(IntersectionObserver);
    });

    describe('calculating offset for smooth transitions', () => {
      beforeAll(() => {
        const opts = {
          el,
          enableSmoothTransition: true
        };

        // Add two .sticky-show-stuck elements inside the sticky element
        el.innerHTML = showStuckHtml + showStuckHtml;
        // Mock the Util function that returns the height of the .sticky-show-stuck elements
        Util.getElementOuterHeight = jest.fn();
        Util.getElementOuterHeight.mockReturnValue(showStuckHeight);

        sticky = new Sticky(opts);
      });

      afterAll(() => {
        // Remove the .sticky-show-stuck elements
        el.innerHTML = '';
        // Clear mock information and any mock return values
        Util.getElementOuterHeight.mockReset();
      });

      it('should calculate an offset for each .sticky-show-stuck element', () => {
        expect(sticky.rootMarginOffset).toEqual(showStuckHeight * 2);
      });

      it('should reflect the total offset in the observer\'s rootMargin', () => {
        expect(sticky.observer.rootMargin).toEqual(`-${showStuckHeight * 2}px 0px 0px 0px`);
      });
    });

    describe('with no options set', () => {
      beforeAll(() => {
        const opts = { el };

        sticky = new Sticky(opts);
      });

      it('should set direction to top', () => {
        expect(sticky.direction).toEqual('top');
      });

      it('should apply top styles', () => {
        expect(el.style.top).toBe('0px');
        expect(el.style.bottom).toBe('');
      });

      it('should set enableSmoothTransition to false', () => {
        expect(sticky.enableSmoothTransition).toEqual(false);
      });

      it('should set enableObserver to true', () => {
        expect(sticky.enableObserver).toEqual(true);
      });

      it('should set extraScrollPaddingPx to default value', () => {
        expect(sticky.extraScrollPaddingPx).toEqual(12);
      });
    });

    describe('with options set', () => {
      beforeAll(() => {
        const opts = {
          el,
          direction: 'bottom',
          enableSmoothTransition: true,
          enableObserver: false,
          extraScrollPaddingPx: 8
        };

        sticky = new Sticky(opts);
      });

      it('should set direction to bottom', () => {
        expect(sticky.direction).toEqual('bottom');
      });

      it('should apply bottom styles', () => {
        expect(el.style.bottom).toBe('0px');
        expect(el.style.top).toBe('');
      });

      it('should set enableSmoothTransition to true', () => {
        expect(sticky.enableSmoothTransition).toEqual(true);
      });

      it('should set enableObserver to false', () => {
        expect(sticky.enableObserver).toEqual(false);
      });

      it('should set extraScrollPaddingPx to 8', () => {
        expect(sticky.extraScrollPaddingPx).toEqual(8);
      });
    });

    describe('with invalid options set', () => {
      beforeAll(() => {
        const opts = {
          el,
          direction: 'sideways',
          enableSmoothTransition: 10,
          enableObserver: 'true',
          extraScrollPaddingPx: false
        };

        sticky = new Sticky(opts);
      });

      it('should set direction to top', () => {
        expect(sticky.direction).toEqual('top');
      });

      it('should apply top styles', () => {
        expect(el.style.top).toBe('0px');
        expect(el.style.bottom).toBe('');
      });

      it('should set enableSmoothTransition to true', () => {
        expect(sticky.enableSmoothTransition).toEqual(false);
      });

      it('should set enableObserver to false', () => {
        expect(sticky.enableObserver).toEqual(true);
      });

      it('should set extraScrollPaddingPx to default value', () => {
        expect(sticky.extraScrollPaddingPx).toEqual(12);
      });
    });

    describe('with options set as HTML attributes', () => {
      beforeAll(() => {
        const opts = { el };
        el.dataset.direction = 'bottom';
        el.dataset.smoothTransition = '';

        sticky = new Sticky(opts);
      });

      afterAll(() => {
        el.removeAttribute('data-direction');
        el.removeAttribute('data-smooth-transition');
      });

      it('should set direction to bottom', () => {
        expect(sticky.direction).toEqual('bottom');
      });

      it('should apply bottom styles', () => {
        expect(el.style.bottom).toBe('0px');
        expect(el.style.top).toBe('');
      });

      it('should set enableSmoothTransition to true', () => {
        expect(sticky.enableSmoothTransition).toEqual(true);
      });
    });
  });

  describe('doesSentinelExceedBoundary()', () => {
    beforeAll(() => {
      const opts = { el };

      sticky = new Sticky(opts);
    });

    afterAll(() => {
      // No longer mock this, restore original function
      sticky.sentinel.getBoundingClientRect.mockRestore();
    });

    it('should return true when the sticky is on top and the sentinel is above the viewport', () => {
      sticky.direction = 'top';
      sticky.sentinel.getBoundingClientRect = jest.fn(() => {
        return boundingClientRectStuck.top;
      });

      expect(sticky.doesSentinelExceedBoundary()).toEqual(true);
    });

    it('should return true when the sticky is on bottom and the sentinel is below the viewport', () => {
      sticky.direction = 'bottom';
      sticky.sentinel.getBoundingClientRect = jest.fn(() => {
        return boundingClientRectStuck.bottom;
      });

      expect(sticky.doesSentinelExceedBoundary()).toEqual(true);
    });

    it('should return false when the sticky is on top and the sentinel is within the viewport', () => {
      sticky.direction = 'top';
      sticky.sentinel.getBoundingClientRect = jest.fn(() => {
        return boundingClientRectStatic.top;
      });

      expect(sticky.doesSentinelExceedBoundary()).toEqual(false);
    });

    it('should return false when the sticky is on bottom and the sentinel is within the viewport', () => {
      sticky.direction = 'bottom';
      sticky.sentinel.getBoundingClientRect = jest.fn(() => {
        return boundingClientRectStatic.bottom;
      });

      expect(sticky.doesSentinelExceedBoundary()).toEqual(false);
    });

    it('should return false when the sticky is on top and the sentinel is below the viewport', () => {
      sticky.direction = 'top';
      sticky.sentinel.getBoundingClientRect = jest.fn(() => {
        return boundingClientRectStatic.bottom;
      });

      expect(sticky.doesSentinelExceedBoundary()).toEqual(false);
    });

    it('should return false when the sticky is on bottom and the sentinel is above the viewport', () => {
      sticky.direction = 'bottom';
      sticky.sentinel.getBoundingClientRect = jest.fn(() => {
        return boundingClientRectStatic.top;
      });

      expect(sticky.doesSentinelExceedBoundary()).toEqual(false);
    });
  });

  describe('setObserverStatus()', () => {
    beforeAll(() => {
      const opts = { el };

      sticky = new Sticky(opts);
    });

    beforeEach(() => {
      sticky.doesSentinelExceedBoundary = jest.fn();
    });

    afterEach(() => {
      // No longer mock this, restore original function
      sticky.doesSentinelExceedBoundary.mockRestore();
    });

    it('should enable the sticky', () => {
      sticky.enableObserver = false;
      sticky.doesSentinelExceedBoundary.mockReturnValue(true);

      sticky.setObserverStatus(true);
      expect(sticky.enableObserver).toEqual(true);
      expect(sticky.el.classList.contains(ClassName.STUCK)).toEqual(true);
    });

    it('should disable the sticky', () => {
      sticky.enableObserver = true;
      sticky.doesSentinelExceedBoundary.mockReturnValue(true);

      sticky.setObserverStatus(false);
      expect(sticky.enableObserver).toEqual(false);
      expect(sticky.el.classList.contains(ClassName.STUCK)).toEqual(false);
    });
  });

  describe('remove()', () => {
    beforeAll(() => {
      const opts = { el };

      sticky = new Sticky(opts);
    });

    beforeEach(() => {
      sticky.el.dispatchEvent = jest.fn();
      sticky.remove();
    });

    it('should remove sticky from the list of instances', () => {
      const instances = Sticky.getInstances();
      expect(instances.indexOf(sticky)).toEqual(-1);
    });

    it('should trigger the `onRemove` custom event', () => {
      expect(sticky.el.dispatchEvent).toBeCalled();
      expect(sticky.el.dispatchEvent.mock.calls[0][0].type).toBe(EventName.ON_REMOVE);
    });
  });

  describe('update()', () => {
    beforeEach(() => {
      sticky = new Sticky({ el });
    });
    describe('no change with no options', () => {
      beforeEach(() => {
        const opts = {};

        sticky.update(opts);
      });

      it('should leave unchanged the sticky and the sentinel element', () => {
        expect(sticky.el.id).toEqual(id);
        expect(sticky.el.classList.contains('sticky')).toEqual(true);
        expect(document.querySelectorAll('.sticky-sentinel').length).toEqual(1);
      });

      it('should leave unchanged the observer', () => {
        expect(sticky.observer).toBeDefined();
        expect(sticky.observer).toBeInstanceOf(IntersectionObserver);
      });
    });

    describe('calculating offset for smooth transitions', () => {
      beforeAll(() => {
        // Add two .sticky-show-stuck elements inside the sticky element
        el.innerHTML = showStuckHtml + showStuckHtml;
        // Mock the Util function that returns the height of the .sticky-show-stuck elements
        Util.getElementOuterHeight = jest.fn();
        Util.getElementOuterHeight.mockReturnValue(showStuckHeight);
      });
      beforeEach(() => {
        const opts = {
          enableSmoothTransition: true
        };

        sticky.update(opts);
      });

      afterAll(() => {
        // Remove the .sticky-show-stuck elements
        el.innerHTML = '';
        // Clear mock information and any mock return values
        Util.getElementOuterHeight.mockReset();
      });

      it('should calculate an offset for each .sticky-show-stuck element', () => {
        expect(sticky.rootMarginOffset).toEqual(showStuckHeight * 2);
      });

      it('should reflect the total offset in the observer\'s rootMargin', () => {
        expect(sticky.observer.rootMargin).toEqual(`-${showStuckHeight * 2}px 0px 0px 0px`);
      });
    });

    describe('with options set', () => {
      beforeEach(() => {
        const opts = {
          direction: 'bottom',
          enableSmoothTransition: true,
          extraScrollPaddingPx: 8
        };

        sticky.update(opts);
      });

      it('should set direction to bottom', () => {
        expect(sticky.direction).toEqual('bottom');
      });

      it('should apply bottom styles', () => {
        expect(el.style.bottom).toBe('0px');
        expect(el.style.top).toBe('');
      });

      it('should set enableSmoothTransition to true', () => {
        expect(sticky.enableSmoothTransition).toEqual(true);
      });

      it('should set extraScrollPaddingPx to 8', () => {
        expect(sticky.extraScrollPaddingPx).toEqual(8);
      });
    });

    describe('with invalid options set', () => {
      beforeEach(() => {
        const opts = {
          direction: 'sideways',
          enableSmoothTransition: 10,
          extraScrollPaddingPx: false
        };

        sticky.update(opts);
      });

      it('should set direction to top', () => {
        expect(sticky.direction).toEqual('top');
      });

      it('should apply top styles', () => {
        expect(el.style.top).toBe('0px');
        expect(el.style.bottom).toBe('');
      });

      it('should set enableSmoothTransition to true', () => {
        expect(sticky.enableSmoothTransition).toEqual(false);
      });

      it('should set extraScrollPaddingPx to default value', () => {
        expect(sticky.extraScrollPaddingPx).toEqual(12);
      });
    });

    describe('with options set as HTML attributes', () => {
      beforeEach(() => {
        el.dataset.direction = 'bottom';
        el.dataset.smoothTransition = 'true';

        sticky.update();
      });

      afterEach(() => {
        el.removeAttribute('data-direction');
        el.removeAttribute('data-smooth-transition');
      });

      it('should not set direction to bottom', () => {
        expect(sticky.direction).toEqual('top');
      });

      it('should not apply bottom styles', () => {
        expect(el.style.top).toBe('0px');
        expect(el.style.bottom).toBe('');
      });

      it('should not set enableSmoothTransition to true', () => {
        expect(sticky.enableSmoothTransition).toEqual(false);
      });
    });
  });
});
