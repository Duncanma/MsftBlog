import Util from '../../js/util';
import { throttle, debounce } from 'throttle-debounce';

export const Selector = {
  DATA_MOUNT: '[data-mount="sticky"]',
  SHOW_STUCK: '.sticky-show-stuck',
  HIDE_STUCK: '.sticky-hide-stuck'
};

export const ClassName = {
  STICKY: 'sticky',
  SENTINEL: 'sticky-sentinel',
  STUCK: 'stuck',
  GET_HEIGHT: 'get-height',
  STICKY_TOP: 'sticky-direction-top',
  STICKY_BOTTOM: 'sticky-direction-bottom'
};

export const Direction = {
  TOP: 'top',
  BOTTOM: 'bottom'
};

export const EventName = {
  ON_STUCK: 'onSticky',
  ON_UNSTUCK: 'onStatic',
  ON_UPDATE: 'onUpdate',
  ON_REMOVE: 'onRemove',
  FOCUS_IN: 'focusin',
  RESIZE: 'resize'
};

export const Default = {
  DIRECTION: 'top'
};

const stickies = [];

/**
 * Private functions.
 */

/**
 * Check for the `data-smooth-transition` attribute.
 * Its presence makes this option "true" unless the value is specifically set to "false"
 * @param {Node} node - The element to check for the attribute `data-smooth-transition`
 * @returns {Boolean} return false if contentDivTarget is null
 */
function _hasSmoothTransition(node) {
  if (node.hasAttribute('data-smooth-transition') && node.dataset.smoothTransition !== 'false') {
    return true;
  }

  return false;
}

/**
 * Get the direction of the sticky.
 * @param {string} string - The string to parse.
 * @param {string} [defaultValue=top] - The default value to fallback to.
 * @returns {string} The direction of the sticky.
 */
function _getDirection(str, defaultValue = Default.DIRECTION) {
  switch (str) {
    case 'top':
    case 'bottom':
      return str;
    default:
      return defaultValue;
  }
}

/**
 * Handle intersection observer
 */
function _onStickyChange() {
  this.el.classList.toggle(ClassName.STUCK, this.isStuck);
  _updateContentDivSpacing.bind(this)();
  _updateScrollPadding.bind(this)();
}

/**
 * Update margin spacing on the element before/after the sticky bar so that overlapping
 * does not occur when the page bar is fixed. Remove property if it is not stuck
 */
function _updateContentDivSpacing() {
  if (this.contentDivTarget === null) {
    return;
  }

  let adjustNextElementSpacing = this.stickyElementHeight + this.contentDivTargetSpacing;
  if (this.rootMarginOffset !== 0) {
    adjustNextElementSpacing -= this.rootMarginOffset;
  }

  if (this.isStuck) {
    this.contentDivTarget.style.setProperty(this.styleProp, adjustNextElementSpacing + 'px', 'important');
  } else {
    this.contentDivTarget.style.setProperty(this.styleProp, '');
  }
}

/**
 * Updates scroll padding so that elements scrolled into view don't stay behind
 */
function _updateScrollPadding(removeScrollPadding) {
  const htmlElement = document.querySelector('html');
  this.stickyElementHeight = this.el.getBoundingClientRect().height;
  if (removeScrollPadding) {
    htmlElement.style.scrollPaddingTop = 0;
    htmlElement.style.scrollPaddingBottom = 0;
  }

  if (this.direction === Direction.TOP) {
    if (this.isStuck) {
      htmlElement.style.scrollPaddingTop = (this.stickyElementHeight + this.extraScrollPaddingPx) + 'px';
    } else {
      htmlElement.style.scrollPaddingTop = (this.stickyElementHeight + this.rootMarginOffset + this.extraScrollPaddingPx) + 'px';
    }
  } else if (this.direction === Direction.BOTTOM) {
    if (this.isStuck) {
      htmlElement.style.scrollPaddingBottom = (this.stickyElementHeight + this.extraScrollPaddingPx) + 'px';
    } else {
      htmlElement.style.scrollPaddingBottom = (this.stickyElementHeight + this.rootMarginOffset + this.extraScrollPaddingPx) + 'px';
    }
  }
}

/**
 * Triggers a boundary check when focus changes to handle edge cases where Intersection Observer does not fire
 * Uses focusin because focus does not bubble
 */
function _onFocusin() {
  if (this.enableObserver) {
    this.isStuck = this.doesSentinelExceedBoundary();
    this.el.classList.toggle(ClassName.STUCK, this.isStuck);
    _updateScrollPadding.bind(this)();
  }
}

/**
  @func _stickyExceedsAcceptedHeight
  @desc Calculates and returns whether the height of the sticky has exceeded 33% of the viewport height based on height of the sticky's hidden elements and the height of the sticky's visible elements.
  @returns {boolean} Whether the height of the sticky has exceeded 33% of the viewport height.
  @this Sticky
*/
function _stickyExceedsAcceptedHeight() {
  // Subtracting two additional pixels based on a border that is toggled based on visibility.
  return (this.hiddenElementsHeight + this.visibleElementsHeight - 2) / window.innerHeight > 0.33;
}

/**
  @func _noStickyIfTooTall
  @desc If the height of the sticky has exceeded 33% of the viewport height based on height of the sticky's hidden elements and the height of the sticky's visible elements, makes it not sticky
  @this Sticky
*/
function _noStickyIfTooTall() {
  // Subtracting two additional pixels based on a border that is toggled based on visibility.
  if (this.enableObserverInitial) {
    if (_stickyExceedsAcceptedHeight.call(this)) {
      this.setObserverStatus(false);
    } else {
      this.setObserverStatus(true);
    }
  }
}

/**
  @func _getShowStuckHeight
  @desc Calculates and returns the combined height of all .sticky-show-stuck elements.
  @returns {number} Combined height of all .sticky-show-stuck elements.
  @this Sticky
*/
function _getShowStuckHeight() {
  let hiddenHeight = 0;
  // Calculate the height of hidden elements when not stuck
  const showStuck = this.el.querySelectorAll(Selector.SHOW_STUCK);
  if (showStuck && showStuck instanceof NodeList) {
    // Get the height of all hidden elements
    showStuck.forEach((el, index, list) => {
      hiddenHeight += Util.getElementOuterHeight(el, { cssSelectors: ['margin', 'padding'] });
      // If this is the last item in the node list, remove the CSS hack that displays hidden elements
      if (index === list.length - 1) {
        this.el.classList.remove(ClassName.GET_HEIGHT);
      }
    });
  }

  return hiddenHeight;
}

/**
  @func _calculateHeights
  @desc Calculates and returns the height of hidden and visible elements.
  @returns {Object} Object containing height of hidden and visible elements.
  @this Sticky
*/
function _calculateHeights() {
  this.el.classList.add(ClassName.GET_HEIGHT);
  const hiddenHeight = _getShowStuckHeight.call(this);
  const visibleHeight = this.el.offsetHeight;
  this.el.classList.remove(ClassName.GET_HEIGHT);

  return { hidden: hiddenHeight, visible: visibleHeight };
}

/**
 * @func _setDirectionalProps
 * @desc Sets value of instances members and DOM node properties depending on the direction instance member
 */
function _setDirectionalProps() {
  if (this.direction === Direction.BOTTOM) {
    this.el.style.top = null; // prevent interference
    this.el.style.bottom = '0';
    this.contentDivTarget = this.el.previousElementSibling;
    this.contentDivTargetSpacing = this.contentDivTarget ? parseInt(getComputedStyle(this.contentDivTarget).paddingBottom, 10) + parseInt(getComputedStyle(this.contentDivTarget).marginBottom, 10) : 0;
    this.styleProp = 'margin-bottom';
    this.el.classList.add(ClassName.STICKY_BOTTOM);
    this.el.classList.remove(ClassName.STICKY_TOP);
  } else {
    // Assume direction is Direction.TOP
    this.el.style.bottom = null;
    this.el.style.top = '0';
    this.contentDivTarget = this.el.nextElementSibling;
    this.contentDivTargetSpacing = this.contentDivTarget ? parseInt(getComputedStyle(this.contentDivTarget).paddingTop, 10) + parseInt(getComputedStyle(this.contentDivTarget).marginTop, 10) : 0;
    this.styleProp = 'margin-top';
    this.el.classList.add(ClassName.STICKY_TOP);
    this.el.classList.remove(ClassName.STICKY_BOTTOM);
  }
}

/**
 * @func _createObserver
 * @desc creates a new observer instance member, disconnecting the old one if present. Instance member sentinel must already exist
 */
function _createObserver() {
  if (this.observer) {
    this.observer.disconnect();
  }

  // If smooth transition is enabled, the`rootMarginOffset` value should reflect the combined height
  // of all elements hidden prior to the sticky becoming stuck. Adding this value to the rootMargin option
  // of the intersection observer will allow for the sticky to activate sooner, resulting in a more
  // seamless transition
  const observerOptions = { rootMargin: `-${this.rootMarginOffset}px 0px 0px 0px` };
  const onStickyChange = _onStickyChange.bind(this);
  this.observer = new IntersectionObserver(entries => {
    // fire onStickyChange if not in viewport
    if (this.enableObserver) {
      const prevState = this.isStuck;
      this.isStuck = this.doesSentinelExceedBoundary() && !entries[0].isIntersecting;

      // Check if sticky has changed state from unstuck to stuck and vice versa
      // in order to trigger custom events
      if (typeof prevState !== 'undefined' && prevState !== this.isStuck) {
        if (this.isStuck) {
          // Create and dispatch custom event
          this[EventName.ON_STUCK] = new CustomEvent(EventName.ON_STUCK, { bubbles: true });
          this.el.dispatchEvent(this[EventName.ON_STUCK]);
        } else {
          // Create and dispatch custom event
          this[EventName.ON_UNSTUCK] = new CustomEvent(EventName.ON_UNSTUCK, { bubbles: true });
          this.el.dispatchEvent(this[EventName.ON_UNSTUCK]);
        }
      }

      onStickyChange();
    }
  }, observerOptions);

  if (this.sentinel) {
    this.observer.observe(this.sentinel);
  }
}

/**
 * Helper function to clear key properties of an instance
 */
function _teardownInstance() {
  Util.removeEvents(this.events);

  // remove the attribute from the element
  this.el.classList.remove(ClassName.STICKY);
  _updateScrollPadding.call(this, [true]);
  // remove sticky-sentinel element
  this.sentinel.remove();
  // disconnect observer
  this.observer.disconnect();
}

/**
 * Class representing a Sticky Element.
 */
class Sticky {
  /**
   * Create the Sticky Element
   * @param {Object} opts - The Sticky Element options.
   * @param {Node} opts.el - The Sticky Element DOM node.
   * @param {string} opts.direction - Whether the Sticky element sticks to the top when scrolled below a certain point (TOP) or sticks to the bottom when scrolled above a certain point (BOTTOM). If not defined, will attempt to read `data-direction` atrribute, then defaults TOP
   * @param {boolean} opts.enableSmoothTransition - Whether to enable a smoother transition to hiding/showing elements as the sticky become stuck. If not defined, will attempt to read `data-smooth-transition` attribute, defaults to false
   * @param {boolean} opts.enableObserver - enable the observer on initialization (defaults to true)
   * @param {number} opts.extraScrollPaddingPx - Extra scroll padding to reduce crowding into sticky bars, defaults to 12px, same as minimal gutters
   */
  constructor(opts) {
    this.el = opts.el;
    this.direction = _getDirection(opts.direction || this.el.dataset.direction);
    this.enableSmoothTransition = typeof opts.enableSmoothTransition === 'boolean' ? opts.enableSmoothTransition : _hasSmoothTransition(this.el);
    this.extraScrollPaddingPx = typeof opts.extraScrollPaddingPx === 'number' ? opts.extraScrollPaddingPx : 12;
    this.enableObserver = typeof opts.enableObserver === 'boolean' ? opts.enableObserver : true;
    // Saves the initial value of enable observer status from construction. Is used to flag whether the sticky should be automatically disabled when the height of the sticky exceeds 33% of the viewport
    this.enableObserverInitial = this.enableObserver;

    // Add "sticky" class only while initialized to attach style and functionality provided by CSS
    // Set prior to all height calculations so that styles are applied first
    this.el.classList.add(ClassName.STICKY);

    // HTML element with the property data-mount="sticky"
    // Create a property to hold the value for the sticky element height to be reused in both the _updateContentDivSpacing and _updateScrollPadding function.
    this.stickyElementHeight = 0;

    // Set properties based on the anchor direction
    _setDirectionalProps.call(this);

    // Add event handlers
    this.events = [
      { el: document.body, type: EventName.FOCUS_IN, handler: _onFocusin.bind(this) },
      { el: window, type: EventName.RESIZE, handler: throttle(200, _updateScrollPadding.bind(this)) },
      {
        el: window,
        type: EventName.RESIZE,
        handler: debounce(300, _noStickyIfTooTall.bind(this)),
        options: { passive: true }
      }
    ];

    Util.addEvents(this.events);

    const { hidden: hiddenElementsHeight, visible: visibleElementsHeight } = _calculateHeights.call(this);
    // Adjusts where the sentinel to the intersection observer triggers. Expected to be 0 if smooth transition is disabled.
    this.rootMarginOffset = this.enableSmoothTransition ? hiddenElementsHeight : 0;
    this.hiddenElementsHeight = hiddenElementsHeight;
    this.visibleElementsHeight = visibleElementsHeight;

    this.sentinel = document.createElement('div');
    this.sentinel.classList.add(ClassName.SENTINEL);
    this.el.insertAdjacentElement('beforebegin', this.sentinel);

    _createObserver.call(this);

    if (this.doesSentinelExceedBoundary() && this.enableObserver) {
      this.el.classList.add(ClassName.STUCK);
      _updateScrollPadding.bind(this)();
    }

    _noStickyIfTooTall.call(this);
    stickies.push(this);
  }

  /**
   * Check if the sentinel Exceeds the boundary
   * @returns {boolean} State of sentinel boundary
   */
  doesSentinelExceedBoundary() {
    const sentinelRect = this.sentinel.getBoundingClientRect();
    const sentinelTop = sentinelRect.top - this.rootMarginOffset;
    const sentinelBottom = sentinelRect.bottom;

    if (this.direction === Direction.TOP && sentinelTop < 0) {
      return true;
    }

    if (this.direction === Direction.BOTTOM && sentinelBottom > window.innerHeight) {
      return true;
    }

    return false;
  }

  /**
   * Set the status of the observer (to enable or disable the observer)
   * @param {boolean} status The status to set
   */
  setObserverStatus(status) {
    if (this.doesSentinelExceedBoundary()) {
      _updateScrollPadding.bind(this)();

      if (status) {
        this.el.classList.add(ClassName.STUCK);
      } else {
        this.el.classList.remove(ClassName.STUCK);
      }
    }

    this.enableObserver = status;
  }

  /**
   * Updates key aspects the instance
   * @param {Object} opts - The Sticky options.
   * @param {string} opts.direction - Whether the Sticky element sticks to the top when scrolled below a certain point (TOP) or sticks to the bottom when scrolled above a certain point (BOTTOM). If not defined, will maintain current setting
   * @param {boolean} opts.enableSmoothTransition - Whether to enable a smoother transition to hiding/showing elements as the sticky become stuck. If not defined, will maintain current setting
   * @param {number} opts.extraScrollPaddingPx - Extra scroll padding to reduce crowding into sticky bars. If not define, will maintain current setting
   */
  update(opts = {}) {
    const updateDirection = typeof opts.direction === 'string' ? _getDirection(opts.direction) : this.direction;
    const updateEnableSmoothTransition =
      typeof opts.enableSmoothTransition === 'boolean' ? opts.enableSmoothTransition : this.enableSmoothTransition;
    const updateExtraScrollPaddingPx =
      typeof opts.extraScrollPaddingPx === 'number' ? opts.extraScrollPaddingPx : this.extraScrollPaddingPx;
    const { hidden: updateHiddenElementsHeight, visible: updateVisibleElementsHeight } = _calculateHeights.call(this);

    // update visibleElementsHeight for future calculations
    this.visibleElementsHeight = updateVisibleElementsHeight;

    // Set properties based on the anchor direction if changed
    if (this.direction !== updateDirection) {
      this.direction = updateDirection;

      _setDirectionalProps.call(this);

      // need to update scroll padding if direction changes
      this.extraScrollPaddingPx = updateExtraScrollPaddingPx;
      _updateScrollPadding.call(this, [true]);
    }

    // update scroll padding if extraScrollPaddingPx updated but direction not updated
    if (this.extraScrollPaddingPx !== updateExtraScrollPaddingPx) {
      this.extraScrollPaddingPx = updateExtraScrollPaddingPx;
      _updateScrollPadding.call(this, [true]);
    }

    // update observer if smooth transition has changed, or hiddenElementsHeight has changed
    if (
      this.enableSmoothTransition !== updateEnableSmoothTransition ||
      this.hiddenElementsHeight !== updateHiddenElementsHeight
    ) {
      this.enableSmoothTransition = updateEnableSmoothTransition;
      this.hiddenElementsHeight = updateHiddenElementsHeight;

      this.rootMarginOffset = this.enableSmoothTransition ? updateHiddenElementsHeight : 0;

      _createObserver.call(this);
    }

    if (this.doesSentinelExceedBoundary()) {
      this.el.classList.add(ClassName.STUCK);
    }

    _noStickyIfTooTall.call(this);

    // Create and dispatch custom event
    this[EventName.ON_UPDATE] = new CustomEvent(EventName.ON_UPDATE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_UPDATE]);

    return this;
  }

  /**
   * Remove the sticky.
   */
  remove() {
    _teardownInstance.call(this);
    // remove this sticky reference from array of instances
    const index = stickies.indexOf(this);
    stickies.splice(index, 1);

    // Create and dispatch custom event
    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_REMOVE]);
  }

  /**
   * Get an array of sticky instances.
   * @returns {Object[]} Array of sticky instances.
   */
  static getInstances() {
    return stickies;
  }
}

export default Sticky;
