import Util from '../../js/util';
import Flyout from '../flyout/flyout';
import * as FlyoutConfig from '../flyout/flyout';

export const Selector = {
  DATA_MOUNT: '[data-mount="tooltip"]'
};

export const EventName = {
  ON_HIDE: 'onHide',
  ON_SHOW: 'onShow',
  ON_UPDATE: 'onUpdate',
  ON_REMOVE: 'onRemove'
};

export const ClassName = {
  ...FlyoutConfig.ClassName,
  TOOLTIP: 'tooltip',
  ARROW: 'arrow'
};

export const Default = {
  ...FlyoutConfig.Default,
  SR_CLOSE: 'Press escape to close tooltip',
  ALIGNMENT: 'center'
};

const tooltips = [];

/**
 * The event handler for when the trigger is hovered over
 */
function _onEnter() {
  this.show();
}

/**
 * The event handler for when the trigger or menu is hovered over
 * @param {MouseEvent} event - The event object
 */
function _onLeave(event) {
  // Note: must check if `this.shown` is true for edge case when the mouse is hovered on the menu, but user tabs away from the trigger.
  // This results in an infinite `mouseleave` event on the menu unless we've tripped the `this.shown` flag to false.
  if (this.shown && !this.el.contains(event.relatedTarget) && !this.menu.contains(event.relatedTarget)) {
    this.hide();
  }
}

/**
 * The event handler for when a key is pressed on the trigger
 * @param {KeyboardEvent} event - The event object
 */
function _onKeydown(event) {
  if (this.shown && event.keyCode === Util.keyCodes.ESC) {
    this.hide();
  } else if (!this.shown && event.keyCode === Util.keyCodes.ENTER) {
    this.show();
  }
}

/**
 * The event handler for when a touch point is placed on the trigger
 * @param {TouchEvent} event - The event object
 */
function _onTouchstart(event) {
  // Prevent mouse events such as "click" from happening
  event.preventDefault();
  this.show();
}

/**
 * The event handler for when a touch point is removed from the trigger
 * Note: The event's target will be the element in which the touch occurred
 */
function _onTouchend() {
  if (this.shown) {
    this.hide();
  }
}

/**
 * The generic event handler for the document
 * @param {Event} event - The event object
 */
function _documentEventHandler(event) {
  if (this.shown && !this.el.contains(event.target) && !this.menu.contains(event.target)) {
    this.hide();
  }
}

/**
 * Gets the related menu or creates one if none is associated
 * @param {Node} node - The element associated with the menu, typically the tooltip trigger
 * @returns {Node} The menu element
 */
function _getOrCreateMenu(node) {
  if (node.attributes['aria-describedby']) {
    return document.querySelector(`#${node.attributes['aria-describedby'].value}`);
  }

  if (node.attributes.title) {
    const menu = document.createElement('div');
    const menuId = `${ClassName.TOOLTIP}_${Util.getUid()}`;

    const menuContentWrapper = document.createElement('div');
    const menuScreenReaderMsg = document.createElement('span');

    menuContentWrapper.textContent = node.getAttribute('title');
    menuContentWrapper.classList.add('tooltip-inner');

    menuScreenReaderMsg.classList.add('sr-only');
    menuScreenReaderMsg.textContent = node.getAttribute('data-sr-close') || Default.SR_CLOSE;

    menu.classList.add(ClassName.TOOLTIP);
    menu.setAttribute('id', menuId);
    menu.setAttribute('role', 'tooltip');

    menuContentWrapper.appendChild(menuScreenReaderMsg);
    menu.appendChild(menuContentWrapper);

    node.removeAttribute('title'); // Remove the default browser tooltip
    node.setAttribute('aria-describedby', menuId);
    node.after(menu);

    return menu;
  }
}

/**
 * Creates a decorative arrow element for the menu
 * @param {Node} node - The element to add the arrow to, typically the menu
 * @returns {Node} The arrow element
 */
function _createTooltipArrow(node) {
  const arrow = document.createElement('span');
  const wrapper = document.createElement('div');

  arrow.classList.add(`${ClassName.ARROW}`);
  wrapper.classList.add(`${ClassName.ARROW}-wrapper`);

  wrapper.append(arrow);
  node.append(wrapper);

  return arrow;
}

class Tooltip extends Flyout {
  /**
   * Create a tooltip, inherited from flyout
   * @param {Object} opts - The flyout options
   * @param {Node} opts.el - The element that toggles the flyout
   * @param {Node} [opts.menu] - The element that defines the flyout menu
   * @param {string} [opts.direction=right] - A string that defines the direction of the menu
   */
  constructor(opts) {
    // Set super options
    const flyoutOpts = { ...opts };
    flyoutOpts.menu = opts.menu || _getOrCreateMenu(flyoutOpts.el);
    flyoutOpts.alignment = FlyoutConfig._getAlignment(
      opts.alignment || flyoutOpts.el.getAttribute('data-alignment'),
      Default.ALIGNMENT
    );
    flyoutOpts.offset = opts.offset ? parseInt(opts.offset, 10) : 16;
    flyoutOpts.enableFade = typeof opts.enableFade === 'boolean' ? opts.enableFade : true;
    super(flyoutOpts);

    // Tooltip-specific setup
    this.arrow = _createTooltipArrow(this.menu);

    this.events = [
      { el: this.el, type: 'mouseenter', handler: _onEnter.bind(this) },
      { el: this.el, type: 'focusin', handler: _onEnter.bind(this) },
      { el: this.el, type: 'mouseleave', handler: _onLeave.bind(this) },
      { el: this.menu, type: 'mouseleave', handler: _onLeave.bind(this) },
      { el: this.el, type: 'keydown', handler: _onKeydown.bind(this) },
      { el: this.el, type: 'touchstart', handler: _onTouchstart.bind(this) },
      { el: this.el, type: 'touchend', handler: _onTouchend.bind(this) },
      { el: document, type: 'mousedown', handler: _documentEventHandler.bind(this) },
      { el: document, type: 'focusin', handler: _documentEventHandler.bind(this) }
    ];
    Util.addEvents(this.events);

    tooltips.push(this);
  }

  /**
   * Position the flyout menu
   */
  positionMenu() {
    super.positionMenu();
    this.positionMenuArrow();
  }

  /**
   * Position the menu's arrow
   */
  positionMenuArrow() {
    const position = this.currentPosition;
    const wrapper = this.menu.querySelector(`.${ClassName.ARROW}-wrapper`);

    if (wrapper !== null) {
      if (position.placement === 'top' || position.placement === 'bottom') {
        wrapper.style.width = null;
        wrapper.style.height = this.offset + 'px';
      } else {
        wrapper.style.width = this.offset + 'px';
        wrapper.style.height = null;
      }
    }

    // Reset positioning
    this.arrow.style.top = null;
    this.arrow.style.bottom = null;
    this.arrow.style.left = null;
    this.arrow.style.right = null;

    // Top and bottom menus
    if (position.placement === 'top' || position.placement === 'bottom') {
      if (position.alignment === 'start') {
        this.arrow.style[Default.START] =
          Math.round(this.boundingRect.el.width / 2) - this.arrow.offsetWidth / 2 + 'px';
      } else if (position.alignment === 'end') {
        this.arrow.style[Default.END] = Math.round(this.boundingRect.el.width / 2) - this.arrow.offsetWidth / 2 + 'px';
      } else {
        this.arrow.style.left = Math.round(this.boundingRect.menu.width / 2) - this.arrow.offsetWidth / 2 + 'px';
      }
      // Left and right menus
    } else if (position.alignment === 'start') {
      this.arrow.style.top = Math.round(this.boundingRect.el.height / 2) - this.arrow.offsetWidth / 2 + 'px';
    } else if (position.alignment === 'end') {
      this.arrow.style.bottom = Math.round(this.boundingRect.el.height / 2) - this.arrow.offsetWidth / 2 + 'px';
    } else {
      this.arrow.style.top = Math.round(this.boundingRect.menu.height / 2) - this.arrow.offsetWidth / 2 + 'px';
    }
  }

  /**
   * Show the menu
   */
  show() {
    // Create and dispatch custom event
    this[EventName.ON_SHOW] = new CustomEvent(EventName.ON_SHOW, { bubbles: true, cancelable: true });
    this.el.dispatchEvent(this[EventName.ON_SHOW]);
    if (this[EventName.ON_SHOW].defaultPrevented) {
      return;
    }

    super.show();
    this.el.focus();
  }

  /**
   * Hide the menu
   */
  hide() {
    // Create and dispatch custom event
    this[EventName.ON_HIDE] = new CustomEvent(EventName.ON_HIDE, { bubbles: true, cancelable: true });
    this.el.dispatchEvent(this[EventName.ON_HIDE]);
    if (this[EventName.ON_HIDE].defaultPrevented) {
      return;
    }

    // Never automatically set focus to Tooltip trigger when closing the tooltip
    super.hide({ setFocus: false });
  }

  /**
   * Update the tooltip instance
   * @param {object} [opts={}] - Options for updating the instance
   */
  update(opts = {}) {
    const flyoutOpts = { ...opts };

    // Enforce tooltips default alignment as fallback
    if (opts.alignment) {
      flyoutOpts.alignment = FlyoutConfig._getAlignment(opts.alignment, Default.ALIGNMENT);
    }

    super.update(flyoutOpts);

    // Create and dispatch custom event
    this[EventName.ON_UPDATE] = new CustomEvent(EventName.ON_UPDATE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_UPDATE]);
  }

  /**
   * Remove the tooltip instance
   */
  remove() {
    // Remove event handlers, observers, etc.
    Util.removeEvents(this.events);

    // Remove this reference from the array of instances
    const index = tooltips.indexOf(this);
    tooltips.splice(index, 1);

    // Create and dispatch custom event
    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.el.dispatchEvent(this[EventName.ON_REMOVE]);
  }

  /**
   * Get an array of tooltip instances
   * @returns {Object[]} Array of tooltip instances
   */
  static getInstances() {
    return tooltips;
  }
}

export default Tooltip;
