import Tooltip, { Default } from './tooltip';
import Util from '../../js/util';

const tooltipEscText = 'Press escape custom text';
const tooltipContent = 'hover over this tooltip to show text';

const tooltipDefaultHtml =
  '<button type="button" ' +
    'id="tooltip"' +
    `title="${tooltipContent}" ` +
  '>' +
    'Tooltip trigger' +
  '</button>';

const tooltipAltHtml =
  '<button type="button" ' +
    'id="tooltipAlt"' +
    'data-placement="bottom" ' +
    'data-alignment="start" ' +
    'title="hover over this tooltip to show text" ' +
    `data-sr-close="${tooltipEscText}" ` +
  '>' +
    'Tooltip trigger' +
  '</button>';

const enterKeyPressed = new KeyboardEvent('keydown', { keyCode: Util.keyCodes.ENTER, bubbles: true });
const escKeyPressed = new KeyboardEvent('keydown', { keyCode: Util.keyCodes.ESC, bubbles: true });
const focusInEvent = new MouseEvent('focusin', { bubbles: true, cancelable: true });
const mouseDownEvent = new MouseEvent('mousedown', { bubbles: true, cancelable: true });
const mouseEnterEvent = new MouseEvent('mouseenter', { bubbles: true, cancelable: true });
const mouseLeaveEvent = new MouseEvent('mouseleave', { bubbles: true, cancelable: true });
const touchStartEvent = new TouchEvent('touchstart');
const touchEndEvent = new TouchEvent('touchend');

// Set up our document body
document.body.innerHTML = tooltipDefaultHtml + tooltipAltHtml;

describe('Tooltip', () => {
  let tooltipDefault;

  beforeEach(() => {
    // Initialize tooltip
    tooltipDefault = new Tooltip({
      el: document.querySelector('#tooltip')
    });
  });

  afterEach(() => {
    // Remove the instance for garbage collection
    tooltipDefault.remove();
  });

  it('should be initialized', () => {
    const instances = Tooltip.getInstances();
    expect(instances.indexOf(tooltipDefault)).not.toEqual(-1);
    expect(Tooltip.getInstances().length).toEqual(1);
    expect(tooltipDefault.el.id).toEqual('tooltip');
    expect(tooltipDefault.placement).toEqual('right');
    expect(tooltipDefault.alignment).toEqual('center');
    expect(tooltipDefault.offset).toEqual(16);
    expect(tooltipDefault.enableReflow).toEqual(true);
    expect(tooltipDefault.enableFade).toEqual(true);
    expect(tooltipDefault.shown).toEqual(false);
  });

  it('should create a menu', () => {
    const tooltipInner = tooltipDefault.menu.querySelector('.tooltip-inner');
    expect(tooltipDefault.menu instanceof HTMLElement).toEqual(true);
    expect(tooltipDefault.menu.getAttribute('role')).toEqual('tooltip');
    expect(tooltipDefault.el.getAttribute('aria-describedby')).toEqual(tooltipDefault.menu.id);
    expect(tooltipInner.innerHTML).toEqual(`${tooltipContent}<span class="sr-only">${Default.SR_CLOSE}</span>`);
  });

  it('should create an arrow element', () => {
    expect(tooltipDefault.arrow instanceof HTMLElement).toEqual(true);
    expect(tooltipDefault.arrow.classList.contains('arrow')).toEqual(true);
  });

  describe('with options set using HTML attributes', () => {
    let tooltipAlt;

    beforeEach(() => {
      tooltipAlt = new Tooltip({
        el: document.querySelector('#tooltipAlt')
      });
    });

    afterEach(() => {
      tooltipAlt.remove();
    });

    it('should be initialized', () => {
      const instances = Tooltip.getInstances();
      expect(instances.indexOf(tooltipAlt)).not.toEqual(-1);
      expect(tooltipAlt.el.id).toEqual('tooltipAlt');
      expect(tooltipAlt.placement).toEqual('bottom');
      expect(tooltipAlt.alignment).toEqual('start');
      expect(tooltipAlt.offset).toEqual(16);
      expect(tooltipAlt.enableReflow).toEqual(true);
      expect(tooltipAlt.enableFade).toEqual(true);
      expect(tooltipAlt.shown).toEqual(false);
    });

    it('should use the `data-sr-close` text for the screenreader only text', () => {
      const tooltipInner = tooltipAlt.menu.querySelector('.tooltip-inner');
      expect(tooltipInner.innerHTML).toEqual(`${tooltipContent}<span class="sr-only">${tooltipEscText}</span>`);
    });
  });

  describe('when the tooltip is hidden', () => {
    let eventValue;

    beforeAll(() => {
      tooltipDefault.el.addEventListener('onHide', () => {
        eventValue = 'hidden';
      });
    });

    beforeEach(() => {
      tooltipDefault.hide();
    });

    it('should hide the flyout', () => {
      expect(tooltipDefault.shown).toEqual(false);
      expect(tooltipDefault.el.classList.contains('active')).toEqual(false);
      expect(tooltipDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should not set focus to the button', () => {
      expect(document.activeElement).not.toEqual(tooltipDefault.el);
    });

    it('should open the tooltip when hovering over the button', () => {
      tooltipDefault.el.dispatchEvent(mouseEnterEvent);
      expect(tooltipDefault.shown).toEqual(true);
      expect(tooltipDefault.el.classList.contains('active')).toEqual(true);
      expect(tooltipDefault.menu.classList.contains('show')).toEqual(true);
      expect(document.activeElement).toEqual(tooltipDefault.el);
    });

    it('should open the tooltip when focusing on the button', () => {
      tooltipDefault.el.dispatchEvent(focusInEvent);
      expect(tooltipDefault.shown).toEqual(true);
      expect(tooltipDefault.el.classList.contains('active')).toEqual(true);
      expect(tooltipDefault.menu.classList.contains('show')).toEqual(true);
      expect(document.activeElement).toEqual(tooltipDefault.el);
    });

    it('should open the tooltip when the enter key is pressed on the button', () => {
      tooltipDefault.el.dispatchEvent(enterKeyPressed);
      expect(tooltipDefault.shown).toEqual(true);
      expect(tooltipDefault.el.classList.contains('active')).toEqual(true);
      expect(tooltipDefault.menu.classList.contains('show')).toEqual(true);
      expect(document.activeElement).toEqual(tooltipDefault.el);
    });

    it('should open the tooltip when a touch point is placed on the button', () => {
      tooltipDefault.el.dispatchEvent(touchStartEvent);
      expect(tooltipDefault.shown).toEqual(true);
      expect(tooltipDefault.el.classList.contains('active')).toEqual(true);
      expect(tooltipDefault.menu.classList.contains('show')).toEqual(true);
      expect(document.activeElement).toEqual(tooltipDefault.el);
    });

    it('should trigger the `onHide` custom event', () => {
      expect(eventValue).toEqual('hidden');
    });
  });

  describe('when the tooltip is shown', () => {
    let eventValue;

    beforeAll(() => {
      tooltipDefault.el.addEventListener('onShow', () => {
        eventValue = 'shown';
      });
    });

    beforeEach(() => {
      tooltipDefault.show();
    });

    it('should show the flyout', () => {
      expect(tooltipDefault.shown).toEqual(true);
      expect(tooltipDefault.el.classList.contains('active')).toEqual(true);
      expect(tooltipDefault.menu.classList.contains('show')).toEqual(true);
    });

    it('should set focus to the button', () => {
      expect(document.activeElement).toEqual(tooltipDefault.el);
    });

    it('should close the tooltip when the esc key is pressed on the trigger', () => {
      tooltipDefault.el.dispatchEvent(escKeyPressed);
      expect(tooltipDefault.shown).toEqual(false);
      expect(tooltipDefault.el.classList.contains('active')).toEqual(false);
      expect(tooltipDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should close the tooltip when hovering away from the button', () => {
      tooltipDefault.el.dispatchEvent(mouseLeaveEvent);
      expect(tooltipDefault.shown).toEqual(false);
      expect(tooltipDefault.el.classList.contains('active')).toEqual(false);
      expect(tooltipDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should keep the tooltip open when hovering from the button to the flyout', () => {
      const mouseLeaveToMenuEvent = new MouseEvent('mouseleave', { bubbles: true, cancelable: true, relatedTarget: tooltipDefault.menu });
      tooltipDefault.el.dispatchEvent(mouseLeaveToMenuEvent);
      expect(tooltipDefault.shown).toEqual(true);
      expect(tooltipDefault.el.classList.contains('active')).toEqual(true);
      expect(tooltipDefault.menu.classList.contains('show')).toEqual(true);
    });

    it('should close the tooltip when hovering away from the flyout', () => {
      tooltipDefault.menu.dispatchEvent(mouseLeaveEvent);
      expect(tooltipDefault.shown).toEqual(false);
      expect(tooltipDefault.el.classList.contains('active')).toEqual(false);
      expect(tooltipDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should close the tooltip when focusing away from button', () => {
      document.dispatchEvent(focusInEvent);
      expect(tooltipDefault.shown).toEqual(false);
      expect(tooltipDefault.el.classList.contains('active')).toEqual(false);
      expect(tooltipDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should close the tooltip when a touch point is removed on the button', () => {
      tooltipDefault.el.dispatchEvent(touchEndEvent);
      expect(tooltipDefault.shown).toEqual(false);
      expect(tooltipDefault.el.classList.contains('active')).toEqual(false);
      expect(tooltipDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should close the tooltip when clicking outside the flyout', () => {
      document.dispatchEvent(mouseDownEvent);
      expect(tooltipDefault.shown).toEqual(false);
      expect(tooltipDefault.el.classList.contains('active')).toEqual(false);
      expect(tooltipDefault.menu.classList.contains('show')).toEqual(false);
    });

    it('should trigger the `onShow` custom event', () => {
      expect(eventValue).toEqual('shown');
    });
  });

  describe('when the instance is updated', () => {
    let eventValue;

    beforeAll(() => {
      tooltipDefault.el.addEventListener('onUpdate', () => {
        eventValue = 'updated';
      });
    });

    it('should update the alignment property with a valid enum', () => {
      tooltipDefault.update({ alignment: 'end' });
      expect(tooltipDefault.alignment).toEqual('end');

      tooltipDefault.update({ alignment: 'hi' });
      expect(tooltipDefault.alignment).toEqual('center');
    });

    it('should update the placement property with a valid enum', () => {
      tooltipDefault.update({ placement: 'left' });
      expect(tooltipDefault.placement).toEqual('left');

      tooltipDefault.update({ placement: 'hi' });
      expect(tooltipDefault.placement).toEqual('right');
    });

    it('should update the fade effect option', () => {
      tooltipDefault.update({ enableFade: false });
      expect(tooltipDefault.enableFade).toEqual(false);
      expect(tooltipDefault.menu.classList.contains('fade')).toEqual(false);

      tooltipDefault.update({ enableFade: true });
      expect(tooltipDefault.enableFade).toEqual(true);
      expect(tooltipDefault.menu.classList.contains('fade')).toEqual(true);
    });

    it('should trigger the `onUpdate` custom event', () => {
      tooltipDefault.update();
      expect(eventValue).toEqual('updated');
    });
  });

  describe('when the instance is removed', () => {
    let eventValue;

    beforeAll(() => {
      tooltipDefault.el.addEventListener('onRemove', () => {
        eventValue = 'removed';
      });
    });

    beforeEach(() => {
      tooltipDefault.remove();
    });

    it('should be removed from the list of instances', () => {
      const instances = Tooltip.getInstances();
      expect(instances.indexOf(tooltipDefault)).toEqual(-1);
    });

    it('should trigger the `onRemove` custom event', () => {
      expect(eventValue).toEqual('removed');
    });
  });
});
