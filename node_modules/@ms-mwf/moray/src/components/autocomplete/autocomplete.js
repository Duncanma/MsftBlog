import Util from '../../js/util';
/*
 * @constant
 * @type {string}
 */
export const Config = {
  DEFAULT_SEARCH_RESULT: 10
};

const autocompleteInstances = [];

export const Selector = {
  RESULT_LIST: '.result-list',
  RESULTS_CONTAINER: '.search-results-container',
  SEARCH_INPUT: '.search-input',
  RESULT_STATUS: '.result-status',
  LIST_FIRST_CHILD: 'li:first-child',
  LIST_SELECTED: 'li.selected'
};

export const Messages = {
  // default message is set, if custom message not set.
  RESULTS_TEMPLATE_MANY: '%{numResults} results are available, use up and down arrow keys to navigate',
  RESULTS_TEMPLATE_ONE: '%{numResults} result is available, use up and down arrow keys to navigate',
  NO_RESULTS: 'No results are available'
};

export const Errors = {
  DATA_TYPE_ERROR: 'Data must be of type Array[<string>] or Array[{value: <string>}]'
};

export const ClassName = {
  ACTIVE: 'active',
  SELECTED: 'selected'
};

export const EventName = {
  ON_CLOSE: 'onClose',
  ON_OPEN: 'onOpen',
  ON_UPDATE: 'onUpdate',
  ON_REMOVE: 'onRemove'
};

/*
* filter the data.
*/
function _filterData(data) {
  const re = _getSearchPattern.bind(this)();
  return data.filter(item => {
    if ((typeof item === 'object' && re.test(item.value)) || (typeof item === 'string' && re.test(item))) {
      return item;
    }

    return false;
  });
}

/*
* fetch the data to li tag.
*/
function _fetchData(data) {
  // data is an array of results
  const searchData = data.slice(0, Config.DEFAULT_SEARCH_RESULT);
  let targetHtmlContainer = '';
  let str = null;
  let resultsMessage;

  // if the length of searchData is 0, there are no results
  if (searchData.length > 0 && this.searchInput.value !== '') {
    searchData.forEach(item => {
      if (typeof item === 'string') {
        str = item;
      } else if (typeof item === 'object') {
        str = item.value;
      }

      targetHtmlContainer += '<li class="result"  role="option" tabindex="-1">' + _highlightMatch.bind(this)(str) + '</li>';
    });

    resultsMessage = Util.interpolateString((searchData.length > 1 ? this.resultsAvailableTemplateMany : this.resultsAvailableTemplateOne), { numResults: searchData.length });

    if (!this.shown) {
      this.open();
    }
  } else {
    this.close();
    resultsMessage = this.noResultsMsg;
  }

  this.target.innerHTML = targetHtmlContainer;

  /* Sets sr_only message for a11y */
  this.container.querySelector(Selector.RESULT_STATUS).textContent = resultsMessage;
}

/*
* populates the selected matching values
*/
function _populateSelect() {
  let filteredSearchData = this.suggestedData;
  if (typeof this.suggestedData === 'object') {
    if (this.filter === 'true') {
      filteredSearchData = _filterData.bind(this)(filteredSearchData);
    }

    _fetchData.bind(this)(filteredSearchData);
  }
}

/**
  @func _clearSuggestionsMenu
  @desc Clears the results from the suggestions menu.
  @this AutoComplete
*/
function _clearSuggestionsMenu() {
  this.target.innerHTML = '';
  this.container.querySelector(Selector.RESULT_STATUS).textContent = '';
}

/**
  @func _getSearchPattern
  @desc Returns a new regular expression object from the internal searchInput property.
  @returns {RegExp} Regular expression object with the autocomplete's searchInput value as the source.
  @this AutoComplete
*/
function _getSearchPattern() {
  /* replacing instances of regex characters with string literals to disable use of regular expressions in search input */
  const re = /([()*+.?\\])/gi;
  const sanitizedInput = this.searchInput.value.replace(re, '\\$&');
  /* Second parameter flags - 'g': global (matches multiple instances in string), 'i': case insensitive */
  /* \\b used to only begin match at start of a word (rather than matching a character in the middle of a word) */
  /* \\s used to allow matching of accepted special characters (e.g. &) when in between words */
  return new RegExp('\\b\\s?' + sanitizedInput, 'gi');
}

/**
  @func _setSuggestionItemSelectedStatus
  @desc Given a string, returns the same string with a <strong> tag encapsulating the matching substring.
  @param {string} str - String used to create the regex for matching.
  @returns {string} String with a <strong> tag encapsulating matched sub string.
  @this AutoComplete
*/
function _highlightMatch(str) {
  const re = _getSearchPattern.bind(this)();
  return str.replace(re, '<strong>$&</strong>');
}

/**
  @func _removeSuggestionItemSelectedStatus
  @desc Removes the HTML classes and attributes used to markup the "selected" status for suggestions (li elements) displayed in the auto suggestion menu (ul element, this.target).
  @param {Node} element - HTML element that should remove classes/attributes for showing "selected" status
*/
function _removeSuggestionItemSelectedStatus(element) {
  element.classList.remove(ClassName.SELECTED);
  element.removeAttribute('aria-selected');
}

/**
  @func _setSuggestionItemSelectedStatus
  @desc Sets the HTML classes and attributes used to markup the "selected" status for suggestions (li elements) displayed in the auto suggestion menu (ul element, this.target).
  @param {Node} element - HTML element that should receive classes/attributes for showing "selected" status
*/
function _setSuggestionItemSelectedStatus(element) {
  element.classList.add(ClassName.SELECTED);
  element.setAttribute('aria-selected', true);
  element.focus();
}

/**
  @func _verifyData
  @desc Verifies that the passed in parameter is either Array[<string>] or Array[{value: <string>}]
  @param {Array} data - Data to verify.
  @returns {boolean} Whether the data has the correct structure.
*/
function _verifyData(data) {
  if (Array.isArray(data) && data.every(entry => typeof entry === 'string' || (typeof entry === 'object' && Object.keys(entry).includes('value') && typeof entry.value === 'string'))) {
    return true;
  }

  return false;
}

/***********/
/* EVENTS */
/***********/

/*
* close suggested list.
*/
function _onDocumentClick(e) {
  if (e.target !== this.searchInput && e.target !== this.searchResultsContainer) {
    const _target = this.target;
    _target.classList.remove(ClassName.ACTIVE);
    this.searchInput.setAttribute('aria-expanded', false);
  }
}

/*
* after entering the data,populating the value through populateSelect function
* @param {object} e - present event
*/
function _onSearchInputInput(e) {
  if (this.searchInput.value === '') {
    _clearSuggestionsMenu.bind(this)(e);

    if (this.shown) {
      this.close();
    }
  } else {
    _populateSelect.bind(this)(e);
  }
}

/**
  @func _onSearchInputKeyDown
  @desc Handles keydown event for arrow down.
  @param {Event} e - Keydown event attached to this.searchInput
  @this AutoComplete
*/
function _onSearchInputKeyDown(e) {
  const suggestionMenu = this.target;
  if (e.keyCode === Util.keyCodes.ARROW_DOWN && suggestionMenu.children.length > 0) {
    this.open();
    _setSuggestionItemSelectedStatus(suggestionMenu.querySelector(Selector.LIST_FIRST_CHILD));
  }

  if (e.keyCode === Util.keyCodes.TAB && this.shown) {
    this.close();
  }
}

/**
  @func _onSearchInputFocus
  @desc Sets the cursor position to the end of the text when focus is set to the input element
  @this AutoComplete
*/
function _onSearchInputFocus() {
  /* Requires 2 parameters */
  this.searchInput.setSelectionRange(this.searchInput.value.length, this.searchInput.value.length);
}

/**
  @func _onSuggestionMenuKeyDown
  @desc Handles keydown events for backspace, arrow right, and character input.
Is attached to this.target (ul with suggestions that appears underneath input) during initializaiton.
  @param {Event} e
  @this AutoComplete
*/
function _onSuggestionMenuKeyDown(e) {
  if (this.target.classList.contains(ClassName.ACTIVE)) {
    const _target = this.target;
    const selected = _target.querySelector(Selector.LIST_SELECTED);
    let prevSibling;
    switch (e.keyCode) {
      case Util.keyCodes.ARROW_UP:
        if (selected) {
          prevSibling = selected.previousElementSibling;
          _removeSuggestionItemSelectedStatus(selected);
          if (prevSibling) {
            _setSuggestionItemSelectedStatus(prevSibling);
          } else {
            this.searchInput.focus();
          }
        }

        break;
      case Util.keyCodes.ARROW_DOWN:
        if (_target.querySelector('li') && !_target.querySelector(Selector.LIST_SELECTED)) {
          const firstLiElement = _target.querySelector(Selector.LIST_FIRST_CHILD);
          _setSuggestionItemSelectedStatus(firstLiElement);
        } else {
          let nextSibling = null;
          nextSibling = selected.nextElementSibling;
          if (nextSibling) {
            _removeSuggestionItemSelectedStatus(selected);
            _setSuggestionItemSelectedStatus(nextSibling);
          }
        }

        break;
      case Util.keyCodes.ARROW_RIGHT:
      case Util.keyCodes.BACKSPACE:
        this.searchInput.focus();
        break;
      case Util.keyCodes.ENTER:
        if (selected) {
          this.searchInput.value = selected.textContent;
          _clearSuggestionsMenu.bind(this)();
          this.searchInput.focus();
          this.close();
          e.preventDefault();
        }

        break;
      case Util.keyCodes.ESC:
        this.searchInput.value = '';
        this.searchInput.focus();
        _clearSuggestionsMenu.bind(this)();
        break;
      case Util.keyCodes.TAB:
        this.close();
        this.searchInput.focus();
        _removeSuggestionItemSelectedStatus(selected);

        break;
      default:
        if (e.key.length === 1) {
          this.searchInput.focus();
        }

        break;
    }
  }
}

/*
* fetch the suggested data from drop down to the autocomplete
* @param {object} e - present event
*/
function _onSuggestionMenuMouseUp(e) {
  this.searchInput.value = e.target.textContent;
  _clearSuggestionsMenu.bind(this)();
  this.searchInput.focus();
  this.close();
  e.stopPropagation();
}

/*
 * Class representing a Autocomplete.
 */
export default class AutoComplete {
  /**
   * Create the Autocomplete.
   @param {Object} opts - The autocomplete options.
   @param {Node} opts.target - The autocomplete DOM node.
   @throws {TypeError} Will throw a TypeError when opts.data is not of type Array[<string>] or Array[{value: <string>}]
   */
  constructor(opts) {
    this.container = opts.target;
    // defaults to a sr message for en locales if none is provided
    this.resultsAvailableTemplateMany = opts.multipleResultsMsg || Messages.RESULTS_TEMPLATE_MANY;
    this.resultsAvailableTemplateOne = opts.oneResultMsg || Messages.RESULTS_TEMPLATE_ONE;
    this.noResultsMsg = opts.noResultsMsg || Messages.NO_RESULTS;
    this.filter = opts.filter || opts.target.getAttribute('data-filter') || true;
    if (_verifyData(opts.data)) {
      this.suggestedData = opts.data;
    } else {
      throw new TypeError(Errors.DATA_TYPE_ERROR);
    }

    this.target = opts.target.querySelector(Selector.RESULT_LIST);
    this.searchResultsContainer = this.container.querySelector(Selector.RESULTS_CONTAINER);
    this.searchInput = this.container.querySelector(Selector.SEARCH_INPUT);
    this.shown = false;

    autocompleteInstances.push(this);

    // Add event handlers.
    this.events = [
      { el: document, type: 'click', handler: _onDocumentClick.bind(this) },
      { el: this.searchInput, type: 'input', handler: _onSearchInputInput.bind(this) },
      { el: this.searchInput, type: 'keydown', handler: _onSearchInputKeyDown.bind(this) },
      { el: this.searchInput, type: 'focus', handler: _onSearchInputFocus.bind(this) },
      { el: this.target, type: 'mouseup', handler: _onSuggestionMenuMouseUp.bind(this) },
      { el: this.target, type: 'keydown', handler: _onSuggestionMenuKeyDown.bind(this) }
    ];
    Util.addEvents(this.events);
  }

  /*
   * Get an array of autocomplete instances.
   * @returns {Object[]} Array of search instances.
   */
  static getInstances() {
    return autocompleteInstances;
  }

  /**
  @func open
  @desc Opens the suggestions menu.
  @this AutoComplete
  */
  open() {
    // Create and dispatch custom event
    this[EventName.ON_OPEN] = new CustomEvent(EventName.ON_OPEN, { bubbles: true, cancelable: true });
    this.container.dispatchEvent(this[EventName.ON_OPEN]);
    if (this[EventName.ON_OPEN].defaultPrevented) {
      return;
    }

    this.shown = true;
    this.target.classList.add(ClassName.ACTIVE);
    this.searchInput.setAttribute('aria-expanded', true);
  }

  /**
  @func close
  @desc Closes the suggestions menu.
  @this AutoComplete
  */
  close() {
    // Create and dispatch custom event
    this[EventName.ON_CLOSE] = new CustomEvent(EventName.ON_CLOSE, { bubbles: true, cancelable: true });
    this.container.dispatchEvent(this[EventName.ON_CLOSE]);
    if (this[EventName.ON_CLOSE].defaultPrevented) {
      return;
    }

    this.shown = false;
    this.target.classList.remove(ClassName.ACTIVE);
    this.searchInput.setAttribute('aria-expanded', false);
  }

  /**
  @func update
  @desc Updates the value of this.searchInput with given string.
  @param {string} value - String to set this.searchInput
  @this AutoComplete
  */
  update(value) {
    // Changed if(value) to if(typeof value === 'string') to allow empty string values.
    if (typeof value === 'string') {
      this.searchInput.value = value;

      if (value) {
        _populateSelect.bind(this)();

        // Create and dispatch custom event
        this[EventName.ON_UPDATE] = new CustomEvent(EventName.ON_UPDATE, { bubbles: true });
        this.container.dispatchEvent(this[EventName.ON_UPDATE]);

        // Is empty string. Menu should be closed.
      } else {
        this.close();
      }
    }
  }

  /**
  @func updateDataSource
  @desc Closes the suggestions menu.
  @param {Array} data - Data to set this.suggestedData
  @this AutoComplete
  @throws {TypeError} Will throw a TypeError when opts.data is not of type Array[<string>] or Array[{value: <string>}]
  */
  updateDataSource(data) {
    if (_verifyData(data)) {
      this.suggestedData = data;
      _populateSelect.bind(this)();
    } else {
      throw new TypeError(Errors.DATA_TYPE_ERROR);
    }
  }

  /**
   * Remove all event listeners.
   */
  remove() {
    Util.removeEvents(this.events);

    // Remove this autocomplete reference from array of instances
    const index = autocompleteInstances.indexOf(this);
    autocompleteInstances.splice(index, 1);

    // Create and dispatch custom event
    this[EventName.ON_REMOVE] = new CustomEvent(EventName.ON_REMOVE, { bubbles: true });
    this.container.dispatchEvent(this[EventName.ON_REMOVE]);
  }
}
